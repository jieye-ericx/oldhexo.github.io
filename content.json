{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Python","text":"PIL&amp;Pillow Python图像库PIL(Python Image Library)是python的第三方图像处理库，但是由于其强大的功能与众多的使用人数，几乎已经被认为是python官方图像处理库了。其官方主页为:PIL。 PIL历史悠久，原来是只支持python2.x的版本的，后来出现了移植到python3的库pillow,pillow号称是friendly fork for PIL,其功能和PIL差不多，但是支持python3。本文主要介绍PIL那些最常用的特性与用法,主要参考自:http://www.effbot.org/imagingbookPIL可以做很多和图像处理相关的事情: 图像归档(Image Archives)。PIL非常适合于图像归档以及图像的批处理任务。你可以使用PIL创建缩略图，转换图像格式，打印图像等等。 图像展示(Image Display)。PIL较新的版本支持包括Tk PhotoImage，BitmapImage还有Windows DIB等接口。PIL支持众多的GUI框架接口，可以用于图像展示。 图像处理(Image Processing)。PIL包括了基础的图像处理函数，包括对点的处理，使用众多的卷积核(convolution kernels)做过滤(filter),还有颜色空间的转换。PIL库同样支持图像的大小转换，图像旋转，以及任意的仿射变换。PIL还有一些直方图的方法，允许你展示图像的一些统计特性。这个可以用来实现图像的自动对比度增强，还有全局的统计分析等。 Image Module open 123from PIL import Image ##调用库，包含图像类im = Image.open(\"3d.jpg\") ##文件存在的路径，如果没有路径就是当前目录下文件im.show()","link":"/2020/05/16/Python/Python/"},{"title":"正则表达式","text":"正则表达式学习&amp;特定语言的 正则表达式匹配字符规则 single char quantifiers(数量) position(位置) \\d 匹配数字 * 0个或者更多 ^一行的开头 \\w 匹配word(数字、字母) + 1个或更多，至少1个 $一行的结尾 \\W 匹配非word(数字、字母) ? 0个或1个,一个Optional \\b 单词”结界”(word bounds) \\s 匹配white space(包括空格、tab等) {min,max}出现次数在一个范围内 \\S 匹配非white space(包括空格、tab等) {n}匹配出现n次的 . 匹配任何，任何的字符 或 [] 这个符号用来表示逻辑关系或，比如[abc]表示a或者b或c.[-.]表示符号-或者.号(注意这里，在[]中的.号代表的就是这个符号，但是如果在其外面，表示个匹配所有。 所以如果不在[]之中，想要匹配’.’，就要通过转意符号\\.) 特殊 -连接符是第一个字符时 比如[-.]的含义是连字符-或者点符.。 但是，如果当连字符不是第一个字符时，比如[a-z]，这就表示是从字母a到字符z。 []中的^ ^在之前介绍中，是表示一行开头，但是在[]中，有着不同的含义。 [ab] 表示a或者b [^ab] 啥都行，只要不是a或b(anythings except a and b)，相当于取反 () 除了使用[]表示或逻辑,()也是可以的。用法是(a|b)表示a或者b,见例子 重要 分组捕获(capturing groups) 12345678212-555-1234915-412-1333//我想要保留区号，把后面的电话号码变为通用性的👇👇👇👇👇👇👇👇👇👇👇👇212-xxx-xxxx915-xxx-xxxx复制代码 按照之前的做法\\d{3}-\\d{3}-\\d{4},这种匹配的方式，是将整个电话号码作为一个组(group)匹配起来。 我们把212-555-1234这样的叫Group0。 这个时候，如果我们加了一个括号\\d{3}-(\\d{3})-\\d{4}，那么匹配到的555就叫Group1。 以此类推，如果有两个小括号\\d{3}-(\\d{3})-(\\d{4})那么分组就是下面的情况： 123212-555-1234 Group0555 Group11234 Group2 至于选择分组，两种方式 第一种使用$符号，比如$1 代表555,$2代表1234； 第二种，使用\\,比如\\1代表555。 $ 如： 12 reg: \\(?(\\d{3})[-.)]\\d{3}[-.]\\d{4}replace: $1-xxx-xxxx 注意：$0 是所有匹配到的，所以第一个加括号的是$1 / is is a a dog , I think think this is is really a a good good dog. Don't you you thinks so so ?```123456789101112131415161718 匹配比如`is is` `so so`这样连续的序列，就用到了下面的表达方式: `(\\w+)\\s\\1`![](https://cdn.jsdelivr.net/gh/radoapx/rad-figure-bed/PicGo/blogs/正则表达式/20200514214043.png) 差不多达到效果，但是有一些小的bug。比如第一句话`This is is a` 这个就匹配不准确，会把第一个This的后面字母匹配进去。 **这就用到第一节说的字符结界 `\\b`了**，就变成了`\\b(\\w+)\\s\\1\\b`### 一些例子+ 现在想找5个字母组成的单词`\\b\\w{5}\\b`+ `The lynk is quite a link don't you think? l nk l(nk` `l[yi (]nk` `lynk link l nk l(nk`+ 请匹配所有可能的电话号码： These are some phone numbers 915-134-3122. Also, you can call me at 643.123.1333 and of course, I’m always reachable at (212)867-5509 1234第一步： `\\d{3}[-.]\\d{3}[-.]\\d{4}`第二步: 为了能够匹配括号，可以使用?来，因为这是一个option选择。所以最后就成了 (?\\d{3}[-.)]\\d{3}[-.]\\d{4} 1234 **这里还是要说明，在[]中，特殊字符不需要转义，可以直接使用，比如`[.()]`,但是在外面，是需要转义的`\\(` `\\.`等**+ 匹配所有email gaoyaqi411@126.com dyumc@google.net sam@sjtu.edu 123456789101112131415161718 **思路**： 首先要想我到底相匹配什么，这里我想匹配的是 1. 任何一个以words开头的，一个或更多 `\\w+` 2. 紧接着是一个`@`符号 `\\w+@` 3. 接着有一个或者更多的words `\\w+@\\w+` 4. 接着一个`.`标点 `\\w+@\\w+\\.` 5. 接着一个`com` `net` 或 `edu` `\\w+@\\w+\\.(com|net|edu)` **还是提醒注意第四步的`\\.`转义符号** 好了，这样几可以匹配以上的所有邮箱了。但是还有一个问题，因为邮箱用户名是可以有`.`的，比如`vincent.ko@126.com` 其实仍然很简单，修复如下： `[\\w.]+@\\w+\\.(com|net|edu)`+ 现在有一个名单列表，但是姓和名称是反的，我需要把他交换过来 shiffina, Daniel shifafl, Daniell shquer, Danny 1 reg: (\\w+),\\s(\\w+) replace: $2 $1 ### 总结 1. `[]`的作用，用英文表达就是&quot;alternation&quot;,表达一个或的逻辑； 2. `/[-.(]/` 在符号中的连字符`-`放在第一位表示连字符本身，如果放在中间，表示&quot;从..到..&quot;，比如`[a-z]`表示a-z 3. `[.)]` 括号中的特殊符号不需要转义，就表示其本身 4. [^ab]` 括号中的`^`表示非，anythings except `a` and `b 5. `(a|b)`也可表示选择，但是它有更强大的功能.... # 在js中的应用","link":"/2020/05/16/%E5%85%B6%E4%BB%96/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"利用Element实现响应式导航栏","text":"开始之前按照计划，前端使用Vue.js+Element UI，但在设计导航栏时，发现element没有提供传统意义上的页面顶部导航栏组件，只有一个可以用在很多需要选择tab场景的导航菜单，便决定在其基础上改造，由于我认为实现移动端良好的体验是必须的，所以便萌生了给其增加响应式功能的想法。 需求分析与拆解假设我们的导航栏有logo和四个el-menu-item。 给window绑定监听事件，当宽度小于a时，四个链接全部放入右侧el-submenu的子菜单： 当宽度大于a时，右侧el-submenu不显示，左侧el-menu-item正常显示： 所以，先创建一个数组，存储所有所需的item： 123456navItems: [ { name: \"Home\", indexPath: \"/home\", index: \"1\" }, { name: \"Subscribe\", indexPath: \"/subscribe\", index: \"2\"}, { name: \"About\", indexPath: \"/about\", index: \"3\" }, { name: \"More\", indexPath: \"/more\", index: \"4\" }] 监听宽度很明显功能实现的关键是随时监听窗口的变化，根据对应的宽度做出响应，在data中，我使用screenWidth变量来存储窗口大小,保存初始打开页面时的宽度: 123456data() { return { screenWidth: document.body.clientWidth ...... }} 接下来在mounted中绑定屏幕监听事件，将最新的可用屏幕宽度赋给screenWidth： 12345mounted() { window.onresize = () =&gt; { this.screenWidth = document.body.clientWidth }} (关于document和window中N多的关于高度和宽度的属性，可以参考这篇文章。) 为了防止频繁触发resize函数导致页面卡顿，可以使用一个定时器，控制下screenWidth更新的频率： 1234567891011121314watch: { screenWidth(newValue) { // 为了避免频繁触发resize函数导致页面卡顿，使用定时器 if (!this.timer) { // 一旦监听到的screenWidth值改变，就将其重新赋给data里的screenWidth this.screenWidth = newValue; this.timer = true; setTimeout(() =&gt; { //console.log(this.screenWidth); this.timer = false; }, 400); } }} 显示有了屏幕宽度的实时数据后，就可以以computed的方式控制menuItem了。 123456789computed: { ... leftNavItems: function() { return this.screenWidth &gt;= 600 ? this.navItems : {}; }, rightNavItems: function() { return this.screenWidth &lt; 600 ? this.navItems : {}; }}, 通过简单的判断即可在窗口宽度变化时，将菜单里的内容放入预先设置的正常菜单或者当宽度小于600时显示的右侧下拉菜单,附上html部分代码： 123456789101112131415161718192021222324252627&lt;el-menu text-color=\"#2d2d2d\" id=\"navid\" class=\"nav\" mode=\"horizontal\" @select=\"handleSelect\"&gt; &lt;el-menu-item class=\"logo\" index=\"0\" route=\"/home\"&gt; &lt;img class=\"logoimg\" src=\"../assets/img/logo.png\" alt=\"logo\" /&gt; &lt;/el-menu-item&gt; &lt;el-menu-item :key=\"key\" v-for=\"(item,key) in leftNavItems\" :index=\"item.index\" :route=\"item.activeIndex\" &gt;{{item.name}}&lt;/el-menu-item&gt; &lt;el-submenu style=\"float:right;\" class=\"right-item\" v-if=\"Object.keys(rightNavItems).length === 0?false:true\" index=\"10\" &gt; &lt;template slot=\"title\"&gt; &lt;i class=\"el-icon-s-fold\" style=\"font-size:28px;color:#2d2d2d;\"&gt;&lt;/i&gt; &lt;/template&gt; &lt;el-menu-item :key=\"key\" v-for=\"(item,key) in rightNavItems\" :index=\"item.index\" :route=\"item.activeIndex\" &gt;{{item.name}}&lt;/el-menu-item&gt; &lt;/el-submenu&gt;&lt;/el-menu&gt; 总结总的来说，一个丐版就算完成了，这里只提供了一种可能的思路，如需实践可以增加更多判断规则及功能。（主要是已经转用Vuetify啦~）","link":"/2020/05/16/%E5%8D%9A%E5%AE%A2/%E5%88%A9%E7%94%A8Element%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%BC%E8%88%AA%E6%A0%8F/"},{"title":"HTTP","text":"HTTP 基本概念HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。 HTTP的名字「超文本协议传输」，它可以拆成三个部分： 超文本 我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」。的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算做「文本」。 再来理解「超文本」，它就是超越了普通文本的文本，它是文字、图片、视频等的混合体最关键有超链接，能从一个超文本跳转到另外一个超文本。 HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，在经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。 OK，经过了对 HTTP 里这三个名词的详细解释，就可以给出比「超文本传输协议」这七个字更准确更有技术含量的答案： HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。 那「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议HTTP」 ，这种说法正确吗？ 这种说法是不正确的。因为也可以是「服务器&lt; – &gt;服务器」，所以采用两点之间的描述会更准确。 传输 HTTP 协议是一个双向协议。 我们在上网冲浪时，浏览器是请求方 A ，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。 协议 HTTP 常见的状态码 1xx1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。 2xx2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。 「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。 「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。 「206 Partial Content」是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。 3xx3xx 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。 「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。 「302 Moved Permanently」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。 301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。 「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。 4xx4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。 「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。 「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。 5xx5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。 「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。 「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。 「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。 「503 Service Unavailable」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。 常见字段Host 客户端发送请求时，用来指定服务器的域名。 1Host: www.A.com 有了 Host 字段，就可以将请求发往「同一台」服务器上的不同网站。 Content-Length 字段 服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。 1Content-Length: 1000 如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。 Connection 字段 Connection 字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。 HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为 Keep-Alive。 1Connection: keep-alive 一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。 Content-Type 字段 Content-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。 1Content-Type: text/html; charset=utf-8 上面的类型表明，发送的是网页，而且编码是UTF-8。 客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式。 1Accept: */* 上面代码中，客户端声明自己可以接受任何格式的数据。 Content-Encoding 字段 Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式 1Content-Encoding: gzip 上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。 客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法。 1Accept-Encoding: gzip, deflate","link":"/2020/05/16/%E5%A4%A7%E5%89%8D%E7%AB%AF/HTTP/"},{"title":"Node.js","text":"记录node学习 process文档 process 对象是一个全局变量，它提供有关当前 Node.js 进程的信息并对其进行控制。 作为一个全局变量，它始终可供 Node.js 应用程序使用，无需使用 require()。 它也可以使用 require() 显式地访问： 1const process = require('process'); process.envprocess.env 属性返回包含用户环境的对象。 此对象的示例如下所示： 123456789101112{ TERM: 'xterm-256color', SHELL: '/usr/local/bin/bash', USER: 'maciej', PATH: '~/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin', PWD: '/Users/maciej', EDITOR: 'vim', SHLVL: '1', HOME: '/Users/maciej', LOGNAME: 'maciej', _: '/usr/local/bin/node'} 可以修改此对象，但这些修改不会反映到 Node.js 进程之外，或者（除非明确请求）反映到其他 Worker 线程。 换句话说，以下示例不起作用： 1$ node -e 'process.env.foo = \"bar\"' &amp;&amp; echo $foo 以下示例则起作用： 12process.env.foo = 'bar';console.log(process.env.foo); 在 process.env 上分配属性将隐式地将值转换为字符串。 不推荐使用此行为。 当值不是字符串、数字或布尔值时，Node.js 的未来版本可能会抛出错误。 123456process.env.test = null;console.log(process.env.test);// =&gt; 'null'process.env.test = undefined;console.log(process.env.test);// =&gt; 'undefined' 使用 delete 可以从 process.env 中删除属性。 1234process.env.TEST = 1;delete process.env.TEST;console.log(process.env.TEST);// =&gt; undefined 在 Windows 操作系统上，环境变量不区分大小写。 123process.env.TEST = 1;console.log(process.env.test);// =&gt; 1 除非在创建 Worker 实例时明确指定，否则每个 Worker 线程都有自己的 process.env 副本，基于其父线程的 process.env，或者指定为 Worker 构造函数的 env 选项的任何内容。 对于 process.env 的更改将在 Worker 线程中不可见，并且只有主线程可以进行对操作系统或本机加载项可见的更改。","link":"/2020/05/16/%E5%A4%A7%E5%89%8D%E7%AB%AF/Node.js/"},{"title":"WebSocket 笔记","text":"为什么需要 WebSocket？初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？ 答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。 举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。 这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用“轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。 轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。 简介WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 其他特点包括： 建立在 TCP 协议之上，服务器端的实现比较容易。 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 数据格式比较轻量，性能开销小，通信高效。 可以发送文本，也可以发送二进制数据。 没有同源限制，客户端可以与任意服务器通信。 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 ws://example.com:80/some/path 简单示例https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket http://www.ruanyifeng.com/blog/2017/05/websocket.html WebSocket 的用法相当简单。 下面是一个网页脚本的例子（点击这里看运行结果），基本上一眼就能明白。 1234567891011121314151617var ws = new WebSocket(\"wss://echo.websocket.org\");ws.onopen = function(evt) { console.log(\"Connection open ...\"); //连接建立成功后发送消息 ws.send(\"Hello WebSockets!\");};ws.onmessage = function(evt) { //通过ext.data获得数据 console.log( \"Received Message: \" + evt.data); ws.close();};ws.onclose = function(evt) { console.log(\"Connection closed.\");}; 客户端APIWebSocket 构造函WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。 1var ws = new WebSocket('ws://localhost:8080'); 执行上面语句之后，客户端就会与服务器进行连接。 实例对象的所有属性和方法清单，参见这里。 webSocket.readyStatreadyState属性返回实例对象的当前状态，共有四种。 CONNECTING：值为0，表示正在连接。 OPEN：值为1，表示连接成功，可以通信了。 CLOSING：值为2，表示连接正在关闭。 CLOSED：值为3，表示连接已经关闭，或者打开连接失败。 下面是一个示例。 1234567891011121314151617switch (ws.readyState) { case WebSocket.CONNECTING: // do something break; case WebSocket.OPEN: // do something break; case WebSocket.CLOSING: // do something break; case WebSocket.CLOSED: // do something break; default: // this never happens break;} webSocket.onopen实例对象的onopen属性，用于指定连接成功后的回调函数。 123ws.onopen = function () { ws.send('Hello Server!');} 如果要指定多个回调函数，可以使用addEventListener方法。 123ws.addEventListener('open', function (event) { ws.send('Hello Server!');}); webSocket.onclose实例对象的onclose属性，用于指定连接关闭后的回调函数。 12345678910111213ws.onclose = function(event) { var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event};ws.addEventListener(\"close\", function(event) { var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event}); webSocket.onmessage实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。 123456789ws.onmessage = function(event) { var data = event.data; // 处理数据};ws.addEventListener(\"message\", function(event) { var data = event.data; // 处理数据}); 注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。 12345678910ws.onmessage = function(event){ if(typeof event.data === String) { console.log(\"Received data string\"); } if(event.data instanceof ArrayBuffer){ var buffer = event.data; console.log(\"Received arraybuffer\"); }} 除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。 1234567891011// 收到的是 blob 数据ws.binaryType = \"blob\";ws.onmessage = function(e) { console.log(e.data.size);};// 收到的是 ArrayBuffer 数据ws.binaryType = \"arraybuffer\";ws.onmessage = function(e) { console.log(e.data.byteLength);}; webSocket.send()实例对象的send()方法用于向服务器发送数据。 发送文本的例子。 1ws.send('your message'); 发送 Blob 对象的例子。 1234var file = document .querySelector('input[type=\"file\"]') .files[0];ws.send(file); 发送 ArrayBuffer 对象的例子。 1234567// Sending canvas ImageData as ArrayBuffervar img = canvas_context.getImageData(0, 0, 400, 320);var binary = new Uint8Array(img.data.length);for (var i = 0; i &lt; img.data.length; i++) { binary[i] = img.data[i];}ws.send(binary.buffer); webSocket.bufferedAmount实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。 12345678var data = new ArrayBuffer(10000000);socket.send(data);if (socket.bufferedAmount === 0) { // 发送完毕} else { // 发送还没结束} webSocket.onerror实例对象的onerror属性，用于指定报错时的回调函数。 1234567socket.onerror = function(event) { // handle error event};socket.addEventListener(\"error\", function(event) { // handle error event}); 一般使用Socket.IOhttps://socket.io/get-started/chat/ https://eggjs.org/zh-cn/tutorials/socketio.html","link":"/2020/05/16/%E5%A4%A7%E5%89%8D%E7%AB%AF/WebSocket/"},{"title":"JavaScript之混淆的类","text":"序言学习JavaScript时，如果你已经对C++、Java等传统面向对象编程语言有一定了解，或者老师教导过你使用类(类是面向对象编程的实现核心)把过程化风格的代码转换成结构清晰的代码，那么你很自然地会想在js中使用类。如在万物皆为类的Java中，严格区分类和对象，对象由类实例化而成，继承实际上是类的扩展。但JavaScript中只有对象，没有类，这是本质上的区别，可在JavaScript中有许多模拟类的语法糖在试图掩盖这个事实，很多教程中并未对此作详细解释，而是直接教初学者使用这些语法糖，导致初学者会在无形中出现困惑。 虽然JavaScript中没有类，但俗话说“没有的才是最好的”，开发者们通过不断探索总结，成功地模拟出了“类”。由于大家定义类的方法五花八门，风格不一。对于模拟面向对象的封装、继承、多态，更有许多研究，实现办法更加晦涩，不利于JavaScript新手使用。 这就引出了本文的话题：JavaScript中类的机制。 类的封装、继承与多态说到面向对象编程，不得不先了解类。 根据维基百科的定义，类(class)在面向对象编程中是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。有封装性、继承性、多态性三个最重要的特性。 类与继承抽象了一种代码的组织形式，一种编程领域对真实世界中问题的建模。比如，轮船可以被看做交通工具的一个特例，后者是更广泛的类，可以用Vehicle和Steamer两个类进行建模。Vehicle可以定义引擎、载人能力等几乎所有交通工具都具有的属性，而在具体的交通工具类中，定义同样的属性是没有意义的，所以在定义Steamer类时，只需声明它继承了Vehicle这个基类，那么它就能拥有基类的属性及方法。 有了Steamer类，就有了轮船的所有属性和行为，这便是类的封装。我们迫不及待地想上船航行，可类好比蓝图，正如轮船的图纸，并非真正可以交互的轮船，只有根据图纸建造出物理实物，才能上船。真的轮船便是蓝图的物理实例，本质上是对蓝图的复制，即实例化。 类的另一个核心概念是多态，指父类(基类)的通用行为可以被子类用特殊行为重写。如Vehicle类中为所有交通工具定义了一个decelerate()减速方法，默认操作是踩刹车，但在轮船的减速中，可能还需要抛锚，所以在Steamer类中，可以重写decelerate()方法，在引用Vehicle类中decelerate()方法的基础上再加一步抛锚操作。即任何方法都可引用继承层次中高层的方法(方法名可以不同)。 有以下伪代码： 123456789101112131415161718192021class Vehicle{ engines=1 startEngine(){ console.log('start engine 1') } drive(){ startEngine() console.log('driving') }}class Steamer extends Vehicle{ engines=2//轮船有两个引擎 startEngine(){ super.startEngine()//实现相对多态，调用父类的同名方法 console.log('start engine 2')//增加自身需要的代码 } drive(){//重写了父类的方法 startEngine() console.log('sailing') }} 上面的代码中Steamer下的drive方法会调用自身相对多态的startEngine方法，即多态性取决于引用的实例所来自的类。 可以看出，类是一种设计模式，只是Java等许多语言提供了面向类的原生语法，所以一般不为我们所感知，JavaScript也有类似的语法，但和其他语言中的类完全不同，这便是本文想解释清楚的地方。 类代表着复制，在Java等语言中，类被实例化时，它的行为会被复制到实例中，被继承时行为也会被复制到子类中，多态也是如此。但JavaScript的对象系统基于原型，而不是类，不会自动生成对象的副本。 原型继承要想在JavaScript中优雅地使用“类”，首先需要了解JavaScript的“类”本质上是基于原型的继承。 原型(Prototype)是JS对象的一个特殊内置属性，是对于其他对象的引用。创建一个方法时，会根据一组特定规则为该方法添加一个``prototype属性，这个属性指向方法的原型对象。在默认情况下，原型对象会自动生成一个constructor属性，这个属性包含一个指向prototype`属性所在函数对象的指针，如图所示。 需访问一个对象的属性时，先在对象的本身上查找，如果找不到引擎就会继续在``prototype所关联的对象上继续查找，直到找到为止，prototype最终都指向Object.prototype`。这一系列查找对象的链接即是原型链。如下图。 继承属性12345678910111213141516171819202122232425262728let f = function () { this.a = 1 this.b = 2}let g = new f(); // {a: 1, b: 2}// 在f函数的原型上定义属性f.prototype.b = 3;f.prototype.c = 4;// 可得原型链如下: // {a:1, b:2} ---&gt; {b:3, c:4} ---&gt; Object.prototype---&gt; nullconsole.log(g.a) // 1// a是g自身的属性，值为 1console.log(g.b) // 2// b是g自身的属性，值为 2// 原型上也有一个'b'属性，但是它不会被访问到。console.log(g.c) // 4// c不是g的自身属性，那看看它的原型上有没有// c是g.[[Prototype]]属性该属性的值为 4console.log(g.d) // undefined// d 不是 g 的自身，那看看它的原型上有没有// d 不是 g.[[Prototype]] 的属性，那看看它的原型上有没有// g.[[Prototype]].[[Prototype]] 为 null，停止搜索// 无 d 属性，故为 undefined 上例中console.log(g.b)时输出2而不是3，即’b’属性既出现在g中也出现在了g的原型链上层，那么会触发屏蔽，即g中的’b’属性会屏蔽原型链上层的所有’b’属性。这种情况相当于其他语言的方法重写。 继承方法12345678910111213141516let o = { a: 2, m: function(){ return this.a + 1; }}console.log(o.m()) // 3// 当调用 o.m 时，'this' 指向了 o.let p = Object.create(o)// p是一个继承自 o 的对象p.a = 4 // 创建 p 的自身属性 'a'console.log(p.m()) // 5// 调用 p.m 时，'this' 指向了 p// 又因为 p 继承了 o 的 m 函数// 所以，此时的 'this.a' 即 p.a，就是 p 的自身属性 'a' JavaScript没有那些基于类的语言定义的“方法”。JavaScript中，任何函数(方法)都可以添加到对象上作为对象的属性。函数的继承与其他的属性继承没有差别，包括上面的“屏蔽”。继承的函数被调用时，this指向当前继承的对象，而不是继承的函数所在的原型对象。 Object.create(obj)返回一个与obj的prototype关联的对象，实现了p对于o的“继承”，虽然p对象并无a属性，但访问时若原对象无此属性，便会顺着其prototype链一直查找，直到prototype的尽头——Object.prototype，因此顺着prototype链访问到了o的a属性，是不是有点继承的感觉了？ 模拟“类”所以，在JavaScript中使用类，ES6之前大多为用函数模拟。回到上面Vehicle与Steamer的伪代码，用js代码实现： 12345678910111213141516171819202122function Vehicle(props) { this.id = props.id||'not bind' this.engines=props.engines||'not bind'}Vehicle.prototype.startEngine = function () { console.log('start engine ')}function Steamer(props) { // 调用Vehicle构造函数，绑定this Vehicle.call(this, props) this.cabin = props.cabin || 1}let titanic = new Steamer({ cabin: 10, id: '12412321', engines: 10 })console.log(titanic);console.log(Object.getPrototypeOf(titanic));console.log(Object.getPrototypeOf(Object.getPrototypeOf(titanic)));console.log(Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(titanic))));//Steamer { id: '12412321', engines: 10, cabin: 10 }//Steamer {}//{}//null 但调用了Vehicle()作为“构造函数”不代表继承了Vehicle，Steamer创建的对象原型是``new Steamer()–&gt; Steamer.prototype–&gt; Object.prototype–&gt; null，继承关系的原型链应为new Steamer() –&gt; Steamer.prototype–&gt; Vehicle.prototype–&gt; Object.prototype–&gt; null，这样新的Steamer对象不仅能调用Steamer.prototype绑定的方法，也可以使用Vehicle.prototype绑定的方法。但要想达到这个状态，直接Steamer.prototype = Vehicle.prototype`是不行的，这样两者指向同一个对象，继承关系就不存在了。此时需要借助一个中间对象，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041function Vehicle(props) { this.id = props.id||'not bind' this.engines=props.engines||'not bind'}Vehicle.prototype.startEngine = function () { console.log('start engine ')}function Steamer(props) { // 调用Vehicle构造函数，绑定this Vehicle.call(this, props) this.cabin = props.cabin || 1}function Tmp() {}Tmp.prototype = Vehicle.prototype//把Steamer的原型指向一个新Tmp对象，Tmp对象的原型正好指向Vehicle.prototypeSteamer.prototype = new Tmp()// 把Steamer原型的“构造函数”变回SteamerSteamer.prototype.constructor = SteamerSteamer.prototype.getCabin = function () { return this.cabin}let titanic=new Steamer({ cabin:9999, engines:4, id:'21435452378454'})console.log(titanic.cabin)//9999console.log(titanic.engines)//4//继承关系验证titanic instanceof Steamer//truetitanic instanceof Vehicle//true//查看原型链console.log(Object.getPrototypeOf(titanic));//Steamer { constructor: [Function: Steamer], getCabin: [Function] }console.log(Object.getPrototypeOf(Object.getPrototypeOf(titanic)));//Vehicle { startEngine: [Function] } 由于Tmp()仅用于两者继承的连接，所以可以用一个函数把这个行为封装起来： 12345function(f){ function Tmp(){} Tmp.prototype=f return new Tmp()} 这即是Object.create()的简单实现。Object.create()创建一个新对象，使用现有的对象来提供新创建的对象的prototype。 Steamer.prototype.constructor = Steamer的作用是补上constructor属性(默认对象的prototype都有这个属性，可以理解为“构造函数”，一般指向函数自身，即new Son()时调用Son()来“构造”一个新对象，这个新对象的prototype与Son.prototype相关联)，如果将这里也封装进函数： 12345function extend(son, father) { var prototype = Object.create(father.prototype);// 创建对象，注意！这里和Tmp()方式相同 prototype.constructor = son; son.prototype = prototype;} 抽离出来的extend方法被称作寄生组合式继承，是目前最成熟的方法，仅使用Object.create()而不补上constructor被称作原型式继承，缺点是原型链继承多个实例的引用类型属性指向相同，可能被篡改，以及无法传递参数。还有混入、寄生式等几种方式实现继承，各有各的优缺点，就不一一赘述了。 下面你会读到extends关键字，什么？和上面的extend很像？没错，extends关键字的核心实现就是寄生组合式继承，不然怎么叫语法糖。 class 关键字ECMAScript 6规范中，引入了class的概念。使得 JS 开发者终于告别了直接使用原型对象模仿面向对象中的类和类继承的时代。但是 class 仅仅只是对原型对象运用语法糖，如果认为它像其它面向类语言中的class那样，使用时只会增加新手的困惑。 1234class P { // ...}typeof P // function 可以看出，一个class实际上就是function。 12345678910111213141516171819202122232425262728class Vehicle { constructor(props) { this.engines = props.engines; this.id = props.id; } startEngine() { console.log(\"start \",this.engines,' engines'); }}class Steamer extends Vehicle { constructor(props) { super(props); this.cabin = props.cabin; } getCabin() { this.startEngine(); console.log(\"I have\", this.cabin, \" cabins\"); }}let titanic = new Steamer({ cabin: 9999, engines: 4, id: \"21435452378454\"});titanic.getCabin(); //start 4 engines//I have 9999 cabins 当titanic调用 getCabin方法时，titanic自身没有需要的 startEngine方法，所以会到 titanic.prototype 原型对象上查找，最后调用``Vehicle.prototype原型对象上的startEngine方法。调用时，this` 指向的是titanic对象。 实际上，ECMAScript 6中的class仍然遵循你了解的JavaScript模式，继承的原理还和以前一样基于原型链，方法添加在原型上，只是用了更简单的关键字来代替，却隐藏了许多问题，要说优点可能只有一个:可以打更少的字。 总结传统基于类的面向对象思维在一定程度上妨碍了大家对JavaScript面向对象特性的理解，虽然这些机制和Java等传统面向类语言中的“类初始化”“继承”很像，但JavaScript有一个本质区别就是不会进行复制，对象之间通过内部的prototype链进行关联。所以说，在一定程度上JavaScript模拟类是得不偿失的，可解决当前问题，更可埋下隐患。实际上，对象之间的关系用委托形容更加贴切。 参考文献 类 (计算机科学)——维基百科 《你不知道的JavaScript》——KYLE SIMPSON 《JavaScript继承机制研究》—— 周 岚 《JavaScript需要类吗?》——紫云飞 《继承与原型链》——MDN web docs 《原型继承》——廖雪峰的官方网站 《JavaScript常用八种继承方案》——木易杨说","link":"/2020/05/16/%E5%8D%9A%E5%AE%A2/JavaScript%20%E4%B9%8B%E6%B7%B7%E6%B7%86%E7%9A%84%E2%80%9C%E7%B1%BB%E2%80%9D/"},{"title":"跨域相关","text":"整理跨域的各种方法 解决方法JSONP在HTML标签里，一些标签比如script、img这样的获取资源的标签是没有跨域限制的，利用这一点，我们可以这样干： 后端写个小接口 12345678910111213// 处理成功失败返回格式的工具const {successBody} = require('../utli')class CrossDomain { static async jsonp (ctx) { // 前端传过来的参数 const query = ctx.request.query // 设置一个cookies ctx.cookies.set('tokenId', '1') // query.cb是前后端约定的方法名字，其实就是后端返回一个直接执行的方法给前端，由于前端是用script标签发起的请求，所以返回了这个方法后相当于立马执行，并且把要返回的数据放在方法的参数里。 ctx.body = `${query.cb}(${JSON.stringify(successBody({msg: query.msg}, 'success'))})` }}module.exports = CrossDomain 简单版前端 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;script type='text/javascript'&gt; // 后端返回直接执行的方法，相当于执行这个方法，由于后端把返回的数据放在方法的参数里，所以这里能拿到res。 window.jsonpCb = function (res) { console.log(res) } &lt;/script&gt; &lt;script src='http://localhost:9871/api/jsonp?msg=helloJsonp&amp;cb=jsonpCb' type='text/javascript'&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 简单封装一下前端这个套路 1234567891011121314151617181920212223242526272829303132333435363738394041/** * JSONP请求工具 * @param url 请求的地址 * @param data 请求的参数 * @returns {Promise&lt;any&gt;} */const request = ({url, data}) =&gt; { return new Promise((resolve, reject) =&gt; { // 处理传参成xx=yy&amp;aa=bb的形式 const handleData = (data) =&gt; { const keys = Object.keys(data) const keysLen = keys.length return keys.reduce((pre, cur, index) =&gt; { const value = data[cur] const flag = index !== keysLen - 1 ? '&amp;' : '' return `${pre}${cur}=${value}${flag}` }, '') } // 动态创建script标签 const script = document.createElement('script') // 接口返回的数据获取 window.jsonpCb = (res) =&gt; { document.body.removeChild(script) delete window.jsonpCb resolve(res) } script.src = `${url}?${handleData(data)}&amp;cb=jsonpCb` document.body.appendChild(script) })}// 使用方式request({ url: 'http://localhost:9871/api/jsonp', data: { // 传参 msg: 'helloJsonp' }}).then(res =&gt; { console.log(res)})2.空iframe加for 空iframe加formJSONP只能发GET请求，因为本质上script加载资源就是GET，那么如果要发POST请求怎么办呢？ 后端写个小接口 12345678910// 处理成功失败返回格式的工具const {successBody} = require('../utli')class CrossDomain { static async iframePost (ctx) { let postData = ctx.request.body console.log(postData) ctx.body = successBody({postData: postData}, 'success') }}module.exports = CrossDomain 前端 1234567891011121314151617181920212223242526const requestPost = ({url, data}) =&gt; { // 首先创建一个用来发送数据的iframe. const iframe = document.createElement('iframe') iframe.name = 'iframePost' iframe.style.display = 'none' document.body.appendChild(iframe) const form = document.createElement('form') const node = document.createElement('input') // 注册iframe的load事件处理程序,如果你需要在响应返回时执行一些操作的话. iframe.addEventListener('load', function () { console.log('post success') }) form.action = url // 在指定的iframe中执行form form.target = iframe.name form.method = 'post' for (let name in data) { node.name = name node.value = data[name].toString() form.appendChild(node.cloneNode()) } // 表单元素需要添加到主文档中. form.style.display = 'none' document.body.appendChild(form) form.submit() CORS (推荐)CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）跨域资源共享 CORS 详解。看名字就知道这是处理跨域问题的标准做法。CORS有两种请求，简单请求和非简单请求。 这里引用上面链接阮一峰老师的文章说明一下简单请求和非简单请求。浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 只要同时满足以下两大条件，就属于简单请求。（1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 1.简单请求后端 123456789101112// 处理成功失败返回格式的工具const {successBody} = require('../utli')class CrossDomain { static async cors (ctx) { const query = ctx.request.query // *时cookie不会在http请求中带上 ctx.set('Access-Control-Allow-Origin', '*') ctx.cookies.set('tokenId', '2') ctx.body = successBody({msg: query.msg}, 'success') }}module.exports = CrossDomain 前端什么也不用干，就是正常发请求就可以，如果需要带cookie的话，前后端都要设置一下，下面那个非简单请求例子会看到。 123fetch(`http://localhost:9871/api/cors?msg=helloCors`).then(res =&gt; { console.log(res)}) 2.非简单请求非简单请求会发出一次预检测请求，返回码是204，预检测通过才会真正发出请求，这才返回200。这里通过前端发请求的时候增加一个额外的headers来触发非简单请求。 后端 123456789101112131415161718// 处理成功失败返回格式的工具const {successBody} = require('../utli')class CrossDomain { static async cors (ctx) { const query = ctx.request.query // 如果需要http请求中带上cookie，需要前后端都设置credentials，且后端设置指定的origin ctx.set('Access-Control-Allow-Origin', 'http://localhost:9099') ctx.set('Access-Control-Allow-Credentials', true) // 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为\"预检\"请求（preflight） // 这种情况下除了设置origin，还需要设置Access-Control-Request-Method以及Access-Control-Request-Headers ctx.set('Access-Control-Request-Method', 'PUT,POST,GET,DELETE,OPTIONS') ctx.set('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, t') ctx.cookies.set('tokenId', '2') ctx.body = successBody({msg: query.msg}, 'success') }}module.exports = CrossDomain 一个接口就要写这么多代码，如果想所有接口都统一处理，有什么更优雅的方式呢？见下面的koa2-cors。 123456789101112131415161718192021222324252627const path = require('path')const Koa = require('koa')const koaStatic = require('koa-static')const bodyParser = require('koa-bodyparser')const router = require('./router')const cors = require('koa2-cors')const app = new Koa()const port = 9871app.use(bodyParser())// 处理静态资源 这里是前端build好之后的目录app.use(koaStatic( path.resolve(__dirname, '../dist')))// 处理corsapp.use(cors({ origin: function (ctx) { return 'http://localhost:9099' }, credentials: true, allowMethods: ['GET', 'POST', 'DELETE'], allowHeaders: ['t', 'Content-Type']}))// 路由app.use(router.routes()).use(router.allowedMethods())// 监听端口app.listen(9871)console.log(`[demo] start-quick is starting at port ${port}`) 前端 12345678910fetch(`http://localhost:9871/api/cors?msg=helloCors`, { // 需要带上cookie credentials: 'include', // 这里添加额外的headers来触发非简单请求 headers: { 't': 'extra headers' }}).then(res =&gt; { console.log(res)}) 代理 (Nginx)想一下，如果我们请求的时候还是用前端的域名，然后有个东西帮我们把这个请求转发到真正的后端域名上，不就避免跨域了吗？这时候，Nginx出场了。Nginx配置 12345678910server{ # 监听9099端口 listen 9099; # 域名是localhost server_name localhost; #凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871 location ^~ /api { proxy_pass http://localhost:9871; } } 前端就不用干什么事情了，除了写接口，也没后端什么事情了 1234567891011// 请求的时候直接用回前端这边的域名http://localhost:9099，这就不会跨域，然后Nginx监听到凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871 fetch('http://localhost:9099/api/iframePost', { method: 'POST', headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' }, body: JSON.stringify({ msg: 'helloIframePost' })}) Nginx转发的方式似乎很方便！但这种使用也是看场景的，如果后端接口是一个公共的API，比如一些公共服务获取天气什么的，前端调用的时候总不能让运维去配置一下Nginx，如果兼容性没问题（IE 10或者以上），CROS才是更通用的做法吧。 同源策略限制下Dom查询的正确打开方式1.postMessagewindow.postMessage() 是HTML5的一个接口，专注实现不同窗口不同页面的跨域通讯。为了演示方便，我们将hosts改一下：127.0.0.1 crossDomain.com，现在访问域名crossDomain.com就等于访问127.0.0.1。 这里是http://localhost:9099/#/crossDomain，发消息方 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;postMessage&quot;&gt;给http://crossDomain.com:9099发消息&lt;/button&gt; &lt;iframe name=&quot;crossDomainIframe&quot; src=&quot;http://crossdomain.com:9099&quot;&gt;&lt;/iframe&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { mounted () { window.addEventListener('message', (e) =&gt; { // 这里一定要对来源做校验 if (e.origin === 'http://crossdomain.com:9099') { // 来自http://crossdomain.com:9099的结果回复 console.log(e.data) } }) }, methods: { // 向http://crossdomain.com:9099发消息 postMessage () { const iframe = window.frames['crossDomainIframe'] iframe.postMessage('我是[http://localhost:9099], 麻烦你查一下你那边有没有id为app的Dom', 'http://crossdomain.com:9099') } }}&lt;/script&gt; 这里是http://crossdomain.com:9099，接收消息方 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; 我是http://crossdomain.com:9099 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { mounted () { window.addEventListener('message', (e) =&gt; { // 这里一定要对来源做校验 if (e.origin === 'http://localhost:9099') { // http://localhost:9099发来的信息 console.log(e.data) // e.source可以是回信的对象，其实就是http://localhost:9099窗口对象(window)的引用 // e.origin可以作为targetOrigin e.source.postMessage(`我是[http://crossdomain.com:9099]，我知道了兄弟，这就是你想知道的结果：${document.getElementById('app') ? '有id为app的Dom' : '没有id为app的Dom'}`, e.origin); } }) }}&lt;/script&gt; 结果可以看到： 2.document.domain这种方式只适合主域名相同，但子域名不同的iframe跨域。比如主域名是http://crossdomain.com:9099，子域名是http://child.crossdomain.com:9099，这种情况下给两个页面指定一下document.domain即document.domain = crossdomain.com就可以访问各自的window对象了。 3.canvas操作图片的跨域问题这个应该是一个比较冷门的跨域问题，张大神已经写过了我就不再班门弄斧了解决canvas图片getImageData,toDataURL跨域问题","link":"/2020/05/16/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E8%B7%A8%E5%9F%9F/"},{"title":"PM2","text":"简介对于线上项目，如果直接通过 node app 来启动，如果报错了可能直接停止导致整个服务崩溃，一般监控 node 有几种方案。 supervisor: 一般用作开发环境的使用。 forever: 管理多个站点，一般每个站点的访问量不大的情况，不需要监控。 PM2: 一个进程管理工具，维护一个进程列表，可以用它来管理你的node进程，负责所有正在运行的进程，并查看node进程的状态，也支持性能监控，负载均衡等功能。 PM2 的主要特性 内建负载均衡（使用 Node cluster 集群模块） 后台运行 0 秒停机重载，我理解大概意思是维护升级的时候不需要停机. 具有 Ubuntu 和 CentOS 的启动脚本 停止不稳定的进程（避免无限循环） 控制台检测 提供 HTTP API 远程控制和实时的接口 API ( Nodejs 模块,允许和 PM2 进程管理器交互 ) 安装12// 全局安装pm2，依赖node和npmnpm install -g pm2 常用命令PM2 start启动一个node程序12345pm2 start start.js//Or start any other application easily:$ pm2 start bashscript.sh$ pm2 start python-app.py --watch$ pm2 start binary-file -- --port 1520 启动进程并指定应用的程序名1pm2 start app.js --name application1 集群模式启动123// -i 表示 number-instances 实例数量// max 表示 PM2将自动检测可用CPU的数量 可以自己指定数量pm2 start start.js -i max 添加程监视123// 在文件改变的时候会重新启动程序pm2 start app.js --name start --watch复制代码 其他Options1234567891011121314151617181920212223242526272829# Specify an app name--name &lt;app_name&gt;# Watch and Restart app when files change--watch# Set memory threshold for app reload--max-memory-restart &lt;200MB&gt;# Specify log file--log &lt;log_path&gt;# Pass extra arguments to the script-- arg1 arg2 arg3# Delay between automatic restarts--restart-delay &lt;delay in ms&gt;# Prefix logs with time--time# Do not auto restart app--no-autorestart# Specify cron for forced restart--cron &lt;cron_pattern&gt;# Attach to application log--no-daemon 列出所有进程1$ pm2 [list|ls|status] 重启、删除、停止、重新加载进程1234$ pm2 restart app_name$ pm2 reload app_name$ pm2 stop app_name$ pm2 delete app_name 除了使用app_name,还可以： all to act on all processes id to act on a specific process id 查看状态、日志、指标日志To display logs in realtime: 1$ pm2 logs To dig in older logs: 1$ pm2 logs --lines 200 自适应监控面板1$ pm2 monit 还有个Web版 1$ pm2 plus 查看某个进程具体情况1pm2 describe app 设置pm2开机自启开启启动设置，此处是CentOS系统，其他系统替换最后一个选项（可选项：ubuntu, centos, redhat, gentoo, systemd, darwin, amazon） 1pm2 startup centos 然后按照提示需要输入的命令进行输入 最后保存设置 1pm2 save 官方推荐命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Fork modepm2 start app.js --name my-api # Name process# Cluster modepm2 start app.js -i 0 # Will start maximum processes with LB depending on available CPUspm2 start app.js -i max # Same as above, but deprecated.pm2 scale app +3 # Scales `app` up by 3 workerspm2 scale app 2 # Scales `app` up or down to 2 workers total# Listingpm2 list # Display all processes statuspm2 jlist # Print process list in raw JSONpm2 prettylist # Print process list in beautified JSONpm2 describe 0 # Display all informations about a specific processpm2 monit # Monitor all processes# Logspm2 logs [--raw] # Display all processes logs in streamingpm2 flush # Empty all log filespm2 reloadLogs # Reload all logs# Actionspm2 stop all # Stop all processespm2 restart all # Restart all processespm2 reload all # Will 0s downtime reload (for NETWORKED apps)pm2 stop 0 # Stop specific process idpm2 restart 0 # Restart specific process idpm2 delete 0 # Will remove process from pm2 listpm2 delete all # Will remove all processes from pm2 list# Miscpm2 reset &lt;process&gt; # Reset meta data (restarted time...)pm2 updatePM2 # Update in memory pm2pm2 ping # Ensure pm2 daemon has been launchedpm2 sendSignal SIGUSR2 my-app # Send system signal to scriptpm2 start app.js --no-daemonpm2 start app.js --no-vizionpm2 start app.js --no-autorestart 管理多个应用您还可以创建一个名为生态系统文件的配置文件来管理多个应用程序。生成生态系统文件: 1$ pm2 ecosystem 生成ecosystem.config.js文件： 123456789101112131415module.exports = { apps : [{ name: \"app\", script: \"./app.js\", env: { NODE_ENV: \"development\", }, env_production: { NODE_ENV: \"production\", } }, { name: 'worker', script: 'worker.js' }]} And start it easily: 1$ pm2 start process.yml Read more about application declaration here. 通过pm2配置文件来自动部署项目官网指南 首先是配置服务器与Github的ssh: 在服务器中生成rsa公钥和私钥，当前是 centos7 下进行 前提服务器要安装git，没有安装的先安装git，已安装的跳过 1yum –y install git 生成秘钥 1ssh-keygen -t rsa -C \"xxx@xxx.com\" 在~/.ssh目录下有 id_rsa和 id_rsa.pub两个文件，其中id_rsa.pub文件里存放的即是公钥key。 登录到GitHub，点击右上方的头像，选择settings ，点击Add SSH key，把id_rsa.pub的内容复制到里面即可。 本地项目PM2配置文件1pm2 ecosystem 在项目跟目录下运行，会自动生成模板文件: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869{ // Applications part \"apps\" : [{ \"name\" : \"API\", \"script\" : \"app.js\", \"env\": { \"COMMON_VARIABLE\": \"true\" }, // Environment variables injected when starting with --env production // http://pm2.keymetrics.io/docs/usage/application-declaration/#switching-to-different-environments \"env_production\" : { \"NODE_ENV\": \"production\" } },{ \"name\" : \"WEB\", \"script\" : \"web.js\" }], // Deployment part // Here you describe each environment \"deploy\" : { \"production\" : { // 服务器的用户名 \"user\" : \"node\", // Multi host is possible, just by passing IPs/hostname as an array \"host\" : [\"212.83.163.1\", \"212.83.163.2\", \"212.83.163.3\"], // 要拉取的git分支 \"ref\" : \"origin/master\", // Git repository to clone \"repo\" : \"git@github.com:repo.git\", // 拉取到服务器某个目录下 \"path\" : \"/var/www/production\", // Can be used to give options in the format used in the configura- // tion file. This is useful for specifying options for which there // is no separate command-line flag, see 'man ssh' // can be either a single string or an array of strings \"ssh_options\": \"StrictHostKeyChecking=no\", // To prepare the host by installing required software (eg: git) // even before the setup process starts // can be multiple commands separated by the character \";\" // or path to a script on your local machine \"pre-setup\" : \"apt-get install git\", // Commands / path to a script on the host machine // This will be executed on the host after cloning the repository // eg: placing configurations in the shared dir etc \"post-setup\": \"ls -la\", // Commands to execute locally (on the same machine you deploy things) // Can be multiple commands separated by the character \";\" \"pre-deploy-local\" : \"echo 'This is a local executed command'\" // Commands to be executed on the server after the repo has been cloned \"post-deploy\" : \"npm install &amp;&amp; pm2 startOrRestart ecosystem.json --env production\" // Environment variables that must be injected in all applications on this env \"env\" : { \"NODE_ENV\": \"production\" } }, \"staging\" : { \"user\" : \"node\", \"host\" : \"212.83.163.1\", \"ref\" : \"origin/master\", \"repo\" : \"git@github.com:repo.git\", \"path\" : \"/var/www/development\", \"ssh_options\": [\"StrictHostKeyChecking=no\", \"PasswordAuthentication=no\"], \"post-deploy\" : \"pm2 startOrRestart ecosystem.json --env dev\", \"env\" : { \"NODE_ENV\": \"staging\" } } }} 关于 post-deploy you may have noticed the command pm2 startOrRestart ecosystem.json --env production. The --env allows to inject different sets of environment variables. Read more here. 按照自己要求修改好后，就可以部署啦： 1pm2 deploy &lt;configuration_file&gt; &lt;environment&gt; setup 如:(windows 记得使用 git bash 等unix命令行) 1pm2 deploy ecosystem.json production setup # 这个命令将会在远程服务器上创建文件 pm2 deploy pm2 deploy help: 1234567891011pm2 deploy &lt;configuration_file&gt; &lt;environment&gt; &lt;command&gt; Commands: setup run remote setup commands update update deploy to the latest release revert [n] revert to [n]th last deployment or 1 curr[ent] output current release commit prev[ious] output previous release commit exec|run &lt;cmd&gt; execute the given &lt;cmd&gt; list list previous deploy commits [ref] deploy to [ref], the \"ref\" setting, or latest tag","link":"/2020/05/16/%E8%BF%90%E7%BB%B4/PM2/"},{"title":"linux 常用软件","text":"一些shell程序命令整理 git 命令用户名设置安装完成后，还需要最后一步设置，在命令行输入：$ git config –global user.name “Your Name”$ git config –global user.email “email@example.com“ 要随时掌握工作区的状态，使用git status命令。如果git status告诉你有文件被修改过，用git diff可以查看修改。 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭 git log 查看历史穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 12345678# 每个提交在一行内显示git log --oneline# 在所有提交日志中搜索包含「homepage」的提交git log --all --grep='homepage'# 获取某人的提交日志git log --author=\"Maxence\" git reflog/reset要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 1234567# 获取所有操作历史git reflog# 重置到相应提交git reset HEAD@{4}# ……或者……git reset --hard &lt;提交的哈希值&gt; 工作区（Working Directory）就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区： 版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 提交后，用git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别：每次修改，如果不用git add到暂存区，那就不会加入到commit中。 要关联一个远程库，使用命令 git remote add origin git@server-name:path/repo-name.git 删除远程库 git remote rm origin 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； git remote 你的项目关联的远程存储库列表 要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。git clone git@github.com:michaelliao/gitskills.git 首先，我们创建dev分支，然后切换到dev分支： git checkout -b dev //Switched to a new branch 'dev' git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： git branch dev git checkout dev 然后，查看当前分支： git branch 会列出所有分支，当前分支前面会标一个*号。 然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行： Creating a new branch is quick. 然后提交： 12$ git add readme.txt $ git commit -m \"branch test\" 现在，dev分支的工作完成，我们就可以切换回master分支： 12git checkout master//Switched to branch 'master' 切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！ 因为那个提交是在dev分支上，而master分支此刻的提交点并没有变. 现在，我们把dev分支的工作成果合并到master分支上： git merge dev git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。 合并完成后，就可以放心地删除dev分支了： git branch -d dev 删除后，查看branch，就只剩下master分支了： git branch 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。 .gitignore123456# 此为注释 – 将被 Git 忽略*.a ``# 忽略所有 .a 结尾的文件!lib.a ``# 但 lib.a 除外/TODO` `# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ ``# 忽略 build/ 目录下的所有文件doc/*.txt ``# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt • 所有空行或者以 # 开头的行都会被 Git 忽略。 • 可以使用标准的 glob 模式匹配。 • 匹配模式可以以(/)开头防止递归。 • 匹配模式可以以(/)结尾指定目录。 • 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号(!)取反。 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号(*)匹配零个或多个任意字符;[abc] 匹配 任何一个列在方括号中的字符(这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c);问号(?)只匹配一个任意字符;如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配 (比如 [0-9] 表示匹配所有 0 到 9 的数字)。 使用两个星号() 表示匹配任意中间目录，比如 a/*/z 可以匹 配 a/z , a/b/z 或 a/b/c/z 等。 !!!使更改后的gitignore生效： 12git rm -r --cached . #清除缓存git add . #重新trace file 提交规范一般个人开发时可随意遵守，但对于团队感觉还是适用的。 使用插件可访问 基本commit样式 12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt; 1.typetype为必填项，用于指定commit的类型，约定了feat、fix两个主要type，以及docs、style、build、refactor、revert五个特殊type，其余type暂不使用。 1234567891011121314151617# 主要typefeat: 增加新功能fix: 修复bug# 特殊typedocs: 只改动了文档相关的内容style: 不影响代码含义的改动，例如去掉空格、改变缩进、增删分号build: 构造工具的或者外部依赖的改动，例如webpack，npmrefactor: 代码重构时使用revert: 执行git revert打印的message# 暂不使用typetest: 添加测试或者修改现有测试perf: 提高性能的改动ci: 与CI（持续集成服务）有关的改动chore: 不修改src或者test的其余修改，例如构建过程或辅助工具的变动复制代码 当一次改动包括主要type与特殊type时，统一采用主要type。 2.scopescope也为必填项，用于描述改动的范围，格式为项目名/模块名，例如： node-pc/common rrd-h5/activity，而we-sdk不需指定模块名。如果一次commit修改多个模块，建议拆分成多次commit，以便更好追踪和维护。 3.bodybody填写详细描述，主要描述改动之前的情况及修改动机，对于小的修改不作要求，但是重大需求、更新等必须添加body来作说明。 4.break changesbreak changes指明是否产生了破坏性修改，涉及break changes的改动必须指明该项，类似版本升级、接口参数减少、接口删除、迁移等。 5.affect issuesaffect issues指明是否影响了某个问题。例如我们使用jira时，我们在commit message中可以填写其影响的JIRA_ID，若要开启该功能需要先打通jira与gitlab。参考文档：docs.gitlab.com/ee/user/pro… 填写方式例如： 12re #JIRA_IDfix #JIRA_ID 示例 完整的commit message示例 相应的git log Mysql重要！进行用户相关操作后记得刷新权限！！！FLUSH PRIVILEGES; 列出所有数据库 show databases; 删除数据库 drop database name; 新建数据库 create database name; 查看用户基本资料 SELECT DISTINCT CONCAT('User: ''',user,'''@''',host,''';') AS query FROM mysql.user; 新建用户 create user movie_user@% identified by'123456'; @后面的参数是指该用户可以登陆的ip地址，”%”是可以在任意ip登陆。 用户名@IP地址 用户只能该IP下才能访问用户名@192.168.1.% 用户只能在改IP段下才能访问(通配符%表示任意)用户名@% 用户可以再任意IP下访问(默认IP地址为%) 删除用户 drop user '用户名'@'IP地址'; 修改用户及密码 rename user '用户名'@'IP地址' to '新用户名'@'IP地址'; set password for '用户名'@'IP地址' = Password('新密码'); 查看权限 show grants for '用户'@'IP地址'; 赋予权限 GRANT ALL PRIVILEGES ON mall.* TO 'test'@'%' 12345678910111213141516171819202122232425262728293031323334353637grant 权限 on 数据库.表 to '用户'@'IP地址'; //all privileges 除grant外的所有权限select 仅查权限select,insert 查和插入权限...usage 无访问权限alter 使用alter tablealter routine 使用alter procedure和drop procedurecreate 使用create tablecreate routine 使用create procedurecreate temporary tables 使用create temporary tablescreate user 使用create user、drop user、rename user和revoke all privilegescreate view 使用create viewdelete 使用deletedrop 使用drop tableexecute 使用call和存储过程file 使用select into outfile 和 load data infilegrant option 使用grant 和 revokeindex 使用indexinsert 使用insertlock tables 使用lock tableprocess 使用show full processlistselect 使用selectshow databases 使用show databasesshow view 使用show viewupdate 使用updatereload 使用flushshutdown 使用mysqladmin shutdown(关闭MySQL)super 使用change master、kill、logs、purge、master和set global。还允许mysqladmin????调试登陆replication client 服务器位置的访问replication slave 由复制从属使用================================================= 数据库名.* 数据库中的所有数据库名.表 指定数据库中的某张表数据库名.存储过程 指定数据库中的存储过程*.* 所有数据库 删除权限 revoke 权限 on 数据库.表 from '用户'@'IP地址'; RPMRPM概述RPM（RedHat Package Manager），RedHat软件包管理工具，类似windows里面的setup.exe是Linux这系列操作系统里面的打包安装工具，它虽然是RedHat的标志，但理念是通用的。 RPM包的名称格式: Apache-1.3.23-11.i386.rpm “apache” 软件名称 “1.3.23-11”软件的版本号，主版本和此版本 “i386”是软件所运行的硬件平台，Intel 32位微处理器的统称 “rpm”文件扩展名，代表RPM包 RPM查询命令（rpm -qa）基本语法1$ rpm -qa （功能描述：查询所安装的所有rpm软件包） 经验技巧由于软件包比较多，一般都会采取过滤。rpm -qa | grep rpm软件包 案例（1）查询firefox软件安装情况 123[root@hadoop101 Packages]# rpm -qa |grep firefox -------------firefox-45.0.1-1.el6.centos.x86_64 RPM卸载命令（rpm -e）基本语法123 $ rpm -e RPM软件包 $ rpm -e --nodeps 软件包 选项说明 选项 功能 -e 卸载软件包 –nodeps 卸载软件时，不检查依赖。这样的话，那些使用该软件包的软件在此之后可能就不能正常工作了。 案例（1）卸载firefox软件 1[root@hadoop101 Packages]# rpm -e firefox RPM安装命令（rpm -ivh）基本语法1$ rpm -ivh RPM包全名 选项说明 选项 功能 -i -i=install，安装 -v -v=verbose，显示详细信息 -h -h=hash，进度条 –nodeps –nodeps，不检测依赖进度 案例（1）安装firefox软件 123456789[root@hadoop101 Packages]# pwd-------------------------------/media/CentOS_6.8_Final/Packages[root@hadoop101 Packages]# rpm -ivh firefox-45.0.1-1.el6.centos.x86_64.rpm ---------------------------------------warning: firefox-45.0.1-1.el6.centos.x86_64.rpm: Header V3 RSA/SHA1 Signature, key ID c105b9de: NOKEYPreparing... ########################################### [100%] 1:firefox ########################################### [100%] yumYUM（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装， 语法1yum [options] [command] [package ...] options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为”yes”），-q（不显示安装的过程）等等。 command：要进行的操作。 package：操作的对象。 command 参数 功能 install 安装rpm软件包 update 更新rpm软件包 check-update 检查是否有可用的更新rpm软件包 remove 删除指定的rpm软件包 list 显示软件包信息 clean 清理yum过期的缓存 deplist 显示yum软件包的所有依赖关系 列出所有可更新的软件清单命令：yum check-update 更新所有软件命令：yum update 仅安装指定的软件命令：yum install 仅更新指定的软件命令：yum update 列出所有可安裝的软件清单命令：yum list 删除软件包命令：yum remove 查找软件包 命令：yum search 清除缓存命令: yum clean packages: 清除缓存目录下的软件包 yum clean headers: 清除缓存目录下的 headers yum clean oldheaders: 清除缓存目录下旧的 headers yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers brewbrew 是 Mac 下的一个包管理工具，类似于 centos 下的 yum，可以很方便地进行安装/卸载/更新各种软件包，例如：nodejs, elasticsearch, kibana, mysql, mongodb 等等，可以用来快速搭建各种本地环境，程序员必备工具 安装1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 基本用法 安装/卸载/更新以 nodejs 为例，执行下面命令即可，安装目录在 /usr/local/Cellar install nodejs```12- 如果需要更新或卸载 brew upgrade nodejsbrew remove nodejs 1234567- 其他命令```bashbrew list # 列出当前安装的软件brew search nodejs # 查询与 nodejs 相关的可用软件brew info nodejs # 查询 nodejs 的安装信息 如果需要指定版本，可以在 brew search 查看有没有需要的版本，在 @ 后面指定版本号，例如 brew install thrift@0.9 brew services brew services 是一个非常强大的工具，可以用来管理各种服务的启停，有点像 linux 里面的 services，非常方便，以 elasticsearch 为例 12345brew install elasticsearch # 安装 elasticsearchbrew services start elasticsearch # 启动 elasticsearchbrew services stop elasticsearch # 停止 elasticsearchbrew services restart elasticsearch # 重启 elasticsearchbrew services list # 列出当前的状态 brew services 服务相关配置以及日志路径配置路径：/usr/local/etc/日志路径：/usr/local/var/log systemctl从CentOS 7.x开始，CentOS开始使用systemd服务来代替daemon， 原来管理系统启动和管理系统服务的相关命令全部由systemctl命令来代替。 原来的 service 命令与 systemctl 命令对比 daemon命令 systemctl命令 说明 service [服务] start systemctl start [unit type] 启动服务 service [服务] stop systemctl stop [unit type] 停止服务 service [服务] restart systemctl restart [unit type] 重启服务 此外还是二个systemctl参数没有与service命令参数对应 status：参数来查看服务运行情况 reload：重新加载服务，加载更新后的配置文件（并不是所有服务都支持这个参数，比如network.service） 应用举例： 1234567891011#启动网络服务systemctl start network.service#停止网络服务systemctl stop network.service#重启网络服务systemctl restart network.service#查看网络服务状态systemctl status network.serivce 原来的chkconfig 命令与 systemctl 命令对比设置开机启动/不启动 daemon命令 systemctl命令 说明 chkconfig [服务] on systemctl enable [unit type] 设置服务开机启动 chkconfig [服务] off systemctl disable [unit type] 设备服务禁止开机启动 应用举例： 1234567891011#停止cup电源管理服务systemctl stop cups.service#禁止cups服务开机启动systemctl disable cups.service#查看cups服务状态systemctl status cups.service#重新设置cups服务开机启动systemctl enable cups.service 查看系统上上所有的服务命令格式： 1systemctl [command] [–type=TYPE] [–all] 参数详解： command – list-units：依据unit列出所有启动的unit。加上 –all 才会列出没启动的unit; – list-unit-files:依据/usr/lib/systemd/system/ 内的启动文件，列出启动文件列表 –type=TYPE – 为unit type, 主要有service, socket, target 应用举例： systemctl命令 说明 systemctl 列出所有的系统服务 systemctl list-units 列出所有启动unit systemctl list-unit-files 列出所有启动文件 systemctl list-units –type=service –all 列出所有service类型的unit systemctl list-units –type=service –all grep cpu 列出 cpu电源管理机制的服务 systemctl list-units –type=target –all 列出所有target systemctl特殊的用法 systemctl命令 说明 systemctl is-active [unit type] 查看服务是否运行 systemctl is-enable [unit type] 查看服务是否设置为开机启动 systemctl mask [unit type] 注销指定服务 systemctl unmask [unit type] 取消注销指定服务 应用举例： 1234567891011121314151617#查看网络服务是否启动systemctl is-active network.service#检查网络服务是否设置为开机启动systemctl is-enable network.service#停止cups服务systemctl stop cups.service#注销cups服务systemctl mask cups.service#查看cups服务状态systemctl status cups.service#取消注销cups服务systemctl unmask cups.service","link":"/2020/05/16/Linux&Mac/linux%20%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"},{"title":"JavaScript","text":"JavaScript 技巧百度云网页端倍速 videojs.getPlayers(&quot;html5player_html5_api&quot;).html5player.tech_.setPlaybackRate(2) Array技巧Array.includes Array.indexOf“如果你要在数组中查找元素，请使用 Array.indexOf”。我记得在学习 JavaScript 的时候，在教材中读到这样的一句话。毫无疑问，这句话是真的！ MDN 文档写道，Array.indexOf 将“返回第一次出现给定元素的索引”。因此，如果我们稍后要在代码中使用这个返回的索引，那么使用 Array.indexOf 找到索引就对了。 但是，如果我们只想知道数组是否包含某个值，该怎么办？这似乎是一个是与否的问题，或者说是一个布尔值问题。对于这种情况，我建议使用返回布尔值的 Array.includes。 123456789101112131415161718const characters = [ 'ironman', 'black_widow', 'hulk', 'captain_america', 'hulk', 'thor',];console.log(characters.indexOf('hulk'));// 2console.log(characters.indexOf('batman'));// -1console.log(characters.includes('hulk'));// trueconsole.log(characters.includes('batman'));// false Array.some Array.findArray.find 需要一个回调函数作为参数，并返回一个元素。如果我们想要知道数组是否包含某个值，Array.find 是最好的解决方案吗？可能不是，因为它返回的是一个元素值，而不是一个布尔值。 对于这种情况，我建议使用 Array.some，它返回所需的布尔值。另外，从语义上看，Array.some 表示我们只想知道某个元素是否存在，而不需要得到这个元素 123456789101112131415const characters = [ { id: 1, name: 'ironman', env: 'marvel' }, { id: 2, name: 'black_widow', env: 'marvel' }, { id: 3, name: 'wonder_woman', env: 'dc_comics' },];function hasCharacterFrom(env) { return character =&gt; character.env === env;}console.log(characters.find(hasCharacterFrom('marvel')));// { id: 1, name: 'ironman', env: 'marvel' }console.log(characters.some(hasCharacterFrom('marvel')));// true Array.reduce 而不是链接 Array.filter 和 Array.map我们遍历了两次数组。第一次过滤数组并创建一个较短的数组，第二次又基于 Array.filter 获得数组创建一个包含新值的数组。为了获得我们想要的新数组，我们使用了两个 Array 方法。每个方法都有自己的回调函数和一个用不到的数组——由 Array.filter 创建的那个数组。 为了避免这种性能损耗，我的建议是使用 Array.reduce。结果是一样的，代码却更简单！ 我们可以使用 Array.reduce 进行过滤，并将目标元素添加到累加器中。累加器可以是递增的数字、要填充的对象、要连接的字符串或数组。 在我们的例子中，因为之前使用了 Array.map，所以我建议使用 Array.reduce 将满足条件的数组元素加入到累加器中。在下面的示例中，根据 env 值的具体情况，我们将它添加到累加器中或保持累加器不变。 12345678910111213141516171819202122232425262728const characters = [ { name: 'ironman', env: 'marvel' }, { name: 'black_widow', env: 'marvel' }, { name: 'wonder_woman', env: 'dc_comics' },];console.log( characters .filter(character =&gt; character.env === 'marvel') .map(character =&gt; Object.assign({}, character, { alsoSeenIn: ['Avengers'] })));// [// { name: 'ironman', env: 'marvel', alsoSeenIn: ['Avengers'] },// { name: 'black_widow', env: 'marvel', alsoSeenIn: ['Avengers'] }// ]console.log( characters .reduce((acc, character) =&gt; { return character.env === 'marvel' ? acc.concat(Object.assign({}, character, { alsoSeenIn: ['Avengers'] })) : acc; }, []))// [// { name: 'ironman', env: 'marvel', alsoSeenIn: ['Avengers'] },// { name: 'black_widow', env: 'marvel', alsoSeenIn: ['Avengers'] }// ] Array文档Array.join()1arr.join([separator]) 1234567891011121314const elements = ['Fire', 'Air', 'Water'];console.log(elements.join());// expected output: \"Fire,Air,Water\"console.log(elements.join(''));// expected output: \"FireAirWater\"console.log(elements.join('-'));// expected output: \"Fire-Air-Water\"//&gt; \"Fire,Air,Water\"//&gt; \"FireAirWater\"//&gt; \"Fire-Air-Water\" 参数 separator 可选 指定一个字符串来分隔数组的每个元素。如果需要，将分隔符转换为字符串。如果缺省该值，数组元素用逗号（,）分隔。如果separator是空字符串(&quot;&quot;)，则所有元素之间都没有任何字符。 返回值一个所有数组元素连接的字符串。如果 arr.length 为0，则返回空字符串。 描述所有的数组元素被转换成字符串，再用一个分隔符将这些字符串连接起来。 如果一个元素为 undefined 或 null，它会被转换为空字符串。 Array.reduce()方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。 1arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]) 参数 callback 执行数组中每个值 (如果没有提供 initialValue则第一个值除外)的函数，包含四个参数： accumulator累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（见于下方）。 currentValue数组中正在处理的元素。 index 可选数组中正在处理的当前元素的索引。如果提供initialValue，则起始索引号为0，否则从索引1起始。 array可选调用reduce()的数组 initialValue可选 作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。 返回值函数累计处理的结果 描述reduce为数组中的每一个元素依次执行callback函数，不包括数组中被删除或从未被赋值的元素，接受四个参数： accumulator 累计器 currentValue 当前值 currentIndex 当前索引 array 数组 回调函数第一次执行时，accumulator 和currentValue的取值有两种情况：如果调用reduce()时提供了initialValue，accumulator取值为initialValue，currentValue取数组中的第一个值；如果没有提供 initialValue，那么accumulator取数组中的第一个值，currentValue取数组中的第二个值。 注意：如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。 如果数组为空且没有提供initialValue，会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。 Proxy使用Proxy，你可以将一只猫伪装成一只老虎。下面大约有6个例子，我希望它们能让你相信，Proxy 提供了强大的 Javascript 元编程。 尽管它不像其他ES6功能用的普遍，但Proxy有许多用途，包括运算符重载，对象模拟，简洁而灵活的API创建，对象变化事件，甚至Vue 3背后的内部响应系统提供动力。 Proxy用于修改某些操作的默认行为，也可以理解为在目标对象之前架设一层拦截，外部所有的访问都必须先通过这层拦截，因此提供了一种机制，可以对外部的访问进行过滤和修改。这个词的原理为代理，在这里可以表示由它来“代理”某些操作，译为“代理器”。 var proxy = new Proxy(target, handler); Proxy对象的所有用法，都是上面的这种形式。不同的只是handle参数的写法。其中new Proxy用来生成Proxy实例，target是表示所要拦截的对象，handle是用来定制拦截行为的对象。 下面是 Proxy 最简单的例子是，这是一个有陷阱的代理，一个get陷阱，总是返回42。 1234let target = { x: 10, y: 20};let hanler = { get: (obj, prop) =&gt; 42};target = new Proxy(target, hanler);target.x; //42target.y; //42target.x; // 42 结果是一个对象将为任何属性访问操作都返回“42”。这包括target.x，target['x']，Reflect.get(target, 'x')等。 但是，Proxy 陷阱当然不限于属性的读取。它只是十几个不同陷阱中的一个： handler.get handler.set handler.has handler.apply handler.construct handler.ownKeys handler.deleteProperty handler.defineProperty handler.isExtensible handler.preventExtensions handler.getPrototypeOf handler.setPrototypeOf handler.getOwnPropertyDescriptor 用途 默认值/“零值”在 Go 语言中，有零值的概念，零值是特定于类型的隐式默认结构值。其思想是提供类型安全的默认基元值，或者用gopher的话说，给结构一个有用的零值。 虽然不同的创建模式支持类似的功能，但Javascript无法用隐式初始值包装对象。Javascript中未设置属性的默认值是undefined。但 Proxy 可以改变这种情况。 1const withZeroValue = (target, zeroValue) =&gt; new Proxy(target, { get: (obj, prop) =&gt; (prop in obj ? obj[prop] : zeroValue) }); 函数withZeroValue 用来包装目标对象。如果设置了属性，则返回属性值。否则，它返回一个默认的“零值”。 从技术上讲，这种方法也不是隐含的，但如果我们扩展withZeroValue，以Boolean (false), Number (0), String (&quot;&quot;), Object ({})，Array ([])等对应的零值，则可能是隐含的。 1234let pos = { x: 4, y: 19};console.log(pos.x, pos.y, pos.z); // 4, 19, undefinedpos = withZeroValue(pos, 0);console.log(pos.z, pos.y, pos.z); // 4, 19, 0 此功能可能有用的一个地方是坐标系。绘图库可以基于数据的形状自动支持2D和3D渲染。不是创建两个单独的模型，而是始终将z默认为 0 而不是undefined，这可能是有意义的。 PromisePromise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值. 12345678910111213const promise1 = new Promise(function(resolve, reject) { setTimeout(function() { resolve('foo'); }, 300);});promise1.then(function(value) { console.log(value); // expected output: \"foo\"});console.log(promise1);// expected output: [object Promise] 构造函数语法new Promise( function(resolve, reject) {...} /* executor */ ); executor executor是带有 resolve 和 reject 两个参数的函数 。Promise构造函数执行时立即调用executor 函数， resolve 和 reject 两个函数作为参数传递给executor（executor 函数在Promise构造函数返回所建promise实例对象前被调用）。resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled（完成）或rejected（失败）。executor 内部通常会执行一些异步操作，一旦异步操作执行完毕(可能成功/失败)，要么调用resolve函数来将promise状态改成fulfilled，要么调用reject 函数将promise的状态改为rejected。如果在executor函数中抛出一个错误，那么该promise 状态为rejected。executor函数的返回值被忽略。 介绍Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象。 一个 Promise有以下几种状态: pending: 初始状态，既不是成功，也不是失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 pending 状态的 Promise 对象可能会变为fulfilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当Promise状态为fulfilled时，调用 then 的 onfulfilled 方法，当Promise状态为rejected时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。 因为 Promise.prototype.then 和 Promise.prototype.catch 方法返回promise 对象， 所以它们可以被链式调用。 不要和惰性求值混淆： 有一些语言中有惰性求值和延时计算的特性，它们也被称为“promises”，例如Scheme. Javascript中的promise代表一种已经发生的状态， 而且可以通过回调方法链在一起。 如果你想要的是表达式的延时计算，考虑无参数的”箭头方法“: f = () =&gt;表达式 创建惰性求值的表达式，使用 f() 求值。 注意： 如果一个promise对象处在fulfilled或rejected状态而不是pending状态，那么它也可以被称为settled状态。你可能也会听到一个术语resolved ，它表示promise对象处于settled状态。关于promise的术语， Domenic Denicola 的 States and fates 有更多详情可供参考。 属性Promise.length length属性，其值总是为 1 (构造器参数的数目). Promise.prototype 表示 Promise 构造器的原型. 方法 Promise.all(iterable) 这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个promise对象的状态集合。（可以参考jQuery.when方法—译者注） Promise.race(iterable) 当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。 Promise.reject(reason) 返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法 Promise.resolve(value) 返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。 原型属性 Promise.prototype.constructor 返回被创建的实例函数. 默认为 Promise 函数. 方法 Promise.prototype.catch(onRejected) 添加一个拒绝(rejection) 回调到当前 promise, 返回一个新的promise。当这个回调函数被调用，新 promise 将以它的返回值来resolve，否则如果当前promise 进入fulfilled状态，则以当前promise的完成结果作为新promise的完成结果. Promise.prototype.then(onFulfilled, onRejected) 添加解决(fulfillment)和拒绝(rejection)回调到当前 promise, 返回一个新的 promise, 将以回调的返回值来resolve. Promise.prototype.finally(onFinally) 添加一个事件处理回调于当前promise对象，并且在原promise对象解析完毕后，返回一个新的promise对象。回调会在当前promise运行完毕后被调用，无论当前promise的状态是完成(fulfilled)还是失败(rejected) 自己实现剖析https://mp.weixin.qq.com/s/3xfLpQ2h0v8yt2W7opLwGw 20行案例https://mp.weixin.qq.com/s/oHBv7r6x7tVOwm-LsnIbgA 123456789101112131415161718192021222324function Promise(excutor) { var self = this self.onResolvedCallback = [] function resolve(value) { setTimeout(() =&gt; { self.data = value self.onResolvedCallback.forEach(callback =&gt; callback(value)) }) } excutor(resolve.bind(self))}Promise.prototype.then = function(onResolved) { var self = this returnnewPromise(resolve =&gt; { self.onResolvedCallback.push(function() { var result = onResolved(self.data) if (result instanceofPromise) { result.then(resolve) } else { resolve(result) } }) })} 实现过程 首先来实现Promise构造函数 123456789101112131415161718function Promise(excutor) { var self = this self.onResolvedCallback = [] // Promise resolve时的回调函数集 // 传递给Promise处理函数的resolve // 这里直接往实例上挂个data // 然后把onResolvedCallback数组里的函数依次执行一遍就可以 function resolve(value) { // 注意promise的then函数需要异步执行 setTimeout(() =&gt; { self.data = value self.onResolvedCallback.forEach(callback =&gt; callback(value)) }) } // 执行用户传入的函数 excutor(resolve.bind(self))} 好，写到这里先回过头来看案例 Event LoopEvent Loop是一个程序结构，用于等待和分派消息和事件，我个人的理解是 JS 中的 Event Loop 是浏览器或 Node 的一种协调 JavaScript 单线程运行时不会阻塞的一种机制。 JS 的单线程很多人都知道的是，JavaScript 是一门动态的解释型的语言，具有跨平台性。在被问到 JavaScript 为什么是一门单线程的语言，有的人可能会这么回答：“语言特性决定了 JavaScript 是一个单线程语言，JavaScript 天生是一个单线程语言”，这只不过是一层糖衣罢了。 JavaScript 从诞生起就是单线程，原因大概是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。 准确的来说，我认为 JavaScript 的单线程是指 JavaScript 引擎是单线程的，JavaScript 的引擎并不是独立运行的，跨平台意味着 JavaScript 依赖其运行的宿主环境 — 浏览器(大部分情况下是浏览器)。 浏览器需要渲染 DOM，JavaScript 可以修改 DOM 结构，JavaScript 执行时，浏览器 DOM 渲染停止。如果 JavaScript 引擎线程不是单线程的，那么可以同时执行多段 JavaScript，如果这多段 JavaScript 都操作 DOM，那么就会出现 DOM 冲突。 举个例子来说，在同一时刻执行两个 script 对同一个 DOM 元素进行操作，一个修改 DOM，一个删除 DOM，那这样话浏览器就会懵逼了，它就不知道到底该听谁的，会有资源竞争，这也是 JavaScript 单线程的原因之一。 浏览器浏览器的多线程之前说过，JavaScript 运行的宿主环境浏览器是多线程的。 以 Chrome 来说，我们可以通过 Chrome 的任务管理器来看看。 当你打开一个 Tab 页面的时候，就创建了一个进程。如果从一个页面打开了另一个页面，打开的页面和当前的页面属于同一站点的话，那么这个页面会复用父页面的渲染进程。 浏览器主线程常驻线程 GUI 渲染线程 绘制页面，解析 HTML、CSS，构建 DOM 树，布局和绘制等 页面重绘和回流 与 JS 引擎线程互斥，也就是所谓的 JS 执行阻塞页面更新 JS 引擎线程 负责 JS 脚本代码的执行 负责准执行准备好待执行的事件，即定时器计数结束，或异步请求成功并正确返回的事件 与 GUI 渲染线程互斥，执行时间过长将阻塞页面的渲染 事件触发线程 负责将准备好的事件交给 JS 引擎线程执行 多个事件加入任务队列的时候需要排队等待(JS 的单线程) 定时器触发线程 负责执行异步的定时器类的事件，如 setTimeout、setInterval 定时器到时间之后把注册的回调加到任务队列的队尾 HTTP 请求线程 负责执行异步请求 主线程执行代码遇到异步请求的时候会把函数交给该线程处理，当监听到状态变更事件，如果有回调函数，该线程会把回调函数加入到任务队列的队尾等待执行 这里没看懂没关系，后面我会再说。 浏览器端的 Event Loop 上图是一张 JS 的运行机制图，Js 运行时大致会分为几个部分： Call Stack：调用栈(执行栈)，所有同步任务在主线程上执行，形成一个执行栈，因为 JS 单线程的原因，所以调用栈中每次只能执行一个任务，当遇到的同步任务执行完之后，由任务队列提供任务给调用栈执行。 Task Queue：任务队列，存放着异步任务，当异步任务可以执行的时候，任务队列会通知主线程，然后该任务会进入主线程执行。任务队列中的都是已经完成的异步操作，而不是说注册一个异步任务就会被放在这个任务队列中。 说到这里，Event Loop 也可以理解为：不断地从任务队列中取出任务执行的一个过程。 同步任务和异步任务上文已经说过了 JavaScript 是一门单线程的语言，一次只能执行一个任务，如果所有的任务都是同步任务，那么程序可能因为等待会出现假死状态，这对于一个用户体验很强的语言来说是非常不友好的。 比如说向服务端请求资源，你不可能一直不停的循环判断有没有拿到数据，就好像你点了个外卖，点完之后就开始一直打电话问外卖有没有送到，外卖小哥都会抄着锅铲来打你(狗头)。因此，在 JavaScript 中任务有了同步任务和异步任务，异步任务通过注册回调函数，等到数据来了就通知主程序。 同步任务：必须等到结果来了之后才能做其他的事情，举例来说就是你烧水的时候一直等在水壶旁边等水烧开，期间不做其他的任何事情。 异步任务：不需要等到结果来了才能继续往下走，等结果期间可以做其他的事情，结果来了会收到通知。举例来说就是你烧水的时候可以去做自己想做的事情，听到水烧开的声音之后再去处理。 从概念就可以看出来，异步任务从一定程度上来看比同步任务更高效一些，核心是提高了用户体验。 Event LoopEvent Loop 很好的调度了任务的运行，宏任务和微任务也知道了，现在我们就来看看它的调度运行机制。 JavaScript 的代码执行时，主线程会从上到下一步步的执行代码，同步任务会被依次加入执行栈中先执行，异步任务会在拿到结果的时候将注册的回调函数放入任务队列，当执行栈中的没有任务在执行的时候，引擎会从任务队列中读取任务压入执行栈(Call Stack)中处理执行。 宏任务和微任务现在就有一个问题了，任务队列是一个消息队列，先进先出，那就是说，后来的事件都是被加在队尾等到前面的事件执行完了才会被执行。如果在执行的过程中突然有重要的数据需要获取，或是说有事件突然需要处理一下，按照队列的先进先出顺序这些是无法得到及时处理的。这个时候就催生了宏任务和微任务，微任务使得一些异步任务得到及时的处理。 曾经看到的一个例子很好，宏任务和微任务形象的来说就是：你去营业厅办一个业务会有一个排队号码，当叫到你的号码的时候你去窗口办充值业务(宏任务执行)，在你办理充值的时候你又想改个套餐(微任务)，这个时候工作人员会直接帮你办，不可能让你重新排队。 所以上文说过的异步任务又分为宏任务和微任务，JS 运行时任务队列会分为宏任务队列和微任务队列，分别对应宏任务和微任务。 先介绍一下(浏览器环境的)宏任务和微任务大致有哪些： 宏任务： script(整体的代码) setTimeout setInterval I/O 操作 UI 渲染 (对这个笔者持保留意见) 微任务： Promise.then MutationObserver 事件运行顺序 执行同步任务，同步任务不需要做特殊处理，直接执行(下面的步骤中遇到同步任务都是一样处理) — 第一轮从 script开始 从宏任务队列中取出队头任务执行 如果产生了宏任务，将宏任务放入宏任务队列，下次轮循的时候执行 如果产生了微任务，将微任务放入微任务队列 执行完当前宏任务之后，取出微任务队列中的所有任务依次执行 如果微任务执行过程中产生了新的微任务，则继续执行微任务，直到微任务的队列为空 轮循，循环以上 2 - 6 总的来说就是：同步任务/宏任务 -&gt; 执行产生的所有微任务(包括微任务产生的微任务) -&gt; 同步任务/宏任务 -&gt; 执行产生的所有微任务(包括微任务产生的微任务) -&gt; 循环…… 注意：微任务队列 举个栗子光说不练假把式，现在就来看一个例子： 举个栗子 放图的原因是为了让大家在看解析之前可以先自己按照运行顺序走一遍，写好答案之后再来看解析。解析：(用绿色的表示同步任务和宏任务，红色表示微任务) 12345678910111213141516171819202122232425+ console.log('script start')+ setTimeout(function() {+ console.log('setTimeout')+ }, 0)+ new Promise((resolve, reject)=&gt;{+ console.log(\"promise1\")+ resolve()+ })- .then(()=&gt;{- console.log(\"then11\")+ new Promise((resolve, reject)=&gt;{+ console.log(\"promise2\")+ resolve();+ })- .then(() =&gt; {- console.log(\"then2-1\")- })- .then(() =&gt; {- console.log(\"then2-2\")- })- })- .then(()=&gt;{- console.log(\"then12\")- })+ console.log('script end') 首先遇到 console.log()，输出 script start 遇到 setTimeout 产生宏任务，注册到宏任务队列[setTimeout]，下一轮 Event Loop 的时候在执行 然后遇到 new Promise 构造声明(同步)，log 输出 promise1，然后 resolve resolve 匹配到 promise1 的第一个 then，把这个 then 注册到微任务队列[then11]中，继续当前整体脚本的执行 遇到最后的一个 log，输出 script end，当前执行栈清空 从微任务队列中取出队头任务’then11’ 进行执行，其中有一个 log，输出 then11 往下遇到 new Promise 构造声明(同步)，log 输出 promise2，然后 resolve resolve 匹配到 promise2 的第一个 then，把这个 then 注册到微任务队列[then2-1]，当前 then11 可执行部分结束，然后产生了 promise1 的第二个 then，把这个 then 注册到微任务队列[then2-1, then12] 拿出微任务队头任务’then2-1’ 执行，log 输出 then2-1，触发 promise2 的第二个 then，注册到微任务队列[then12, then2-2] 拿出微任务队头任务’then12’，log 输出 then12 拿出微任务队头任务’then2-2’，log 输出 then2-2 微任务队列执行完毕，别忘了宏任务队列中的 setTimeout，log 输出 setTimeout 经过以上一番缜(xia)密(gao)分析，希望没有绕晕你，最后的输出结果就是：script start -&gt; promise1 -&gt; script end -&gt; then11 -&gt; promise2 -&gt; then2-1 -&gt; then12 -&gt; then2-2 -&gt; setTimeout 宏任务？微任务？不知道大家看了宏任务和微任务之后会不会有一个疑惑，宏任务和微任务都是异步任务，微任务之前说过了是为了及时解决一些必要事件而产生的。 为什么要有微任务？为什么要有微任务的原因前面已经说了，这里就不再赘述，简单说一下就是为了及时处理一些任务，不然等到最后再执行的时候拿到的数据可能已经是被污染的数据达不到预期目标了。 是什么宏任务？什么是微任务？相信大家在学习 Event Loop 查找资料的时候，肯定各种资料里面都会讲到宏任务和微任务，但是不知道你有没有灵魂拷问过你自己：什么是宏任务？什么是微任务？怎么区分宏任务和微任务？不能只是默许接受这个概念，在这里，我根据我的个人理解进行一番说(hu)明(che) 宏任务和微任务的真面目其实在 Chrome 的源码中并没有什么宏任务和微任务的代码或是说明，在 JS 大会[3]上提到过微任务这个名词，但是也没有说到底什么是微任务。 宏任务文章最开始的时候说过，在 chrome 里，每个页面都对应一个进程。而该进程又有多个线程，比如 JS 线程、渲染线程、IO 线程、网络线程、定时器线程等等，这些线程之间的通信是通过向对象的任务队列中添加一个任务（postTask）来实现的。宏任务的本质可以认为是多线程事件循环或消息循环，也就是线程间通信的一个消息队列。 就拿 setTimeout 举例来说，当遇到它的时候，浏览器就会对 Event Loop 说：嘿，我有一个任务交给你，Event Loop 就会说：好的，我会把它加到我的 todoList 中，之后我会执行它，它是需要调用 API 的。 宏任务的真面目是浏览器派发，与 JS 引擎无关的，参与了 Event Loop 调度的任务 微任务微任务是在运行宏任务/同步任务的时候产生的，是属于当前任务的，所以它不需要浏览器的支持，内置在 JS 当中，直接在 JS 的引擎中就被执行掉了。 特殊的点 async 隐式返回 Promise 作为结果 执行完 await 之后直接跳出 async 函数，让出执行的所有权 当前任务的其他代码执行完之后再次获得执行权进行执行 立即 resolve 的 Promise 对象，是在本轮”事件循环”的结束时执行，而不是在下一轮”事件循环”的开始时 再举个栗子123456789101112131415161718192021222324252627console.log('script start') asyncfunction async1() { await async2() console.log('async1 end') } asyncfunction async2() { console.log('async2 end') } async1() setTimeout(function() { console.log('setTimeout') }, 0) newPromise(resolve =&gt; { console.log('Promise') resolve() }) .then(function() { console.log('promise1') }) .then(function() { console.log('promise2') }) console.log('script end') 按照之前的分析方法去分析之后就会得出一个结果：script start =&gt; async2 end =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; async1 end =&gt; setTimeout 可以看出 async1 函数获取执行权是作为微任务的队尾，但是，在 Chrome73(金丝雀) 版本之后，async 的执行优化了，它会在 promise1 和 promise2 的输出之前执行。笔者大概了解了一下应该是用 PromiseResolve 对 await 进行了优化，减少了 Promise 的再次创建，有兴趣的小伙伴可以看看 Chrome 的源码。 Node 中的 Event LoopNode 中也有宏任务和微任务，与浏览器中的事件循环类似。Node 与浏览器事件循环不同，其中有多个宏任务队列，而浏览器是只有一个宏任务队列。 Node 的架构底层是有 libuv，它是 Node 自身的动力来源之一，通过它可以去调用一些底层操作，Node 中的 Event Loop 功能就是在 libuv 中封装实现的。 宏任务和微任务Node 中的宏任务和微任务在浏览器端的 JS 相比增加了一些，这里只列出浏览器端没有的： 宏任务 setImmediate 微任务 process.nextTick 事件循环机制的六个阶段 Node 的事件循环分成了六个阶段，每个阶段对应一个宏任务队列，相当于是宏任务进行了一个分类。 timers(计时器)执行 setTimeout 以及 setInterval 的回调 I/O callbacks处理网络、流、TCP 的错误回调 idel, prepare — 闲置阶段node 内部使用 poll(轮循)执行 poll 中的 I/O 队列，检查定时器是否到时间 check(检查)存放 setImmediate 回调 close callbacks关闭回调，例如 sockect.on(‘close’) 轮循顺序执行的轮循顺序 — 每个阶段都要等对应的宏任务队列执行完毕才会进入到下一个阶段的宏任务队列 timers I/O callbacks poll setImmediate close events 每两个阶段之间执行微任务队列 Event Loop 过程 执行全局的 script 同步代码 执行微任务队列，先执行所有 Next Tick 队列中的所有任务，再执行其他的微任务队列中的所有任务 开始执行宏任务，共六个阶段，从第一个阶段开始执行自己宏任务队列中的所有任务(浏览器是从宏任务队列中取第一个执行！！) 每个阶段的宏任务执行完毕之后，开始执行微任务 TimersQueue -&gt; 步骤2 -&gt; I/O Queue -&gt; 步骤2 -&gt; Check Queue -&gt; 步骤2 -&gt; Close Callback Queue -&gt; 步骤2 -&gt; TimersQueue … 这里要注意的是，nextTick 事件是一个单独的队列，它的优先级会高于微任务，所以在当前宏任务/同步任务执行完成之后，会先执行 nextTick 队列中的所有任务，再去执行微任务队列中的所有任务。 setTimeout 和 setImmediate在这里要单独说一下 setTimeout 和 setImmediate，setTimeout 定时器很熟悉，那就说说 setImmediate setImmediate() 方法用于把一些需要长时间运行的操作放在一个回调函数里，并在浏览器完成其他操作（如事件和显示更新）后立即运行回调函数。从定义来看就是为了防止一些耗时长的操作阻塞后面的操作，这也是为什么 check 阶段运行顺序排的比较后。 举个栗子我们来看这样的一个例子： 1234567setTimeout(() =&gt; { console.log('setTimeout')}, 0)setImmediate(() =&gt; { console.log('setImmediate')}) 这里涉及 timers 阶段和 check 阶段，按照上面的运行顺序来说，timers 阶段是在第一个执行的，会早于 check 阶段。运行这段程序可以看到如下的结果： 可是再多运行几次，你就会看到如下的结果： setImmediate 的输出跑到 setTimeout 前面去了，这时候就是：小朋友你是否有很多的问号❓ 分析我们来分析一下原因，timers 阶段确实是在 check 阶段之前，但是在 timers 阶段时候，这里的 setTimeout 真的到了执行的时间吗？ 这里就要先看看 setTiemout(fn, 0)，这个语句的意思不是指不延迟的执行，而是指在可以执行 setTimeout 的时候就立即执行它的回调，也就是处理完当前事件的时候立即执行回调。 在 Node 中 setTimeout 第二个时间参数的最小值是 1ms，小于 1ms 会被初始化为 1(浏览器中最小值是 4ms)，所以在这里 setTimeout(fn, 0) === setTimeout(fn, 1) setTimeout 的回调函数在 timers 阶段执行，setImmediate 的回调函数在 check 阶段执行，Event Loop 的开始会先检查 timers 阶段，但是在代码开始运行之前到 timers 阶段(代码的启动、运行)会消耗一定的时间，所以会出现两种情况： timers 前的准备时间超过 1ms，满足 loop -&gt; timers &gt;= 1，setTimeout 的时钟周期到了，则执行 timers 阶段(setTimeout)的回调函数 timers 前的准备时间小于 1ms，还没到 setTimeout 预设的时间，则先执行 check 阶段(setImmediate)的回调函数，下一次 Event Loop 再进入 timers 阶段执行 timer 阶段(setTimeout)的回调函数 最开始就说了，一个优秀的程序员要让自己的代码按照自己想要的顺序运行，下面我们就来控制一下 setTimeout 和 setImediate 的运行。 让 setTimeout 先执行上面代码运行顺序不同无非就是因为 Node 准备时间的不确定性，我们可以直接手动延长准备时间👇 123456789const start = Date.now() while (Date.now() - start &lt; 10) setTimeout(() =&gt; { console.log('setTimeout') }, 0) setImmediate(() =&gt; { console.log('setImmediate') }) 让 setImmediate 先执行setImmediate 是在 check 阶段执行，相对于 setTimeout 来说是在 timers 阶段之后，只需要想办法把程序的运行环境控制在 timers 阶段之后就可以了。 让程序至少从 I/O callbacks 阶段开始 — 可以套一层文件读写把把程序控制在 I/O callbacks 阶段的运行环境中👇 1234567891011const fs = require('fs')fs.readFile(__dirname, () =&gt; { setTimeout(() =&gt; { console.log('setTimeout') }, 0) setImmediate(() =&gt; { console.log('setImmediate') })}) Node 11.x 的变化timers 阶段的执行有所变化 12345setTimeout(() =&gt;console.log('timeout1'))setTimeout(() =&gt; { console.log('timeout2') Promise.resolve().then(() =&gt;console.log('promise resolve'))}) node 10 及之前的版本：要考虑上一个定时器执行完成时，下一个定时器是否到时间加入了任务队列中，如果未到时间，先执行其他的代码。比如：timer1 执行完之后 timer2 到了任务队列中，顺序为 timer1 -&gt; timer2 -&gt; promise resolvetimer2 执行完之后 timer2 还没到任务队列中，顺序为 timer1 -&gt; promise resolve -&gt; timer2 node 11 及其之后的版本：timeout1 -&gt; timeout2 -&gt; promise resolve一旦执行某个阶段里的一个宏任务之后就立刻执行微任务队列，这和浏览器端运行是一致的。 小结Node 和端浏览器端有什么不同 浏览器端的 Event Loop 和 Node.js 中的 Event Loop 是不同的，实现机制也不一样 Node.js 可以理解成有4个宏任务队列和2个微任务队列，但是执行宏任务时有6个阶段 Node.js 中限制性全局 script 代码，执行完同步代码后，先从微任务队列 Next Tick Queue 中取出所有任务放入调用栈执行，再从其他微任务队列中取出所有任务放入调用栈中执行，然后开始宏任务的6个阶段，每个阶段都将其宏任务队列中的所有任务都取出来执行(浏览器是只取第一个执行)，每个宏任务阶段执行完毕之后开始执行微任务，再开始执行下一阶段宏任务，以此构成事件循环 宏任务包括 …. 微任务包括 …. 看到这里，你应该对浏览器端和 Node 端的 Event Loop 有了一定的了解，那就留一个题目。 不直接放代码是想让大家先自己思考然后在敲代码运行一遍~","link":"/2020/05/16/%E5%A4%A7%E5%89%8D%E7%AB%AF/JavaScript/"},{"title":"Webpack 笔记","text":"webpack简介webpack是什么webpack 是一种前端资源构建工具，一个静态模块打包器(module bundler)。在 webpack 看来, 前端的所有资源文件(js/json/css/img/less/…)都会作为模块处理。它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)。 webpack 五个核心概念Entry入口(Entry)指示 webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图。 Output输出(Output)指示 webpack 打包后的资源 bundles 输出到哪里去，以及如何命名。 LoaderLoader 让 webpack 能 够 去 处 理 那 些 非 JavaScript 文 件 (webpack 自 身 只 理 解 JavaScript) Plugins插件(Plugins)可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩， 一直到重新定义环境中的变量等。 Mode模式(Mode)指示 webpack 使用相应模式的配置。 选项 描述 特点 development 会将 DefinePlugin 中 process.env.NODE_ENV 的值设置 为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin。 能让代码本地调试 运行的环境 production 会将 DefinePlugin 中 process.env.NODE_ENV 的值设置 为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 TerserPlugin。 能让代码优化上线 运行的环境 基本编译打包命令 创建文件 运行指令 开发环境指令： webpack src/js/index.js -o build/js/built.js --mode=development 功能：webpack 能够编译打包 js 和 json 文件，并且能将 es6 的模块化语法转换成 浏览器能识别的语法。 生产环境指令：webpack src/js/index.js -o build/js/built.js --mode=production 功能：在开发配置功能上多一个功能，压缩代码。 结论:webpack 能够编译打包 js 和 json 文件。 能将 es6 的模块化语法转换成浏览器能识别的语法。能压缩代码。 问题 不能编译打包 css、img 等文件。 不能将 js 的 es6 基本语法转化为 es5 以下语法。 这就引出了webpack的自定义配置。 webpack 开发环境的基本配置创建配置文件 创建文件 webpack.config.js 配置内容如下 123456789const { resolve } = require('path'); // node 内置核心模块，用来处理路径问题。module.exports = {entry: './src/js/index.js', // 入口文件output: { // 输出配置filename: './built.js', // 输出文件名path: resolve(__dirname, 'build/js') // 输出文件路径配置},mode: 'development' //开发环境}; 运行指令: webpack(与上节相比，少了入口出口文件以及参数) 结论: 此时功能与上节一致。 打包样式资源 下载安装 相关样式的loader 包 npm i css-loader style-loader less-loader less -D 修改配置文件（主要新增module对象，制定rules，每一个rule会用正则匹配到对应的一类文件，然后用指定的loader加载） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// resolve 用来拼接绝对路径的方法const {resolve} = require('path');module.exports = {// webpack 配置// 入口起点 entry: './src/index.js',// 输出 output: {// 输出文件名 filename: 'built.js',// 输出路径// __dirname nodejs 的变量，代表当前文件的目录绝对路径 path: resolve(__dirname, 'build') },// loader 的配置 module: { rules: [// 详细 loader 配置// 不同文件必须配置不同 loader 处理 {// 匹配哪些文件 test: /\\.css$/,// 使用哪些 loader 进行处理 use: [// use 数组中 loader 执行顺序：从右到左，从下到上 依次执行// 创建 style 标签，将 js 中的样式资源插入进行，添加到 head 中生效 'style-loader',// 将 css 文件变成 commonjs 模块加载 js 中，里面内容是样式字符串 'css-loader' ] }, { test: /\\.less$/, use: [ 'style-loader', 'css-loader',// 将 less 文件编译成 css 文件// 需要下载 less-loader 和 less 'less-loader' ] } ] },// plugins 的配置 plugins: [// 详细 plugins 的配置 ],// 模式 mode: 'development', // 开发模式// mode: 'production'} 运行指令: webpack 如果遇到其他样式文件如sass，可以参考自行配置。 打包 HTML 资源 创建相关html文件 下载安装 plugin 包 npm install --save-dev html-webpack-plugin 修改配置文件（html比较特殊，使用plugins 配置） 12345678910111213141516171819202122232425const { resolve } = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = {entry: './src/index.js',output: {filename: 'built.js',path: resolve(__dirname, 'build')},module: {rules: [// loader 的配置]},plugins: [// plugins 的配置// html-webpack-plugin// 功能：默认会创建一个空的 HTML，自动引入打包输出的所有资源（JS/CSS）// 需求：需要有结构的 HTML 文件new HtmlWebpackPlugin({// 复制 './src/index.html' 文件，并自动引入打包输出的所有资源（JS/CSS）template: './src/index.html'})],mode: 'development'}; 运行指令: webpack 打包图片资源 下载安装 loader 包 npm install --save-dev html-loader url-loader file-loader 配置对应文件（同上增加rule） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const {resolve} = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = { entry: './src/index.js', output: { filename: 'built.js', path: resolve(__dirname, 'build') }, module: { rules: [ {// 问题：默认处理不了 html 中 img 图片// 处理图片资源 test: /\\.(jpg|png|gif)$/,// 使用一个 loader// 下载 url-loader file-loader loader: 'url-loader', options: {// 图片大小小于 8kb，就会被 base64 处理// 优点: 减少请求数量（减轻服务器压力）// 缺点：图片体积会更大（文件请求速度更慢） limit: 8 * 1024,// 问题：因为 url-loader 默认使用 es6 模块化解析，而 html-loader 引入图片是 commonjs// 解析时会出问题：[object Module]// 解决：关闭 url-loader 的 es6 模块化，使用 commonjs 解析 esModule: false,// 给图片进行重命名// [hash:10]取图片的 hash 的前 10 位// [ext]取文件原来扩展名 name: '[hash:10].[ext]' } }, { test: /\\.html$/,// 处理 html 文件的 img 图片（负责引入 img，从而能被 url-loader 进行处理） loader: 'html-loader' } ] }, plugins: [ new HtmlWebpackPlugin({ template: './src/index.html' }) ], mode: 'development'}; 运行指令: webpack 打包其他资源对于除了以上的文件外，还有其他各种资源文件需要处理，如.ttf .svg .eot等，这里直接使用file-loader处理。 增加对应rule即可: 123456789// 打包其他资源(除了 html/js/css 资源以外的资源){// 排除 css/js/html 资源 exclude: /\\.(css|js|html|less)$/, loader: 'file-loader', options: { name: '[hash:10].[ext]' }} devserver 搭建对于前端工程化开发，一定离不开一个能够热更新的开发服务器。 可以在webpack.config.js中如下配置： 123456789101112131415module.exports = { ... mode: 'development', devServer: { // 项目构建后路径 contentBase: resolve(__dirname, 'build'), // 启动 gzip 压缩 compress: true, // 端口号 port: 3000, // 自动打开浏览器 open: true } ...}; 下载webpack-dev-server后直接运行即可。 打包后对应文件放在对应文件夹以img为例，在对应的rule下设置outputPath 123456789101112{ // 处理图片资源 test: /\\.(jpg|png|gif)$/, loader: 'url-loader', options: { limit: 8 * 1024, name: '[hash:10].[ext]', // 关闭 es6 模块化 esModule: false, outputPath: 'imgs' }} 开发config模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657module.exports = { entry: './src/js/index.js', output: { filename: 'js/built.js', path: resolve(__dirname, 'build'), }, module: { rules: [ // loader 的配置 { // 处理 less 资源 test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'], }, { // 处理 css 资源 test: /\\.css$/, use: ['style-loader', 'css-loader'], }, { // 处理图片资源 test: /\\.(jpg|png|gif)$/, loader: 'url-loader', options: { limit: 8 * 1024, name: '[hash:10].[ext]', // 关闭 es6 模块化 esModule: false, outputPath: 'imgs', }, }, { // 处理 html 中 img 资源 test: /\\.html$/, loader: 'html-loader', }, { // 处理其他资源 exclude: /\\.(html|js|css|less|jpg|png|gif)/, loader: 'file-loader', options: { name: '[hash:10].[ext]', outputPath: 'media', }, }, ], }, plugins: [ // plugins 的配置 new HtmlWebpackPlugin({ template: './src/index.html', }), ], mode: 'development', } webpack 生产环境的基本配置提取 css 成单独文件假设如下文件目录 下载插件 npm install --save-dev mini-css-extract-plugin 处理css时: 123456789101112131415161718192021const MiniCssExtractPlugin = require('mini-css-extract-plugin');....rules: [ { test: /\\.css$/, use: [ // 创建 style 标签，将样式放入 // 'style-loader', // 这个 loader 取代 style-loader。作用：提取 js 中的 css 成单独文件 MiniCssExtractPlugin.loader, // 将 css 文件整合到 js 文件中 'css-loader', ], },],plugins: [ new MiniCssExtractPlugin({ // 对输出的 css 文件进行重命名 filename: 'css/built.css' })] css 兼容性处理 npm install --save-dev postcss-loader postcss-preset-env 如下，配置postcss-loader后，再在package.json中配置browserslist(详细配置可以谷歌)，再配置process.env.NODE_ENV后即可，执行webpack后，可以发现CSS自动添加了不同浏览器的适配代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667const { resolve } = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin')const MiniCssExtractPlugin = require('mini-css-extract-plugin')// 设置nodejs环境变量// process.env.NODE_ENV = 'development';module.exports = { entry: './src/js/index.js', output: { filename: 'js/built.js', path: resolve(__dirname, 'build'), }, module: { rules: [ { test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', /* css兼容性处理：postcss --&gt; postcss-loader postcss-preset-env 帮postcss找到package.json中browserslist里面的配置，通过配置加载指定的css兼容性样式 \"browserslist\": { // 开发环境 --&gt; 设置node环境变量：process.env.NODE_ENV = development \"development\": [ \"last 1 chrome version\", \"last 1 firefox version\", \"last 1 safari version\" ], // 生产环境：默认是看生产环境 \"production\": [ \"&gt;0.2%\", \"not dead\", \"not op_mini all\" ] } */ // 使用loader的默认配置 // 'postcss-loader', // 修改loader的配置 { loader: 'postcss-loader', options: { ident: 'postcss', plugins: () =&gt; [ // postcss的插件 require('postcss-preset-env')(), ], }, }, ], }, ], }, plugins: [ new HtmlWebpackPlugin({ template: './src/index.html', }), new MiniCssExtractPlugin({ filename: 'css/built.css', }), ], mode: 'development',} 压缩 css使用npm install --save-dev optimize-css-assets-webpack-plugin 12345const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')plugins: [ // 压缩 css new OptimizeCssAssetsWebpackPlugin()] 只需加入以上配置即可！ js 语法检查(eslint)使用npm install --save-dev eslint-loader eslint eslint-config-airbnb-base eslint-plugin-import 语法检查： eslint-loader eslint注意：只检查自己写的源代码，第三方的库是不用检查的设置检查规则： package.json中eslintConfig中设置： 123\"eslintConfig\": { \"extends\": \"airbnb-base\"} 依赖airbnb –&gt; eslint-config-airbnb-base eslint-plugin-import eslint 配置rule: 123456789{ test: /\\.js$/, exclude: /node_modules/,//记得排除 loader: 'eslint-loader', options: { // 自动修复eslint的错误 fix: true }} 如果不想检查某一句： 123// 下一行eslint所有规则都失效（下一行不进行eslint检查）// eslint-disable-next-lineconsole.log(add(2, 5)); js 兼容性处理(babel)安装npm install --save-dev babel-loader @babel/core @babel/preset-env @babel/polyfill core-js js兼容性处理：babel-loader @babel/core 基本js兼容性处理 –&gt; @babel/preset-env 问题：只能转换基本语法，如promise高级语法不能转换 全部js兼容性处理 –&gt; @babel/polyfill 问题：我只要解决部分兼容性问题，但是将所有兼容性代码全部引入，体积太大了~ 需要做兼容性处理的就做：按需加载 –&gt; core-js 配置 1234567891011121314151617181920212223242526272829{ test: /\\.js$/, exclude: /node_modules/, loader: 'babel-loader', options: { // 预设：指示babel做怎么样的兼容性处理 presets: [ [ '@babel/preset-env', { // 按需加载 useBuiltIns: 'usage', // 指定core-js版本 corejs: { version: 3 }, // 指定兼容性做到哪个版本浏览器 targets: { chrome: '60', firefox: '60', ie: '9', safari: '10', edge: '17' } } ] ] }} js 压缩生产环境下会自动压缩js代码 1234567891011121314151617const { resolve } = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = { entry: './src/js/index.js', output: { filename: 'js/built.js', path: resolve(__dirname, 'build') }, plugins: [ new HtmlWebpackPlugin({ template: './src/index.html' }) ], // 生产环境下会自动压缩js代码 mode: 'production'}; HTML 压缩直接使用之前安装的HtmlWebpackPlugin 123456789101112plugins: [ new HtmlWebpackPlugin({ template: './src/index.html', // 压缩html代码 minify: { // 移除空格 collapseWhitespace: true, // 移除注释 removeComments: true } })] webpack 优化配置 webpack性能优化 开发环境性能优化 生产环境性能优化 开发环境性能优化 优化打包构建速度 HMR 优化代码调试 source-map 生产环境性能优化 优化打包构建速度 oneOf babel缓存 多进程打包 externals dll 优化代码运行的性能 缓存(hash-chunkhash-contenthash) tree shaking code split 懒加载/预加载 pwa HMR HMR: hot module replacement 热模块替换 / 模块热替换作用：一个模块发生变化，只会重新打包这一个模块（而不是打包所有模块） ，极大提升构建速度。 样式文件：可以使用HMR功能：因为style-loader内部实现了~ js文件：默认不能使用HMR功能 –&gt; 需要修改js代码，添加支持HMR功能的代码。 注意：HMR功能对js的处理，只能处理非入口js文件的其他文件。 12345678if (module.hot) { // 一旦 module.hot 为true，说明开启了HMR功能。 --&gt; 让HMR功能代码生效 module.hot.accept('./print.js', function() { // 方法会监听 print.js 文件的变化，一旦发生变化，其他模块不会重新打包构建。 // 会执行后面的回调函数 print(); });} html文件: 默认不能使用HMR功能.同时会导致问题：html文件不能热更新了~ （不用做HMR功能） 解决：修改entry入口，将html文件引入-&gt;entry: [‘./src/js/index.js’, ‘./src/index.html’], devserver中加入hot即可： 123456789devServer: { contentBase: resolve(__dirname, 'build'), compress: true, port: 3000, open: true, // 开启HMR功能 // 当修改了webpack配置，新配置要想生效，必须重新webpack服务 hot: true} source-mapsource-map: 一种 提供源代码到构建后代码映射 技术 （如果构建后代码出错了，通过映射可以追踪源代码错误） 在module.exports中加入devtool: source-map 上为最基本写法，可以增加功能[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map ！ 内联 和 外部的区别：1. 外部生成了文件，内联没有 2. 内联构建速度更快 source-map：外部 错误代码准确信息 和 源代码的错误位置 inline-source-map：内联 只生成一个内联source-map 错误代码准确信息 和 源代码的错误位置 hidden-source-map：外部 错误代码错误原因，但是没有错误位置 不能追踪源代码错误，只能提示到构建后代码的错误位置 eval-source-map：内联 每一个文件都生成对应的source-map，都在eval 错误代码准确信息 和 源代码的错误位置 nosources-source-map：外部 错误代码准确信息, 但是没有任何源代码信息 cheap-source-map：外部 错误代码准确信息 和 源代码的错误位置 只能精确的行 cheap-module-source-map：外部 错误代码准确信息 和 源代码的错误位置 module会将loader的source map加入 种类这么多，至于如何使用： 开发环境：速度快，调试更友好 速度快(eval&gt;inline&gt;cheap&gt;…)eval-cheap-souce-map eval-source-map 调试更友好 souce-map cheap-module-souce-map cheap-souce-map –&gt; eval-source-map / eval-cheap-module-souce-map 生产环境：源代码要不要隐藏? 调试要不要更友好 内联会让代码体积变大，所以在生产环境不用内联 nosources-source-map 全部隐藏 hidden-source-map 只隐藏源代码，会提示构建后代码错误信息 –&gt; source-map / cheap-module-souce-map oneOfrules中的loader在执行时所有文件都会被匹配一次，使用oneof来使一个文件只被匹配一次： 注意：不能 两个配置处理同一种类型文件，所以可以把一些一定执行的放在oneof外部。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273rules: [ { // 在package.json中eslintConfig --&gt; airbnb test: /\\.js$/, exclude: /node_modules/, // 优先执行 enforce: 'pre', loader: 'eslint-loader', options: { fix: true } }, { // 以下loader只会匹配一个 // 注意：不能 两个配置处理同一种类型文件 oneOf: [ { test: /\\.css$/, use: [...commonCssLoader] }, { test: /\\.less$/, use: [...commonCssLoader, 'less-loader'] }, /* 正常来讲，一个文件只能被一个loader处理。 当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序： 先执行eslint 在执行babel */ { test: /\\.js$/, exclude: /node_modules/, loader: 'babel-loader', options: { presets: [ [ '@babel/preset-env', { useBuiltIns: 'usage', corejs: {version: 3}, targets: { chrome: '60', firefox: '50' } } ] ] } }, { test: /\\.(jpg|png|gif)/, loader: 'url-loader', options: { limit: 8 * 1024, name: '[hash:10].[ext]', outputPath: 'imgs', esModule: false } }, { test: /\\.html$/, loader: 'html-loader' }, { exclude: /\\.(js|css|less|html|jpg|png|gif)/, loader: 'file-loader', options: { outputPath: 'media' } } ] }] 缓存 babel缓存 cacheDirectory: true –&gt; 让第二次打包构建速度更快 1234567891011121314151617181920212223{ test: /\\.js$/, exclude: /node_modules/, loader: 'babel-loader', options: { presets: [ [ '@babel/preset-env', { useBuiltIns: 'usage', corejs: { version: 3 }, targets: { chrome: '60', firefox: '50' } } ] ], // 开启babel缓存 // 第二次构建时，会读取之前的缓存 cacheDirectory: true }} 文件资源缓存 hash: 每次wepack构建时会生成一个唯一的hash值。问题: 因为js和css同时使用一个hash值。如果重新打包，会导致所有缓存失效。（可能我却只改动一个文件） 12345678910111213{ test: /\\.(jpg|png|gif)/, loader: 'url-loader', options: { limit: 8 * 1024, name: '[hash:10].[ext]', outputPath: 'imgs', esModule: false }}new MiniCssExtractPlugin({ filename: 'css/built.[hash:10].css'}) chunkhash：根据chunk生成的hash值。如果打包来源于同一个chunk，那么hash值就一样。问题: js和css的hash值还是一样的因为css是在js中被引入的，所以同属于一个chunk。 chunk是指所有跟着index引入的文件最后会变成一个文件，一个chunk。 contenthash: 根据文件的内容生成hash值。不同文件hash值一定不一样–&gt; 让代码上线运行缓存更好使用 123new MiniCssExtractPlugin({ filename: 'css/built.[contenthash:10].css'}) 可以发现，如果修改css不修改js，则css缓存失效，js不失效。 tree shakingtree shaking：去除无用代码前提： 必须使用ES6模块化 开启production环境 作用: 减少代码体积 在package.json中配置 ： &quot;sideEffects&quot;: false:所有代码都没有副作用（都可以进行tree shaking) 问题：可能会把css / @babel/polyfill （副作用）文件干掉,可以&quot;sideEffects&quot;: [&quot;\\*.css&quot;, &quot;\\*.less&quot;]解决。 code split方案一假如我有两个如下名字的文件，直接在index.js中引入test.js的话，最后两个文件被打包成一个，可以使用如下方法: 123456789101112// 单入口// entry: './src/js/index.js',entry: { // 多入口：有一个入口，最终输出就有一个bundle index: './src/js/index.js', test: './src/js/test.js'},output: { // [name]：取文件名 filename: 'js/[name].[contenthash:10].js', path: resolve(__dirname, 'build')} 方案二123456789101112module.exports = { /* 1. 可以将node_modules中代码单独打包一个chunk最终输出 2. 自动分析多入口chunk中，有没有公共的文件。如果有会打包成单独一个chunk */ optimization: { splitChunks: { chunks: 'all' } }, mode: 'production'}; 方案三123456789101112131415/* 通过js代码，让某个文件被单独打包成一个chunk import动态导入语法：能将某个文件单独打包 默认使用chunkid命名，webpackChunkName指定打包后名字*/import(/* webpackChunkName: 'test' */'./test') .then(({ mul, count }) =&gt; { // 文件加载成功~ // eslint-disable-next-line console.log(mul(2, 5)); }) .catch(() =&gt; { // eslint-disable-next-line console.log('文件加载失败~'); }); lazy loading如下，不使用第一行引入方式而是第八行（也会像上面一样单独打包成一个chunk） 1234567891011// import { mul } from './test';document.getElementById('btn').onclick = function() { // 懒加载~：当文件需要使用时才加载~ // 预加载 prefetch：会在使用之前，提前加载js文件 // 正常加载可以认为是并行加载（同一时间加载多个文件） // 预加载 prefetch：等其他资源加载完毕，浏览器空闲了，再偷偷加载资源 import(/* webpackChunkName: 'test', webpackPrefetch: true */'./test').then(({ mul }) =&gt; { console.log(mul(4, 5)); });}; PWA PWA: 渐进式网络开发应用程序(离线可访问)workbox –&gt; workbox-webpack-plugin 安装:npm install --save-dev workbox-webpack-plugin 配置： 12345678910const WorkboxWebpackPlugin = require('workbox-webpack-plugin');new WorkboxWebpackPlugin.GenerateSW({ /* 1. 帮助serviceworker快速启动 2. 删除旧的 serviceworker 生成一个 serviceworker 配置文件~ */ clientsClaim: true, skipWaiting: true}) 在index.js注册 1234567891011121314// 注册serviceWorker// 处理兼容性问题if ('serviceWorker' in navigator) { window.addEventListener('load', () =&gt; { navigator.serviceWorker .register('/service-worker.js') .then(() =&gt; { console.log('sw注册成功了~'); }) .catch(() =&gt; { console.log('sw注册失败了~'); }); });} 问题： eslint不认识 window、navigator全局变量 解决：需要修改package.json中eslintConfig配置 “env”: { “browser”: true // 支持浏览器端全局变量 } sw代码必须运行在服务器上–&gt; nodejs–&gt;npm i serve -g serve -s build 启动服务器，将build目录下所有资源作为静态资源暴露出去 多进程打包npm install --save-dev thread-loader 1234567891011121314151617181920212223242526272829303132333435363738{ test: /\\.js$/, exclude: /node_modules/, use: [ /* 开启多进程打包。 进程启动大概为600ms，进程通信也有开销。 只有工作消耗时间比较长，才需要多进程打包 */ { loader: 'thread-loader', options: { workers: 2 // 进程2个 } }, { loader: 'babel-loader', options: { presets: [ [ '@babel/preset-env', { useBuiltIns: 'usage', corejs: { version: 3 }, targets: { chrome: '60', firefox: '50' } } ] ], // 开启babel缓存 // 第二次构建时，会读取之前的缓存 cacheDirectory: true } } ]} externals忽略需要打包的内容，此时需要cdn引入。 1234567891011121314151617181920const { resolve } = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = { entry: './src/js/index.js', output: { filename: 'js/built.js', path: resolve(__dirname, 'build') }, plugins: [ new HtmlWebpackPlugin({ template: './src/index.html' }) ], mode: 'production', externals: { // 拒绝jQuery被打包进来 jquery: 'jQuery' }}; dllwebpack.dll.js： 123456789101112131415161718192021222324252627282930/* 使用dll技术，对某些库（第三方库：jquery、react、vue...）进行单独打包 当你运行 webpack 时，默认查找 webpack.config.js 配置文件 需求：需要运行 webpack.dll.js 文件 --&gt; webpack --config webpack.dll.js*/const { resolve } = require('path');const webpack = require('webpack');module.exports = { entry: { // 最终打包生成的[name] --&gt; jquery // ['jquery'] --&gt; 要打包的库是jquery jquery: ['jquery'], }, output: { filename: '[name].js', path: resolve(__dirname, 'dll'), library: '[name]_[hash]' // 打包的库里面向外暴露出去的内容叫什么名字 }, plugins: [ // 打包生成一个 manifest.json --&gt; 提供和jquery映射 new webpack.DllPlugin({ name: '[name]_[hash]', // 映射库的暴露的内容名称 path: resolve(__dirname, 'dll/manifest.json') // 输出文件路径 }) ], mode: 'production'}; 单独打包后，上一节可以看出，其他文件正常打包后只需引入打包好的ddl即可，则webpack.config.js中配置： 12345678910111213141516const webpack = require('webpack');// 告诉webpack哪些库不参与打包，同时使用时的名称也得变~const AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin');plugins: [ new HtmlWebpackPlugin({ template: './src/index.html' }), // 告诉webpack哪些库不参与打包，同时使用时的名称也得变~ new webpack.DllReferencePlugin({ manifest: resolve(__dirname, 'dll/manifest.json') }), // 将某个文件打包输出去，并在html中自动引入该资源 new AddAssetHtmlWebpackPlugin({ filepath: resolve(__dirname, 'dll/jquery.js') })] webpack 配置详情entryentry: 入口起点 string –&gt; ‘./src/index.js’ 单入口，打包形成一个chunk。 输出一个bundle文件。此时chunk的名称默认是 main。 array –&gt; [‘./src/index.js’, ‘./src/add.js’] 多入口，所有入口文件最终只会形成一个chunk, 输出出去只有一个bundle文件。 只有在HMR功能中让html热更新生效~ object 多入口，有几个入口文件就形成几个chunk，输出几个bundle文件此时chunk的名称是 key(即下面的index、add)。 特殊用法 123456entry:{ // 所有入口文件最终只会形成一个chunk, 输出出去只有一个bundle文件。 index: ['./src/index.js', './src/count.js'], // 形成一个chunk，输出一个bundle文件。 add: './src/add.js'} output12345678910111213output: { // 文件名称（指定名称+目录） filename: 'js/[name].js', // 输出文件目录（将来所有资源输出的公共目录） path: resolve(__dirname, 'build'), // 所有资源引入公共路径前缀 --&gt; 'imgs/a.jpg' --&gt; '/imgs/a.jpg' publicPath: '/', chunkFilename: 'js/[name]_chunk.js', // 非入口chunk的名称 // library: '[name]', // 整个库向外暴露的变量名 // libraryTarget: 'window' // 变量名添加到哪个上 browser // libraryTarget: 'global' // 变量名添加到哪个上 node // libraryTarget: 'commonjs'} module12345678910111213141516171819202122232425262728module: { rules: [ // loader的配置 { test: /\\.css$/, // 多个loader用use use: ['style-loader', 'css-loader'] }, { test: /\\.js$/, // 排除node_modules下的js文件 exclude: /node_modules/, // 只检查 src 下的js文件 include: resolve(__dirname, 'src'), // 优先执行 enforce: 'pre', // 延后执行 // enforce: 'post', // 单个loader用loader loader: 'eslint-loader', options: {} }, { // 以下配置只会生效一个 oneOf: [] } ]}, resolve1234567891011// 解析模块的规则resolve: { // 配置解析模块路径别名: 优点简写路径 缺点路径没有提示 alias: { $css: resolve(__dirname, 'src/css') }, // 配置省略文件路径的后缀名 extensions: ['.js', '.json', '.jsx', '.css'], // 告诉 webpack 解析模块是去找哪个目录 modules: [resolve(__dirname, '../../node_modules'), 'node_modules']} devserve12345678910111213141516171819202122232425262728293031323334353637devServer: { // 运行代码的目录 contentBase: resolve(__dirname, 'build'), // 监视 contentBase 目录下的所有文件，一旦文件变化就会 reload watchContentBase: true, watchOptions: { // 忽略文件 ignored: /node_modules/ }, // 启动gzip压缩 compress: true, // 端口号 port: 5000, // 域名 host: 'localhost', // 自动打开浏览器 open: true, // 开启HMR功能 hot: true, // 不要显示启动服务器日志信息 clientLogLevel: 'none', // 除了一些基本启动信息以外，其他内容都不要显示 quiet: true, // 如果出错了，不要全屏提示~ overlay: false, // 服务器代理 --&gt; 解决开发环境跨域问题 proxy: { // 一旦devServer(5000)服务器接受到 /api/xxx 的请求，就会把请求转发到另外一个服务器(3000) '/api': { target: 'http://localhost:3000', // 发送请求时，请求路径重写：将 /api/xxx --&gt; /xxx （去掉/api） pathRewrite: { '^/api': '' } } }} optimization生产环境下才有意义。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748optimization: { splitChunks: { chunks: 'all' // 默认值，可以不写~ /* minSize: 30 * 1024, // 分割的chunk最小为30kb maxSiza: 0, // 最大没有限制 minChunks: 1, // 要提取的chunk最少被引用1次 maxAsyncRequests: 5, // 按需加载时并行加载的文件的最大数量 maxInitialRequests: 3, // 入口js文件最大并行请求数量 automaticNameDelimiter: '~', // 名称连接符 name: true, // 可以使用命名规则 cacheGroups: { // 分割chunk的组 // node_modules文件会被打包到 vendors 组的chunk中。--&gt; vendors~xxx.j // 满足上面的公共规则，如：大小超过30kb，至少被引用一次。 vendors: { test: /[\\\\/]node_modules[\\\\/]/, // 优先级 priority: -10 }, default: { // 要提取的chunk最少被引用2次 minChunks: 2, // 优先级 priority: -20, // 如果当前要打包的模块，和之前已经被提取的模块是同一个，就会复用 reuseExistingChunk: true } }*/ }, // 将当前模块的记录其他模块的hash单独打包为一个文件 runtime // 解决：修改a文件导致b文件的contenthash变化 runtimeChunk: { name: entrypoint =&gt; `runtime-${entrypoint.name}` }, minimizer: [ // 配置生产环境的压缩方案：js和css //默认使用Terser，一般不需要配置 new TerserWebpackPlugin({ // 开启缓存 cache: true, // 开启多进程打包 parallel: true, // 启动source-map sourceMap: true }) ]} Webpack 5此版本重点关注以下内容: 通过持久缓存提高构建性能. 使用更好的算法和默认值来改善长期缓存. 通过更好的树摇和代码生成来改善捆绑包大小. 清除处于怪异状态的内部结构，同时在 v4 中实现功能而不引入任何重大更改. 通过引入重大更改来为将来的功能做准备，以使我们能够尽可能长时间地使用 v5. 下载: npm i webpack@next webpack-cli -D 自动删除 Node.js Polyfills早期，webpack 的目标是允许在浏览器中运行大多数 node.js 模块，但是模块格局发生了变化，许多模块用途现在主要是为前端目的而编写的。webpack &lt;= 4 附带了许多 node.js 核心模块的 polyfill，一旦模块使用任何核心模块（即 crypto 模块），这些模块就会自动应用。 尽管这使使用为 node.js 编写的模块变得容易，但它会将这些巨大的 polyfill 添加到包中。在许多情况下，这些 polyfill 是不必要的。 webpack 5 会自动停止填充这些核心模块，并专注于与前端兼容的模块。 迁移： 尽可能尝试使用与前端兼容的模块。 可以为 node.js 核心模块手动添加一个 polyfill。错误消息将提示如何实现该目标。 Chunk 和模块 ID添加了用于长期缓存的新算法。在生产模式下默认情况下启用这些功能。 chunkIds: &quot;deterministic&quot;, moduleIds: &quot;deterministic&quot; Chunk ID你可以不用使用 import(/* webpackChunkName: &quot;name&quot; */ &quot;module&quot;) 在开发环境来为 chunk 命名，生产环境还是有必要的 webpack 内部有 chunk 命名规则，不再是以 id(0, 1, 2)命名了 Tree Shaking webpack 现在能够处理对嵌套模块的 tree shaking 1234567891011// inner.jsexport const a = 1;export const b = 2;// module.jsimport * as inner from './inner';export { inner };// user.jsimport * as module from './module';console.log(module.inner.a); 在生产环境中, inner 模块暴露的 b 会被删除 webpack 现在能够多个模块之前的关系 123456789import { something } from './something';function usingSomething() { return something;}export function test() { return usingSomething();} 当设置了&quot;sideEffects&quot;: false时，一旦发现test方法没有使用，不但删除test，还会删除&quot;./something&quot; webpack 现在能处理对 Commonjs 的 tree shaking Outputwebpack 4 默认只能输出 ES5 代码 webpack 5 开始新增一个属性 output.ecmaVersion, 可以生成 ES5 和 ES6 / ES2015 代码. 如：output.ecmaVersion: 2015 SplitChunk12// webpack4minSize: 30000; 12345// webpack5minSize: { javascript: 30000, style: 50000,} Caching123456789// 配置缓存cache: { // 磁盘存储 type: \"filesystem\", buildDependencies: { // 当配置修改时，缓存失效 config: [__filename] }} 缓存将存储到 node_modules/.cache/webpack 监视输出文件之前 webpack 总是在第一次构建时输出全部文件，但是监视重新构建时会只更新修改的文件。 此次更新在第一次构建时会找到输出文件看是否有变化，从而决定要不要输出全部文件。 默认值 entry: &quot;./src/index.js output.path: path.resolve(__dirname, &quot;dist&quot;) output.filename: &quot;[name].js&quot; 更多内容https://github.com/webpack/changelog-v5 模板加上了vue，使用时注意设置process.env.NODE_ENV。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124const { resolve } = require('path');const MiniCssExtractPlugin = require('mini-css-extract-plugin');const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');const VueLoaderPlugin = require('vue-loader/lib/plugin')// 定义nodejs环境变量：决定使用browserslist的哪个环境// process.env.NODE_ENV = 'production';// 复用loaderconst commonCssLoader = [ MiniCssExtractPlugin.loader, 'css-loader', { // 还需要在package.json中定义browserslist loader: 'postcss-loader', options: { ident: 'postcss', plugins: () =&gt; [require('postcss-preset-env')()] } }];module.exports = { entry: './src/js/index.js', output: { filename: 'js/bundle.js', path: resolve(__dirname, 'dist') }, module: { rules: [ { test: /\\.vue$/, loader: 'vue-loader' }, { test: /\\.css$/, use: [...commonCssLoader] }, { test: /\\.less$/, use: [...commonCssLoader, 'less-loader'] }, /* 正常来讲，一个文件只能被一个loader处理。 当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序： 先执行eslint 在执行babel */ { // 在package.json中eslintConfig --&gt; airbnb test: /\\.js$/, exclude: /node_modules/, // 优先执行 enforce: 'pre', loader: 'eslint-loader', options: { fix: true } }, { test: /\\.js$/, exclude: /node_modules/, loader: 'babel-loader', options: { presets: [ [ '@babel/preset-env', { useBuiltIns: 'usage', corejs: {version: 3}, targets: { chrome: '60', firefox: '50' } } ] ] } }, { test: /\\.(jpg|png|gif)/, loader: 'url-loader', options: { limit: 8 * 1024, name: '[hash:10].[ext]', outputPath: 'imgs', esModule: false } }, { test: /\\.html$/, loader: 'html-loader' }, { exclude: /\\.(js|css|less|html|jpg|png|gif)/, loader: 'file-loader', options: { outputPath: 'media' } } ] }, plugins: [ new VueLoaderPlugin(), new MiniCssExtractPlugin({ filename: 'css/built.css' }), new OptimizeCssAssetsWebpackPlugin(), new HtmlWebpackPlugin({ template: './src/index.html', minify: { collapseWhitespace: true, removeComments: true } }) ], mode: 'development', devServer: { contentBase: resolve(__dirname, 'build'), compress: true, port: 3000, open: true, }};","link":"/2020/05/16/%E5%A4%A7%E5%89%8D%E7%AB%AF/webpack/"},{"title":"Nginx","text":"Nginx 的产生Nginx 同 Apache 一样都是一种 Web 服务器。基于 REST 架构风格，以统一资源描述符（Uniform Resources Identifier）URI 或者统一资源定位符（Uniform Resources Locator）URL 作为沟通依据，通过 HTTP 协议提供各种网络服务。 然而，这些服务器在设计之初受到当时环境的局限，例如当时的用户规模，网络带宽，产品特点等局限并且各自的定位和发展都不尽相同。这也使得各个 Web 服务器有着各自鲜明的特点。 Apache 的发展时期很长，而且是毫无争议的世界第一大服务器。它有着很多优点：稳定、开源、跨平台等等。 它出现的时间太长了，它兴起的年代，互联网产业远远比不上现在。所以它被设计为一个重量级的。 它不支持高并发的服务器。在 Apache 上运行数以万计的并发访问，会导致服务器消耗大量内存。 操作系统对其进行进程或线程间的切换也消耗了大量的 CPU 资源，导致 HTTP 请求的平均响应速度降低。 这些都决定了 Apache 不可能成为高性能 Web 服务器，轻量级高并发服务器 Nginx 就应运而生了。 俄罗斯的工程师 Igor Sysoev，他在为 Rambler Media 工作期间，使用 C 语言开发了 Nginx。 Nginx 作为 Web 服务器一直为 Rambler Media 提供出色而又稳定的服务。然后呢，Igor Sysoev 将 Nginx 代码开源，并且赋予自由软件许可证。 由于以下这几点，所以，Nginx 火了： Nginx 使用基于事件驱动架构，使得其可以支持数以百万级别的 TCP 连接。 高度的模块化和自由软件许可证使得第三方模块层出不穷（这是个开源的时代啊）。 Nginx 是一个跨平台服务器，可以运行在 Linux、Windows、FreeBSD、Solaris、AIX、Mac OS 等操作系统上。 这些优秀的设计带来的极大的稳定性。 Nginx定义Nginx 是一款自由的、开源的、高性能的 HTTP 服务器和反向代理服务器；同时也是一个 IMAP、POP3、SMTP 代理服务器。 Nginx 可以作为一个 HTTP 服务器进行网站的发布处理，另外 Nginx 可以作为反向代理进行负载均衡的实现。 代理说到代理，首先我们要明确一个概念，所谓代理就是一个代表、一个渠道；此时就涉及到两个角色，一个是被代理角色，一个是目标角色。 被代理角色通过这个代理访问目标角色完成一些任务的过程称为代理操作过程；如同生活中的专卖店，客人到 adidas 专卖店买了一双鞋，这个专卖店就是代理，被代理角色就是 adidas 厂家，目标角色就是用户。 正向代理说反向代理之前，我们先看看正向代理，正向代理也是大家最常接触到的代理模式，我们会从两个方面来说关于正向代理的处理模式，分别从软件方面和生活方面来解释一下什么叫正向代理。 在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的。 此时大家可能都会用一个操作 FQ 进行访问，FQ 的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！ 上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。 来看个示意图： 客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的 IP 地址，还有代理程序的端口。 总结来说：正向代理，”它代理的是客户端”，是一个位于客户端和原始服务器（Origin Server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器）。 然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。 正向代理的用途： 访问原来无法访问的资源，如 Google。 可以做缓存，加速访问资源。 对客户端访问授权，上网进行认证。 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息。 反向代理明白了什么是正向代理，我们继续看关于反向代理的处理方式，举例如我国的某宝网站，每天同时连接到网站的访问人数已经爆表，单个服务器远远不能满足人民日益增长的购买欲望了。 此时就出现了一个大家耳熟能详的名词：分布式部署；也就是通过部署多台服务器来解决访问人数限制的问题。 某宝网站中大部分功能也是直接使用 Nginx 进行反向代理实现的，并且通过封装 Nginx 和其他的组件之后起了个高大上的名字：Tengine。 有兴趣的童鞋可以访问 Tengine 的官网查看具体的信息： 1http://tengine.taobao.org/ 那么反向代理具体是通过什么样的方式实现的分布式的集群操作呢，我们先看一个示意图： 通过上述的图解就可以看清楚了，多个客户端给服务器发送的请求，Nginx 服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。 此时请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx 扮演的就是一个反向代理角色。 客户端是无感知代理的存在的，反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。因为客户端不需要任何配置就可以访问。 反向代理，”它代理的是服务端”，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。 反向代理的作用： 保证内网的安全，通常将反向代理作为公网访问地址，Web 服务器是内网。 负载均衡，通过反向代理服务器来优化网站的负载。 项目场景通常情况下，我们在实际项目操作时，正向代理和反向代理很有可能会存在同一个应用场景中，正向代理代理客户端的请求去访问目标服务器，目标服务器是一个反向代理服务器，反向代理了多台真实的业务处理服务器。 具体的拓扑图如下： 截了一张图来说明正向代理和反向代理二者之间的区别，如下图： 图解： 在正向代理中，Proxy 和 Client 同属于一个 LAN（图中方框内），隐藏了客户端信息。 在反向代理中，Proxy 和 Server 同属于一个 LAN（图中方框内），隐藏了服务端信息。 实际上，Proxy 在两种代理中做的事情都是替服务器代为收发请求和响应，不过从结构上看正好左右互换了一下，所以把后出现的那种代理方式称为反向代理了。 负载均衡我们已经明确了所谓代理服务器的概念，那么接下来，Nginx 扮演了反向代理服务器的角色，它是依据什么样的规则进行请求分发的呢？不用的项目应用场景，分发的规则是否可以控制呢？ 这里提到的客户端发送的、Nginx 反向代理服务器接收到的请求数量，就是我们说的负载量。 请求数量按照一定的规则进行分发，到不同的服务器处理的规则，就是一种均衡规则。 所以将服务器接收到的请求按照规则分发的过程，称为负载均衡。 负载均衡在实际项目操作过程中，有硬件负载均衡和软件负载均衡两种，硬件负载均衡也称为硬负载，如 F5 负载均衡，相对造价昂贵成本较高。 但是数据的稳定性安全性等等有非常好的保障，如中国移动中国联通这样的公司才会选择硬负载进行操作。 更多的公司考虑到成本原因，会选择使用软件负载均衡，软件负载均衡是利用现有的技术结合主机硬件实现的一种消息队列分发机制。 Nginx 支持的负载均衡调度算法方式如下： ①weight 轮询（默认）：接收到的请求按照顺序逐一分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx 会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。 这种方式下，可以给不同的后端服务器设置一个权重值（weight），用于调整不同的服务器上请求的分配率。 权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。 ②ip_hash：每个请求按照发起客户端的 ip 的 hash 结果进行匹配，这样的算法下一个固定 ip 地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下 Session 共享的问题。 ③fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配。 响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少，它是结合了前两者的优点的一种调度算法。 但是需要注意的是 Nginx 默认不支持 fair 算法，如果要使用这种调度算法，请安装 upstream_fair 模块。 ④url_hash：按照访问的 URL 的 hash 结果分配请求，每个请求的 URL 会指向后端固定的某个服务器，可以在 Nginx 作为静态服务器的情况下提高缓存效率。 同样要注意 Nginx 默认不支持这种调度算法，要使用的话需要安装 Nginx 的 hash 软件包。 Web 服务器对比几种常用 Web 服务器对比如下图： nginx 服务架构 nginx 服务器的开发完全遵循模块化设计思想 模块化开发 单一职责原则，一个模块只负责一个功能 将程序分解，自顶向下，逐步求精 高内聚，低耦合 nginx 的模块化结构 核心模块：nginx 最基本最核心的服务，如进程管理、权限控制、日志记录； 标准 HTTP 模块：nginx 服务器的标准 HTTP 功能； 可选 HTTP 模块：处理特殊的 HTTP 请求 邮件服务模块：邮件服务 第三方模块：作为扩展，完成特殊功能 nginx 的模块清单 核心模块 ngx_core ngx_errlog ngx_conf ngx_events ngx_event_core ngx_epll ngx_regex 标准 HTTP 模块 ngx_http ngx_http_core #配置端口，URI 分析，服务器相应错误处理，别名控制 (alias) 等 ngx_http_log #自定义 access 日志 ngx_http_upstream #定义一组服务器，可以接受来自 proxy, Fastcgi,Memcache 的重定向；主要用作负载均衡 ngx_http_static ngx_http_autoindex #自动生成目录列表 ngx_http_index #处理以/结尾的请求，如果没有找到 index 页，则看是否开启了random_index；如开启，则用之，否则用 autoindex ngx_http_auth_basic #基于 http 的身份认证 (auth_basic) ngx_http_access #基于 IP 地址的访问控制 (deny,allow) ngx_http_limit_conn #限制来自客户端的连接的响应和处理速率 ngx_http_limit_req #限制来自客户端的请求的响应和处理速率 ngx_http_geo ngx_http_map #创建任意的键值对变量 ngx_http_split_clients ngx_http_referer #过滤 HTTP 头中 Referer 为空的对象 ngx_http_rewrite #通过正则表达式重定向请求 ngx_http_proxy ngx_http_fastcgi #支持 fastcgi ngx_http_uwsgi ngx_http_scgi ngx_http_memcached ngx_http_empty_gif #从内存创建一个 1×1 的透明 gif 图片，可以快速调用 ngx_http_browser #解析 http 请求头部的 User-Agent 值 ngx_http_charset #指定网页编码 ngx_http_upstream_ip_hash ngx_http_upstream_least_conn ngx_http_upstream_keepalive ngx_http_write_filter ngx_http_header_filter ngx_http_chunked_filter ngx_http_range_header ngx_http_gzip_filter ngx_http_postpone_filter ngx_http_ssi_filter ngx_http_charset_filter ngx_http_userid_filter ngx_http_headers_filter #设置 http 响应头 ngx_http_copy_filter ngx_http_range_body_filter ngx_http_not_modified_filter 可选 HTTP 模块 ngx_http_addition #在响应请求的页面开始或者结尾添加文本信息 ngx_http_degradation #在低内存的情况下允许服务器返回 444 或者 204 错误 ngx_http_perl ngx_http_flv #支持将 Flash 多媒体信息按照流文件传输，可以根据客户端指定的开始位置返回 Flash ngx_http_geoip #支持解析基于 GeoIP 数据库的客户端请求 ngx_google_perftools ngx_http_gzip #gzip 压缩请求的响应 ngx_http_gzip_static #搜索并使用预压缩的以.gz 为后缀的文件代替一般文件响应客户端请求 ngx_http_image_filter #支持改变 png，jpeg，gif 图片的尺寸和旋转方向 ngx_http_mp4 #支持.mp4,.m4v,.m4a 等多媒体信息按照流文件传输，常与 ngx_http_flv 一起使用 ngx_http_random_index #当收到 / 结尾的请求时，在指定目录下随机选择一个文件作为 index ngx_http_secure_link #支持对请求链接的有效性检查 ngx_http_ssl #支持 https ngx_http_stub_status ngx_http_sub_module #使用指定的字符串替换响应中的信息 ngx_http_dav #支持 HTTP 和 WebDAV 协议中的 PUT/DELETE/MKCOL/COPY/MOVE 方法 ngx_http_xslt #将 XML 响应信息使用 XSLT 进行转换 邮件服务模块 ngx_mail_core ngx_mail_pop3 ngx_mail_imap ngx_mail_smtp ngx_mail_auth_http ngx_mail_proxy ngx_mail_ssl 第三方模块 echo-nginx-module #支持在 nginx 配置文件中使用 echo/sleep/time/exec 等类 Shell 命令 memc-nginx-module rds-json-nginx-module #使 nginx 支持 json 数据的处理 lua-nginx-module nginx 的 web 请求处理机制作为服务器软件，必须具备并行处理多个客户端的请求的能力， 工作方式主要以下 3 种： 多进程 (Apache) 优点：设计和实现简单；子进程独立 缺点：生成一个子进程要内存复制，在资源和时间上造成额外开销 多线程 (IIS) 优点：开销小 缺点：开发者自己要对内存进行管理；线程之间会相互影响 异步方式 (nginx) 经常说道异步非阻塞这个概念， 包含两层含义： 通信模式： + 同步：发送方发送完请求后，等待并接受对方的回应后，再发送下个请求 + 异步：发送方发送完请求后，不必等待，直接发送下个请求 配置文件实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#定义 nginx 运行的用户和用户组user www www;#nginx 进程数，建议设置为等于 CPU 总核心数。worker_processes 8;#nginx 默认没有开启利用多核 CPU, 通过增加 worker_cpu_affinity 配置参数来充分利用多核 CPU 以下是 8 核的配置参数worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]error_log /var/log/nginx/error.log info;#进程文件pid /var/run/nginx.pid;#一个 nginx 进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值 ulimit -n）与 nginx 进程数相除，但是 nginx 分配请求并不均匀，所以建议与 ulimit -n 的值保持一致。worker_rlimit_nofile 65535;#工作模式与连接数上限events{ #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll 模型是 Linux 2.6 以上版本内核中的高性能网络 I/O 模型，如果跑在 FreeBSD 上面，就用 kqueue 模型。 #epoll 是多路复用 IO(I/O Multiplexing) 中的一种方式，但是仅用于 linux2.6 以上内核，可以大大提高 nginx 的性能 use epoll; ############################################################################ #单个后台 worker process 进程的最大并发链接数 #事件模块指令，定义 nginx 每个进程最大连接数，默认 1024。最大客户连接数由 worker_processes 和 worker_connections 决定 #即 max_client=worker_processes*worker_connections, 在作为反向代理时：max_client=worker_processes*worker_connections / 4 worker_connections 65535; ############################################################################}#设定 http 服务器http { include mime.types; #文件扩展名与文件类型映射表 default_type application/octet-stream; #默认文件类型 #charset utf-8; #默认编码 server_names_hash_bucket_size 128; #服务器名字的 hash 表大小 client_header_buffer_size 32k; #上传文件大小限制 large_client_header_buffers 4 64k; #设定请求缓 client_max_body_size 8m; #设定请求缓 sendfile on; #开启高效文件传输模式，sendfile 指令指定 nginx 是否调用 sendfile 函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘 IO 重负载应用，可设置为 off，以平衡磁盘与网络 I/O 处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成 off。 autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。 tcp_nopush on; #防止网络阻塞 tcp_nodelay on; #防止网络阻塞 ##连接客户端超时时间各种参数设置## keepalive_timeout 120; #单位是秒，客户端连接时时间，超时之后服务器端自动关闭该连接 如果 nginx 守护进程在这个等待的时间里，一直没有收到浏览发过来 http 请求，则关闭这个 http 连接 client_header_timeout 10; #客户端请求头的超时时间 client_body_timeout 10; #客户端请求主体超时时间 reset_timedout_connection on; #告诉 nginx 关闭不响应的客户端连接。这将会释放那个客户端所占有的内存空间 send_timeout 10; #客户端响应超时时间，在两次客户端读取操作之间。如果在这段时间内，客户端没有读取任何数据，nginx 就会关闭连接 ################################ #FastCGI 相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。 fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; ###作为代理缓存服务器设置####### ###先写到 temp 再移动到 cache #proxy_cache_path /var/tmp/nginx/proxy_cache levels=1:2 keys_zone=cache_one:512m inactive=10m max_size=64m; ###以上 proxy_temp 和 proxy_cache 需要在同一个分区中 ###levels=1:2 表示缓存级别，表示缓存目录的第一级目录是 1 个字符，第二级目录是 2 个字符 keys_zone=cache_one:128m 缓存空间起名为 cache_one 大小为 512m ###max_size=64m 表示单个文件超过 128m 就不缓存了 inactive=10m 表示缓存的数据，10 分钟内没有被访问过就删除 #########end#################### #####对传输文件压缩########### #gzip 模块设置 gzip on; #开启 gzip 压缩输出 gzip_min_length 1k; #最小压缩文件大小 gzip_buffers 4 16k; #压缩缓冲区 gzip_http_version 1.0; #压缩版本（默认 1.1，前端如果是 squid2.5 请使用 1.0） gzip_comp_level 2; #压缩等级，gzip 压缩比，1 为最小，处理最快；9 为压缩比最大，处理最慢，传输速度最快，也最消耗 CPU； gzip_types text/plain application/x-javascript text/css application/xml; #压缩类型，默认就已经包含 text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个 warn。 gzip_vary on; ############################## #limit_zone crawler $binary_remote_addr 10m; #开启限制 IP 连接数的时候需要使用 upstream blog.ha97.com { #upstream 的负载均衡，weight 是权重，可以根据机器配置定义权重。weigth 参数表示权值，权值越高被分配到的几率越大。 server 192.168.80.121:80 weight=3; server 192.168.80.122:80 weight=2; server 192.168.80.123:80 weight=3; } #虚拟主机的配置 server { #监听端口 listen 80; #############https################## #listen 443 ssl; #ssl_certificate /opt/https/xxxxxx.crt; #ssl_certificate_key /opt/https/xxxxxx.key; #ssl_protocols SSLv3 TLSv1; #ssl_ciphers HIGH:!ADH:!EXPORT57:RC4+RSA:+MEDIUM; #ssl_prefer_server_ciphers on; #ssl_session_cache shared:SSL:2m; #ssl_session_timeout 5m; ####################################end #域名可以有多个，用空格隔开 server_name www.ha97.com ha97.com; index index.html index.htm index.php; root /data/www/ha97; location ~ .*.(php|php5)?$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; } #图片缓存时间设置 location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$ { expires 10d; } #JS 和 CSS 缓存时间设置 location ~ .*.(js|css)?$ { expires 1h; } #日志格式设定 log_format access '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" $http_x_forwarded_for'; #定义本虚拟主机的访问日志 access_log /var/log/nginx/ha97access.log access; #对 \"/\" 启用反向代理 location / { proxy_pass http://127.0.0.1:88; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; #后端的 Web 服务器可以通过 X-Forwarded-For 获取用户真实 IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #以下是一些反向代理的配置，可选。 proxy_set_header Host $host; client_max_body_size 10m; #允许客户端请求的最大单文件字节数 client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数， ##代理设置 以下设置是 nginx 和后端服务器之间通讯的设置## proxy_connect_timeout 90; #nginx 跟后端服务器连接超时时间（代理连接超时） proxy_send_timeout 90; #后端服务器数据回传时间（代理发送超时） proxy_read_timeout 90; #连接成功后，后端服务器响应时间（代理接收超时） proxy_buffering on; #该指令开启从后端被代理服务器的响应内容缓冲 此参数开启后 proxy_buffers 和 proxy_busy_buffers_size 参数才会起作用 proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffers 4 32k; #proxy_buffers 缓冲区，网页平均在 32k 以下的设置 proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2） proxy_max_temp_file_size 2048m; #默认 1024m, 该指令用于设置当网页内容大于 proxy_buffers 时，临时文件大小的最大值。如果文件大于这个值，它将从 upstream 服务器同步地传递请求，而不是缓冲到磁盘 proxy_temp_file_write_size 512k; 这是当被代理服务器的响应过大时 nginx 一次性写入临时文件的数据量。 proxy_temp_path /var/tmp/nginx/proxy_temp; ##定义缓冲存储目录，之前必须要先手动创建此目录 proxy_headers_hash_max_size 51200; proxy_headers_hash_bucket_size 6400; ####################################################### } #设定查看 nginx 状态的地址 location /nginxStatus { stub_status on; access_log on; auth_basic \"nginxStatus\"; auth_basic_user_file conf/htpasswd; #htpasswd 文件的内容可以用 apache 提供的 htpasswd 工具来产生。 } #本地动静分离反向代理配置 #所有 jsp 的页面均交由 tomcat 或 resin 处理 location ~ .(jsp|jspx|do)?$ { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; } #所有静态文件由 nginx 直接读取不经过 tomcat 或 resin location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$ { expires 15d; } location ~ .*.(js|css)?$ { expires 1h; } }} nginx 服务器基础配置指令nginx.conf 文件的结构 Global: nginx 运行相关 events: 与用户的网络连接相关 http http Global: 代理，缓存，日志，以及第三方模块的配置 server server Global: 虚拟主机相关 location: 地址定向，数据缓存，应答控制，以及第三方模块的配置 所有的所有的所有的指令，都要以;结尾 nginx 运行相关的 Global 部分配置运行 nginx 服务器用户user nobody nobody; 配置允许生成的 worker process 数worker_processes auto; worker_processes 4; 这个数字，跟电脑 CPU 核数要保持一致 12345678# grep ^proces /proc/cpuinfoprocessor : 0processor : 1processor : 2processor : 3# grep ^proces /proc/cpuinfo | wc -l4复制代码 配置 nginx 进程 PID 存放路径pid logs/nginx.pid; 这里面保存的就是一个数字，nginx master 进程的进程号 配置错误日志的存放路径error_log logs/error.log; error_log logs/error.log error; 配置文件的引入include mime.types; include fastcgi_params; include ../../conf/*.conf; 与用户的网络连接相关的 events设置网络连接的序列化accept_mutex on; 对多个 nginx 进程接收连接进行序列化，防止多个进程对连接的争抢（惊群） 设置是否允许同时接收多个网络连接multi_accept off; 事件驱动模型的选择use select|poll|kqueue|epoll|rtsig|/dev/poll|eventport 这个重点，后面再看 配置最大连接数worker_connections 512; httphttp Global 代理 - 缓存 - 日志 - 第三方模块配置定义 MIME-Typeinclude mime.types; default_type application/octet-stream; 自定义服务日志access_log logs/access.log main; access_log off; 配置允许 sendfile 方式传输文件sendfile off; sendfile on; sendfile_max_chunk 128k; nginx 每个 worker process 每次调用 sendfile() 传输的数据量的最大值 Refer: Linux kenel sendfile 如何提升性能 nginx sendifle tcp_nopush tcp_nodelay 参数解释 配置连接超时时间 与用户建立连接后，nginx 可以保持这些连接一段时间，默认 75s 下面的 65s 可以被 Mozilla/Konqueror 识别，是发给用户端的头部信息Keep-Alive值 keepalive_timeout 75s 65s; 单连接请求数上限 和用户端建立连接后，用户通过此连接发送请求；这条指令用于设置请求的上限数 keepalive_requests 100; server配置网络监听listen *:80 | *:8000; # 监听所有的 80 和 8000 端口 listen 192.168.1.10:8000; listen 192.168.1.10; listen 8000; # 等同于 listen *:8000; listen 192.168.1.10 default_server backlog=511; # 该 ip 的连接请求默认由此虚拟主机处理；最多允许 1024 个网络连接同时处于挂起状态 基于名称的虚拟主机配置server_name myserver.com www.myserver.com; server_name .myserver.com www.myserver. myserver2.*; # 使用通配符 不允许的情况： server_name www.ab*d.com; # *只允许出现在 www 和 com 的位置 server_name ~^www\\d+.myserver.com$; # 使用正则 nginx 的配置中，可以用正则的地方，都以~开头 from nginx~0.7.40 开始，server_name 中的正则支持 字符串捕获功能（capture） server_name ~^www.(.+).com$; # 当请求通过 www.myserver.com 请求时， myserver 就被记录到$1中，在本 server 的上下文中就可以使用 如果一个名称 被多个虚拟主机的 server_name 匹配成功，那这个请求到底交给谁处理呢？看优先级： 准确匹配到 server_name 通配符在开始时匹配到 server_name 通配符在结尾时匹配到 server_name 正则表达式匹配 server_name 先到先得 配置 https 证书原理 https 是在 http 和 TCP 中间加上一层加密层 浏览器向服务端发送消息时：本质上是浏览器（客户端）使用服务端的公钥来加密信息，服务端使用自己的私钥解密， 浏览器从服务端获取消息是：服务端使用自己私钥加密，浏览器（客户端）使用服务端的公钥来解密信息 在这个过程中，需要保证服务端给浏览器的公钥不是假冒的。证明服务端公钥信息的机构是 CA（数字认证中心） 可以理解为：如果想证明一个人的身份是真的，就得证明这个人的身份证是真的 数字证书 1234数字证书相当于物理世界中的身份证，在网络中传递信息的双方互相不能见面，利用数字证书可确认双方身份，而不是他人冒充的。这个数字证书由信任的第三方，即认证中心使用自己的私钥对 A 的公钥加密，加密后文件就是网络上的身份证了，即数字证书复制代码 大致可以理解为如下 12345678910111213141516171819202122231. 服务端将自己的公钥和其他信息（服务端数字证书），请求数字认证中心签名，数字认证中心使用自己的私钥在证书里加密（只有数字认证中心的公钥才能解开）2. 服务端将自己的证书（证书里面包括服务端的公钥）给浏览器3. 浏览器的“证书管理器”中有“受信任的根证书颁发机构”列表，客户端在接收到响应后，会在这个列表里查看是否存在解开该服务器数字证书的公钥。有两种错误情况：如果公钥在这个列表里，但是解码后的内容不匹配，说明证书被冒用；如果公钥不在这个列表里，说明这张证书不是受信任的机构所颁发，他的真实性无法确定4. 如果一切都没问题，浏览器就可以使用服务器的公钥对信息内容进行加密，然后与服务器交换信息（已加密）+--------------+ +------------------+| 服务端 |----------&gt;| 数字认证中心 (CA) |+------+-------+ 1 X +------------------+ | / / | / / | / / | / / |2 3 / / 4 | / / | / / | / / X / /+--------------+ /| 浏览器 |X+--------------+只要证书（证书里有服务端的公钥）是可信的，公钥就是可信的。复制代码 证书格式 Linux 下的工具们通常使用 base64 编码的文本格式，相关常用后缀如下 证书 .crt .pem .cer(IIS 等一些平台下，则习惯用 cer 作为证书文件的扩展名，二进制证书） 私钥：.key 证书请求：.csr 其他 .keystore java 密钥库（包括证书和私钥） 制作证书 123456789101112131415161718192021221. 生成服务器端的私钥 (key 文件）$openssl genrsa -out server.key 10242. 生成服务器端证书签名请求文件 (csr 文件）;$ openssl req -new -key server.key -out server.csr...Country Name:CN------------ 证书持有者所在国家State or Province Name:BJ-- 证书持有者所在州或省份（可省略不填）Locality Name:BJ----------- 证书持有者所在城市（可省略不填）Organization Name:SC------- 证书持有者所属组织或公司Organizational Unit Name:.- 证书持有者所属部门（可省略不填）Common Name :ceshi.com----- 域名Email Address:------------- 邮箱（可省略不填）A challenge password:------ 直接回车An optional company name:-- 直接回车3. 生成证书文件 (crt 文件）$ openssl x509 -req -days 1000 -in server.csr -signkey server.key -out server.crt复制代码 以上生成 server.crt server.key 文件即是用于 HTTPS 配置的证书和 key 如果想查看证书里面的内容，可以通过 $openssl x509 -in server.crt -text -noout 查看 配置 nginx 在 nginx 的 server 区域内添加如下 123456789listen 443 ssl;ssl_certificate /opt/https/server.crt;ssl_certificate_key /opt/https/server.key;ssl_protocols SSLv3 TLSv1;ssl_ciphers HIGH:!ADH:!EXPORT57:RC4+RSA:+MEDIUM;ssl_prefer_server_ciphers on;ssl_session_cache shared:SSL:2m;ssl_session_timeout 5m;复制代码 基于 IP 的虚拟主机配置 基于 IP 的虚拟主机，需要将网卡设置为同时能够监听多个 IP 地址 1234567891011ifconfig# 查看到本机 IP 地址为 192.168.1.30ifconfig eth1:0 192.168.1.31 netmask 255.255.255.0 upifconfig eth1:1 192.168.1.32 netmask 255.255.255.0 upifconfig# 这时就看到 eth1 增加来 2 个别名， eth1:0 eth1:1# 如果需要机器重启后仍保持这两个虚拟的 IPecho \"ifconfig eth1:0 192.168.1.31 netmask 255.255.255.0 up\" &gt;&gt; /etc/rc.localecho \"ifconfig eth1:0 192.168.1.32 netmask 255.255.255.0 up\" &gt;&gt; /etc/rc.local复制代码 再来配置基于 IP 的虚拟主机 1234567891011121314http { ... server { listen 80; server_name 192.168.1.31; ... } server { listen 80; server_name 192.168.1.32; ... }}复制代码 配置 location 块 location 块的配置，应该是最常用的了 location [ = | ~ | * | ^ ] uri {…} 这里内容分 2 块，匹配方式和 uri， 其中 uri 又分为 标准 uri 和正则 uri 先不考虑 那 4 种匹配方式 nginx 首先会再 server 块的多个 location 中搜索是否有标准 uri和请求字符串匹配， 如果有，记录匹配度最高的一个； 然后，再用 location 块中的正则 uri和请求字符串匹配， 当第一个正则 uri匹配成功，即停止搜索， 并使用该 location 块处理请求； 如果，所有的正则 uri都匹配失败，就使用刚记录下的匹配度最高的一个标准 uri处理请求 如果都失败了，那就失败喽 再看 4 种匹配方式： =: 用于标准 uri前，要求请求字符串与其严格匹配，成功则立即处理 ^~: 用于标准 uri前，并要求一旦匹配到，立即处理，不再去匹配其他的那些个正则 uri ~: 用于正则 uri前，表示 uri 包含正则表达式， 并区分大小写 ~*: 用于正则 uri前， 表示 uri 包含正则表达式， 不区分大小写 1^~` 也是支持浏览器编码过的 URI 的匹配的哦， 如 `/html/%20/data` 可以成功匹配 `/html/ /data [root] 配置请求的根目录Web 服务器收到请求后，首先要在服务端指定的目录中寻找请求资源 12root /var/www;复制代码 root 后跟的指定目录是上级目录 该上级目录下要含有和 location 后指定名称的同名目录才行，末尾“/”加不加无所谓 1234location /c/ { root /a/}复制代码 访问站点 http://location/c 访问的就是 /a/c 目录下的站点信息。 [alias] 更改 location 的 URI除了使用 root 指明处理请求的根目录，还可以使用 alias 改变 location 收到的 URI 的请求路径 1234location ~ ^/data/(.+\\.(htm|html))$ { alias /locatinotest1/other/$1;}复制代码 alias 后跟的指定目录是准确的，并且末尾必须加“/”，否则找不到文件 1234location /c/ { alias /a/}复制代码 访问站点 http://location/c 访问的就是 /a/ 目录下的站点信息。 【注】一般情况下，在 location / 中配置 root，在 location /other 中配置 alias 是一个好习惯。 设置网站的默认首页index 指令主要有 2 个作用： 对请求地址没有指明首页的，指定默认首页 对一个请求，根据请求内容而设置不同的首页，如下： 1234location ~ ^/data/(.+)/web/$ { index index.$1.html index.htm;}复制代码 设置网站的错误页面error_page 404 /404.html; error_page 403 /forbidden.html; error_page 404 =301 /404.html; 1234location /404.html { root /myserver/errorpages/;}复制代码 基于 IP 配置 nginx 的访问权限1234567location / { deny 192.168.1.1; allow 192.168.1.0/24; allow 192.168.1.2/24; deny all;}复制代码 从 192.168.1.0 的用户时可以访问的，因为解析到 allow 那一行之后就停止解析了 基于密码配置 nginx 的访问权限auth_basic “please login”; auth_basic_user_file /etc/nginx/conf/pass_file; 这里的 file 必须使用绝对路径，使用相对路径无效 123456# /usr/local/apache2/bin/htpasswd -c -d pass_file user_name# 回车输入密码，-c 表示生成文件，-d 是以 crypt 加密。name1:password1name2:password2:comment复制代码 经过 basic auth 认证之后没有过期时间，直到该页面关闭； 如果需要更多的控制，可以使用 HttpAuthDigestModule wiki.nginx.org/HttpAuthDig… 应用架设简单文件服务器将 /data/public/ 目录下的文件通过 nginx 提供给外部访问 123456789101112131415161718192021#mkdir /data/public/#chmod 777 /data/public/复制代码worker_processes 1;error_log logs/error.log info;events { use epoll;}http { server { # 监听 8080 端口 listen 8080; location /share/ { # 打开自动列表功能，通常关闭 autoindex on; # 将 /share/ 路径映射至 /data/public/，请保证 nginx 进程有权限访问 /data/public/ alias /data/public/; } }}复制代码 nginx 正向代理 正向代理指代理客户端访问服务器的一个中介服务器，代理的对象是客户端。正向代理就是代理服务器替客户端去访问目标服务器 反向代理指代理后端服务器响应客户端请求的一个中介服务器，代理的对象是服务器。 配置 代理服务器配置 nginx.conf 12345678910server{ resolver x.x.x.x;# resolver 8.8.8.8; listen 82; location / { proxy_pass http://$http_host$request_uri; } access_log /data/httplogs/proxy-$host-aceess.log;}复制代码 location 保持原样即可，根据自己的配置更改 listen port 和 dnf 即 resolver 验证： 在需要访问外网的机器上执行以下操作之一即可： 12341. export http_proxy=http://yourproxyaddress：proxyport（建议）2. vim ~/.bashrc export http_proxy=http://yourproxyaddress：proxyport复制代码 2 不足 nginx 不支持 CONNECT 方法，不像我们平时用的 GET 或者 POST，可以选用 apache 或 squid 作为代替方案。 nginx 服务器基础配置实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788user nginx nginx;worker_processes 3;error_log logs/error.log;pid myweb/nginx.pid;events { use epoll; worker_connections 1024;}http { include mime.types; default_type applicatioin/octet-stream; sendfile on; keepalive_timeout 65; log_format access.log '$remote_addr [$time_local] \"$request\" \"$http_user_agent\"'; server { listen 8081; server_name myServer1; access_log myweb/server1/log/access.log; error_page 404 /404.html; location /server1/location1 { root myweb; index index.svr1-loc1.htm; } location /server1/location2 { root myweb; index index.svr1-loc2.htm; } } server { listen 8082; server_name 192.168.0.254; auth_basic \"please Login:\"; auth_basic_user_file /opt/X_nginx/nginx/myweb/user_passwd; access_log myweb/server2/log/access.log; error_page 404 /404.html; location /server2/location1 { root myweb; index index.svr2-loc1.htm; } location /svr2/loc2 { alias myweb/server2/location2/; index index.svr2-loc2.htm; } location = /404.html { root myweb/; index 404.html; } }}复制代码#./sbin/nginx -c conf/nginx02.confnginx: [warn] the \"user\" directive makes sense only if the master process runs with super-user privileges, ignored in /opt/X_nginx/nginx/conf/nginx02.conf:1.├── 404.html├── server1│ ├── location1│ │ └── index.svr1-loc1.htm│ ├── location2│ │ └── index.svr1-loc2.htm│ └── log│ └── access.log└── server2 ├── location1 │ └── index.svr2-loc1.htm ├── location2 │ └── index.svr2-loc2.htm └── log └── access.log8 directories, 7 files复制代码 测试 myServer1 的访问123456http://myserver1:8081/server1/location1/this is server1/location1/index.svr1-loc1.htmhttp://myserver1:8081/server1/location2/this is server1/location1/index.svr1-loc2.htm复制代码 测试 myServer2 的访问123456789http://192.168.0.254:8082/server2/location1/this is server2/location1/index.svr2-loc1.htmhttp://192.168.0.254:8082/svr2/loc2/this is server2/location1/index.svr2-loc2.htmhttp://192.168.0.254:8082/server2/location2/404 404 404 404复制代码 使用缓存创建缓存目录 123mkdir /tmp/nginx_proxy_cache2chmod 777 /tmp/nginx_proxy_cache2复制代码 修改配置文件 12345678910111213141516# http 区域下添加缓存区配置proxy_cache_path /tmp/nginx_proxy_cache2 levels=1 keys_zone=cache_one:512m inactive=60s max_size=1000m;# server 区域下添加缓存配置#缓存相应的文件（静态文件）location ~ \\.(gif|jpg|png|htm|html|css|js|flv|ico|swf)(.*) { proxy_pass http://IP: 端口；#如果没有缓存则通过 proxy_pass 转向请求 proxy_redirect off; proxy_set_header Host $host; proxy_cache cache_one; proxy_cache_valid 200 302 1h; #对不同的 HTTP 状态码设置不同的缓存时间，h 小时，d 天数 proxy_cache_valid 301 1d; proxy_cache_valid any 1m; expires 30d;}复制代码 使用 location 反向代理到已有网站123location ~/bianque/(.*)$ { proxy_pass http://127.0.0.1:8888/$1/?$args; } 加内置变量 ![args 是保障 nginx 正则捕获 get 请求时不丢失，如果只是 post 请求，](https://juejin.im/equation?tex=args%20%E6%98%AF%E4%BF%9D%E9%9A%9C%20nginx%20%E6%AD%A3%E5%88%99%E6%8D%95%E8%8E%B7%20get%20%E8%AF%B7%E6%B1%82%E6%97%B6%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%8F%AA%E6%98%AF%20post%20%E8%AF%B7%E6%B1%82%EF%BC%8C%60)args是非必须的 $1 取自正则表达式部分()里的内容 其他ngx_http_sub_module 替换响应中内容 ngx_http_sub_module nginx 用来替换响应内容的一个模块（应用：有些程序中写死了端口，可以通过此工具将页面中的端口替换为其他端口） 配置 http 强制跳转 https在 nginx 配置文件中的 server 区域添加如下内容 123if ($scheme = 'http') { rewrite ^(.*)$ https://$host$uri;}","link":"/2020/05/16/%E8%BF%90%E7%BB%B4/Nginx/"},{"title":"HTML","text":"记录Html相关 h5的文档声明，声明当前的网页是按照HTML5标准编写的 编写网页时一定要将h5的文档声明写在网页的最上边 如果不写文档声明，则会导致有些浏览器会进入一个怪异模式， 进入怪异模式以后，浏览器解析页面会导致页l面无法正常显示，所以为了避免进入该模式，一定要写文档声明 1&lt;!doctype *html*&gt; 实体12345678910111213&lt;!-- 在HTML中，一些如&lt; &gt;这种特殊字符是不能直接使用， 需要使用一些特殊的符号来表示这些特殊字符，这些特殊符号我们称为实体（转义字符串） 浏览器解析到实体时，会自动将实体转换为其对应的字符 实体的语法： &amp;实体的名字; &lt; &amp;lt; &gt; &amp;gt; 空格 &amp;nbsp; 版权符号 &amp;copy; --&gt; a&amp;lt;b&amp;gt;c &lt;p&gt;&amp;copy;&amp;divide;今天天气&amp;nbsp;&amp;nbsp;&amp;nbsp;好晴朗，处处好风光&lt;/p&gt; w3 块元素和内联元素和行内块元素块元素常见的块元素有/&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中div标签是最典型的块元素。 块级元素的特点： 比较霸道，自己独占一行,无论他的内容有多少。 高度，宽度、外边距以及内边距都可以控制。 宽度默认是容器（父级宽度）的100%。 是一个容器及盒子，里面可以放行内或者块级元素。 注意： 文字类的元素内不能使用块级元素 &lt;p&gt;标签主要用于存放文字，因此里面不能放块级元素，特别是不能放&lt;div&gt;。 同理，&lt;h1&gt;-&lt;h6&gt;等都是文字类块级标签，里面也不能放其他块级元素 内联元素a strong b em i del s ins u spac iframe 行内元素的特点: 相邻行内元素在一行上，一行可以显示多个。 高、宽直接设置是无效的。 默认宽度就是它本身内容的宽度。 行内元素只能容纳文本或其他行内元素。 注意： 链接里面不能再放链接 特殊情况&lt;a&gt;链接里面可以放块级元素，但是给&lt;a&gt;转换一下块级模式最安全 行内块元素在行内元素中有几个特殊的标签img、input、td,它们同时具有块元素和行内元素的特点。 有些资料称它们为行内块元素 行内块元素的特点： 和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙。一行可以显示多个（行内元素特点）。 默认宽度就是它本身内容的宽度（行内元素特点）。 高度，行高、外边距以及内边距都可以控制（块级元素特点）。 选择器元素选择器作用：通过元素选择器可以选则页面中的所有指定元素 语法：标签名 {} 123p{ color: red;} id选择器通过元素的id属性值选中唯一的一个元素 语法：#id属性值 {} 123#p1{ font-size: 20px;} 类选择器通过元素的class属性值选中一组元素 语法：.class属性值{} 123.classname{ color:red;} 选择器分组(并集选择器)通过选择器分组可以同时选中多个选择器对应的元素 语法：选择器1,选择器2,选择器N{} 123#p1 , .p2 , h1{ background-color: yellow;} 通配选择器他可以用来选中页面中的所有的元素语法：*{} 复合选择器（交集选择器）作用：可以选中同时满足多个选择器的元素 语法：选择器1选择器2选择器N{} 123span .p3 { background-color: yellow;} 对于id选择器来说，不建议使用复合选择器 伪类选择器伪类专门用来表示元素的一种的特殊的状态，比如：访问过的超链接，比如普通的超链接，比如获取焦点的文本框.当我们需要为处在这些特殊状态的元素设置样式时，就可以使用伪类 12345678/* * 为没访问过的链接设置一个颜色为绿色 * :link * - 表示普通的链接（没访问过的链接） */a:link{ color: yellowgreen;} 123456789101112/* * 为访问过的链接设置一个颜色为红色 * :visited * - 表示访问过的链接 * * 浏览器是通过历史记录来判断一个链接是否访问过, * 由于涉及到用户的隐私问题，所以使用visited伪类只能设置字体的颜色 * */a:visited{ color: red;} 123456/* * :hover伪类表示鼠标移入的状态 */a:hover{ color: skyblue;} 123456/* * :active表示的是超链接被点击的状态 */a:active{ color: black;} 123456/* * 文本框获取焦点以后，修改背景颜色为黄色 */input:focus{ background-color: yellow;} 12345678910111213141516171819/** * 为p标签中选中的内容使用样式 * 可以使用::selection为类 * 注意：这个伪类在火狐中需要采用另一种方式编写::-moz-select */ /** * 兼容火狐的 */p::-moz-selection{ background-color: orange;} /** * 兼容大部分浏览器的 */p::selection{ background-color: orange;} 伪元素选择器表示元素中的一些特殊的位置 1234567/* * 为p中第一个字符来设置一个特殊的样式 */ p:first-letter { color: red; font-size: 20px;} 123456/* * 为p中的第一行设置一个背景颜色为黄色 */ p:first-line { background-color: yellow;} 123456789101112131415/* * :before表示元素最前边的部分 * 一般before都需要结合content这个样式一起使用， * 通过content可以向before或after的位置添加一些内容 * * :after表示元素的最后边的部分 */p:before{ content: \"我会出现在整个段落的最前边\"; color: red;} p:after{ content: \"我会出现在整个段落的最后边\"; color: orange;} 属性选择器作用：可以根据元素中的属性或属性值来选取指定元素 语法：[属性名] 选取含有指定属性的元素[属性名=”属性值”] 选取含有指定属性值的元素[属性名^=”属性值”] 选取属性值以指定内容开头的元素[属性名$=”属性值”] 选取属性值以指定内容结尾的元素[属性名*=”属性值”] 选取属性值以包含指定内容的元素 123456/* * 为title属性值以ab开头的元素设置一个背景颜色为黄色 */p[title^=\"ab\"]{ background-color: yellow;} 结构伪类选择器\\子元素选择器12345678910111213141516171819202122232425262728293031323334353637/* * 为第一个p标签设置一个背景颜色为黄色 * :first-child 可以选中第一个子元素 * :last-child 可以选中最后一个子元素 */body &gt; p:first-child{ background-color: yellow;}p:last-child{ background-color: yellow;} /* * :nth-child 可以选中任意位置的子元素 * 该选择器后边可以指定一个参数，指定要选中 * even 表示偶数位置的子元素 * odd 表示奇数位置的子元素 * */p:nth-child(odd){ background-color: yellow;} /* * :first-of-type * :last-of-type * :nth-of-type * 和:first-child这些非常的类似， * 只不过child，是在所有的子元素中排列 * 而type，是在当前类型的子元素中排列 */p:first-of-type{ background-color: yellow;}p:last-of-type{ background-color: yellow;} 兄弟元素选择器123456789101112131415161718/* * 为span后的一个p元素设置一个背景颜色为黄色 * 后一个兄弟元素选择器 * 作用：可以选中一个元素后紧挨着的指定的兄弟元素 * 语法：前一个 + 后一个 * */span + p{ background-color: yellow;} /* * 选中后边的所有兄弟元素 * 语法：前一个 ~ 后边所有 */span ~ p{ background-color: yellow;} 否定伪类1234567891011/* * 为所有的p元素设置一个背景颜色为黄色，除了class值为hello的 * * 否定伪类： * 作用：可以从已选中的元素中剔除出某些元素 * 语法： * :not(选择器) */p:not(.hello){ background-color: yellow;} 选择器的优先级当使用不同的选择器，选中同一个元素时并且设置相同的样式时，这时样式之间产生了冲突，最终到底采用哪个选择器定义的样式，由选择器的优先级（权重）决定, 优先级高的优先显示。 优先级的规则 内联样式 1000 id选择器 100 类和伪类 10 元素选择器 1 * 0 继承的样式，没有优先级 当选择器中包含多种选择器时，需要将多种选择器的优先级相加然后在比较，但是注意，选择器优先级计算不会超过他的最大的数量级，如果选择器的优先级一样，则使用靠后的样式。 并集选择器的优先级是单独计算 div , p , #p1 , .hello{} * 可以在样式的最后，添加一个!important，则此时该样式将会获得一个最高的优先级，将会优先于所有的样式显示甚至超过内联样式，但是在开发中尽量避免使用!important 各标签em&amp;strong这两个标签都表示一个强调的内容，em主要表示语气上的强调,em在浏览器中默认使用斜体显示strong表示强调的内容，比em更强烈，默认使用粗体显示 i&amp;bi标签中的内容会以斜体显示b标签中的内容会以加粗显示 h5规范中规定，对于不需要着重的内容而是单纯的加粗或者是斜体，就可以使用b和i标签 smallsmall标签中的内容会比他的父元素中的文字要小一些在h5中使用small标签来表示一些细则一类的内容比如：合同中小字，网站的版权声明都可以放到small cite网页中所有的加书名号的内容都可以使用cite标签，表示参考的内容，比如：书名 歌名 话剧名 电影名 。。。 qq标签表示一个短的引用（行内引用）q标签引用的内容，浏览器会默认加上引号blockquote标签表示一个长引用（块级引用） 12345678910&lt;p&gt; 子曰:&lt;q&gt;学而时习之不亦说乎！&lt;/q&gt;&lt;/p&gt; &lt;div&gt; 子曰: &lt;blockquote&gt; 有朋自远方来，乐呵乐呵！ &lt;/blockquote&gt;&lt;/div&gt; sup&amp;sub使用sup/sub标签来设置一个上/下标 del使用del标签来表示一个删除的内容del标签中的内容，会自动添加删除线 insins表示一个插入的内容ins中的的内容，会自动添加下划线 pre&amp;code需要页面中直接编写一些代码pre是一个预格式标签，会将代码中的格式保存，不会忽略多个空格code专门用来表示代码我们一般结合使用pre和code来表示一段代码 1234567&lt;pre&gt; &lt;code&gt; window.onload = function(){ alert(&quot;Hello World&quot;); }; &lt;/code&gt;&lt;/pre&gt; ul&amp;li&amp;ol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!-- 列表就相当于去超市购物时的那个购物清单，在HTML也可以创建列表，在网页中一共有三种列表： 1.无序列表 2.有序列表 3.定义列表 无序列表 - 使用ul标签来创建一个无序列表 - 使用li在ul中创建一个一个的列表项，一个li就是一个列表项 通过type属性可以修改无序列表的项目符号 可选值： disc，默认值，实心的圆点 square，实心的方块 circle，空心的圆 注意：默认的项目符号我们一般都不使用！！ 如果需要设置项目符号，则可以采用为li设置背景图片的方式来设置 !!!ul和li都是块元素 --&gt;&lt;ul&gt; &lt;li&gt;西门大官人&lt;/li&gt; &lt;li&gt;柴大官人&lt;/li&gt; &lt;li&gt;许大官人&lt;/li&gt; &lt;li&gt;唐僧大官人&lt;/li&gt;&lt;/ul&gt; &lt;!-- 有序列表和无序列表类似，只不过它使用ol来代替ul 有序列表使用有序的序号作为项目符号 type属性，可以指定序号的类型 可选值：1，默认值，使用阿拉伯数字 a/A 采用小写或大写字母作为序号 i/I 采用小写或大写的罗马数字作为序号 ol也是块元素 --&gt;&lt;ol type=\"I\"&gt; &lt;li&gt;结构&lt;/li&gt; &lt;li&gt;表现&lt;/li&gt; &lt;li&gt;行为&lt;/li&gt;&lt;/ol&gt; &lt;!-- 列表之间都是可以互相嵌套，可以在无序列表中放个有序列表 也可以在有序列表中放一个无序列表--&gt; &lt;p&gt;菜谱&lt;/p&gt;&lt;ul&gt; &lt;li&gt; 鱼香肉丝 &lt;ol&gt; &lt;li&gt;鱼&lt;/li&gt; &lt;li&gt;香&lt;/li&gt; &lt;li&gt;肉丝&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt; 宫保鸡丁 &lt;ul&gt; &lt;li&gt;宫保&lt;/li&gt; &lt;li&gt;鸡丁&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;青椒肉丝&lt;/li&gt;&lt;/ul&gt; dl&amp;dt&amp;dd123456789101112131415&lt;!-- 定义列表用来对一些词汇或内容进行定义 使用dl来创建一个定义列表 dl中有两个子标签 dt ： 被定义的内容 dd ： 对定义内容的描述 同样dl和ul和ol之间都可以互相嵌套 --&gt;&lt;dl&gt; &lt;dt&gt;武松&lt;/dt&gt; &lt;dd&gt;景阳冈打虎英雄，战斗力99&lt;/dd&gt; &lt;dd&gt;后打死西门庆，投奔梁山&lt;/dd&gt; &lt;dt&gt;武大&lt;/dt&gt; &lt;dd&gt;著名餐饮企业家，战斗力0&lt;/dd&gt;&lt;/dl&gt; center12345&lt;!-- center标签中的内容，会默认在页面中居中显示 我们可以将要居中的元素，全都放到center中--&gt; &lt;center&gt; &lt;p&gt;我是一个p标签&lt;/p&gt;&lt;/center&gt; a123456789101112131415161718&lt;!-- 使用超链接可以让我们从一个页面跳转到另一个页面使用a标签来创建一个超链接 属性： href:指向链接跳转的目标地址,可以写一个相对路径也可以写一个完整的地址 --&gt;&lt;a href=\"http://www.baidu.com\"&gt;我是一个超链接&lt;/a&gt; &lt;br /&gt;&lt;br /&gt;&lt;a href=\"http://www.baidu1234567.com\"&gt;我是一个超链接&lt;/a&gt; &lt;br /&gt;&lt;br /&gt; &lt;!-- a标签中的target属性可以用来指定打开链接的位置可选值： _self，表示在当前窗口中打开（默认值） _blank，在新的窗口中打开链接 可以设置一个内联框架的name属性值，链接将会在指定的内联框架中打开 --&gt;&lt;a href=\"demo03.html\" target=\"tom\"&gt;我是一个超链接&lt;/a&gt;&lt;iframe src=\"demo02.html\" name=\"tom\"&gt;&lt;/iframe&gt; iframe123456789101112&lt;!-- 使用内联框架可以引入一个外部的页面使用iframe来创建一个内联框架属性：src ：指向一个外部页面的路径，可以使用相对路径width：height：name ：可以为内联框架指定一个name属性在现实开发中不推荐使用内联框架，因为内联框架中的内容不会被搜索引擎所检索 --&gt;&lt;iframe src=\"demo02.html\" name=\"tom\"&gt;&lt;/iframe&gt; meta1234567891011121314151617&lt;!-- 使用meta标签还可以用来设置网页的关键字--&gt;&lt;meta name=\"keywords\" content=\"HTML5,JavaScript,前端,Java\" /&gt; &lt;!-- 还可以用来指定网页的描述 搜索引擎在检索页面时，会同时检索页面中的关键词和描述，但是这两个值不会影响页面在搜索引擎中--&gt;&lt;meta name=\"description\" content=\"发布h5、js等前端相关的信息\" /&gt; &lt;!-- 使用meta可以用来做请求的重定向 &lt;meta http-equiv=\"refresh\" content=\"秒数;url=目标路径\" /&gt;--&gt;&lt;meta http-equiv=\"refresh\" content=\"5;url=http://www.baidu.com\" /&gt; p1234567891011&lt;!-- 在HTML中，字符之间写再多的空格，浏览器也会当成一个空格解析， 换行也会当成一个空格解析。 在页面中可以使用br标签来表示一个换行，br标签是一个自结束标签 --&gt; &lt;p&gt; 锄禾日当午，&lt;br /&gt; 汗滴禾下土，&lt;br /&gt; 谁知盘中餐，&lt;br /&gt; 粒粒皆辛苦。&lt;br /&gt; &lt;/p&gt; Html5DOCTYPEDOCTYPE，或者称为 Document Type Declaration（文档类型声明，缩写 DTD）通常情况下，DOCTYPE 位于一个 HTML 文档的最前面的位置，位于根元素 HTML 的起始标签之前。因为浏览器必须在解析 HTML 文档正文之前就确定当前文档的类型，以决定其需要采用的渲染模式，不同的渲染模式会影响到浏览器对于 CSS 代码甚至 JavaScript 脚本的解析。 HTML5提供的是标准模式，向后兼容的,等同于开启了标准模式，那么浏览器就得老老实实的按照W3C的 标准解析渲染页面。一个不含任何 DOCTYPE 的网页将会以 怪异(quirks) 模式渲染。 根元素H4中的根元素:&lt;html xmlns=”http://www.w3.org/1999/xhtml&quot;&gt; 首先这个标记没有任何问题，你喜欢的话,那就背下来继续用。它是有效的。但这个标记中的很多字节在Html5中我们都可以省略了。 xmlns:这是XHTML1.0的东西，它的意思是在这个页面上的元素都位于http://www.w3.org/1999/xhtml这个命名空间内。但是HTML5中的每个元素都具有这个命名空间，不需要在页面上再显示指出。 H5中的根元素&lt;html&gt;&lt;/html&gt; 语义化标签以前布局，我们基本用 div 来做。div 对于搜索引擎来说，是没有语义的。 123456789101112131415&lt;header&gt;：头部标签，代表 网页 或 section 的页眉。通常包含h1-h6元素或hgroup。&lt;nav&gt;：导航标签,素代表页面的导航链接区域。用于定义页面的主要导航部分。&lt;article&gt;：内容标签,最容易跟section和div容易混淆，其实article代表一个在文档，页面或者网站中自成一体的内容.&lt;section&gt;：定义文档某个区域,代表文档中的 节 或 段，段可以是指一篇文章里按照主题的分段；节可以是指一个页面里的分组。&lt;aside&gt;：侧边栏标签,被包含在article元素中作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的相关资料、标签、名次解释等。&lt;footer&gt;：尾部标签，代表 网页 或 section 的页脚，通常含有该节的一些基本信息，譬如：作者，相关文档链接，版权资料。&lt;hgroup&gt;元素代表 网页 或 section 的标题，当元素有多个层级时，该元素可以将h1到h6元素放在其内，譬如文章的主标题和副标题的组合。 &lt;hgroup&gt; &lt;h1&gt;HTML 5&lt;/h1&gt; &lt;h2&gt;这是一篇介绍HTML 5语义化标签和更简洁的结构&lt;/h2&gt; &lt;/hgroup&gt;hgroup使用注意： 如果只需要一个h1-h6标签就不用hgroup 如果有连续多个h1-h6标签就用hgroup 如果有连续多个标题和其他文章数据，h1-h6标签就用hgroup包住，和其他文章元数据一起放入header标签 这种语义化标准主要是针对搜索引擎的 这些新标签页面中可以使用多次 在 IE9 中，需要把这些元素转换为块级元素 其实，我们移动端更喜欢使用这些标签 他们这些标签功能就是代替功能中的一部分，他们没有任何的默认样式，除了会让文本另起一行外；https://gsnedders.html5.org/outliner/ video audio input 这种语义化标准主要是针对搜索引擎的  这些新标签页面中可以使用多次  在 IE9 中，需要把这些元素转换为块级元素  其实，我们移动端更喜欢使用这些标签  HTML5 还增加了很多其他标签，我们后面再慢慢学 canvas&lt;canvas&gt; 是 HTML5 新增的元素，可用于通过使用JavaScript中的脚本来绘制图形. 例如，它可以用于绘制图形，创建动画。&lt;canvas&gt; 最早由Apple引入WebKit. 我们可以使用&lt;canvas&gt;标签来定义一个canvas元素—-&gt;使用&lt;canvas&gt;标签时，建议要成对出现，不要使用闭合的形式。—–&gt;canvas元素默认具有高宽 width： 300px height：150px 整体API1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111.注意点---canvas图像的渲染有别于html图像的渲染， canvas的渲染极快，不会出现代码覆盖后延迟渲染的问题 写canvas代码一定要具有同步思想---在获取上下文时，一定要先判断---画布高宽的问题 画布默认高宽300*150 切记一定要使用html的attribute的形式来定义画布的宽高 通过css形式定义会缩放画布内的图像---绘制矩形的问题 a.边框宽度的问题，边框宽度是在偏移量上下分别渲染一半，可能会出现小数边框， 一旦出现小数边框都会向上取整 b.canvas的api只支持一种图像的直接渲染：矩形---我们没法使用选择器来选到canvas中的图像2.画布api oc.getContext(\"2d\"):获取画布的2d上下文 oc.width:画布在横向上css像素的个数 oc.height:画布在纵向上css像素的个数 oc.toDataUrl():拿到画布的图片地址3.上下文api ctx.fillRect(x,y,w,h):填充矩形 ctx.strokeRect(x,ymwmh):带边框的矩形 ctx.clearRect(0,0,oc.width,oc.height):清除整个画布,注意原点的位置 ctx.fillStyle:填充颜色 背景fillStyle的值可以是createPattern(image, repetition)返回的对象 线性渐变fillStyle的值可以是createLinearGradient(x1, y1, x2, y2))返回的对象 addColorStop(position, color) 径向渐变fillStyle的值可以是createRadialGradient(x1, y1, r1, x2, y2, r2)返回的对象 addColorStop(position, color) ctx.strokeStyle:线条颜色 ctx.lineWidth：线条宽度 ctx.lineCap：线条两端的展现形式 ctx.lineJoin：线条连接处的展现形式 ctx.moveTo(x,y):将画笔抬起点到x，y处 ctx.lineTo(x,y):将画笔移到x，y处 ctx.rect(x,y,w,h) ctx.arc(x,y,r,degS,degE,dir) ctx.arcTo(x1,y1,x2,y2,r):2个坐标，一个半径 结合moveTo(x,y)方法使用， x,y:起始点 x1,y1：控制点 x2,y2：结束点 ctx.quadraticCurveTo(x1,y1,x2,y2) 结合moveTo(x,y)方法使用， x,y:起始点 x1,y1：控制点 x2,y2：结束点 必须经过起点和终点 ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3) 结合moveTo(x,y)方法使用， x,y:起始点 x1,y1：控制点 x2,y2：控制点 x3，y3：结束点 必须经过起点和终点 ctx.fill() ctx.stroke() ctx.beginpath():清除路径容器 ctx.closepath():闭合路径 fill自动闭合 stroke需要手动闭合 ctx.save() 将画布当前状态(样式相关 变换相关)压入到样式栈中 ctx.restore() 将样式栈中栈顶的元素弹到样式容器中 图像最终渲染依赖于样式容器 ctx.translate(x,y):将原点按当前坐标轴位移x，y个单位 ctx.rotate(弧度):将坐标轴按顺时针方向进行旋转 ctx.scale(因子): 放大：放大画布，画布中的一个css像素所占据的物理面积变大，画布中包含的css像素的个数变少 画布中图像所包含的css像素的个数不变 缩小：缩小画布，画布中的一个css像素所占据的物理面积变小，画布中包含的css像素的个数变多 画布中图像所包含的css像素的个数不变 ctx.drawImage(img,x,y,w,h):在canvas中引入图片一定在图片加载完成之后再去操作 ctx.measureText(\"文本\"):返回一个持有文本渲染宽度的对象 ctx.fillText() ctx.strokeText() ctx.font ctx.textAlign ctx.textBaseline shadowOffsetX = float shadowOffsetY = float shadowBlur = float shadowColor = color(必需项) ctx.getImageData(x,y,w,h) ImageData对象 width：选中区域在横向上css像素的个数 height：选中区域在纵向上css像素的个数 data:数组 选中区域所有像素点的rgba信息，rgba的取值从0到255 ctx.putImageData(imgdata,x,y) ctx.createImageData(w,h) 返回的是imgdata对象 默认像素点的信息是rgba(0,0,0,0) ctx.globalAlpha 取值为0到1 ctx.globalCompositeOperation source-over(默认值):源在上面,新的图像层级比较高 source-in :只留下源与目标的重叠部分(源的那一部分) source-out :只留下源超过目标的部分 source-atop:砍掉源溢出的部分 destination-over:目标在上面,旧的图像层级比较高 destination-in:只留下源与目标的重叠部分(目标的那一部分) destination-out:只留下目标超过源的部分 destination-atop:砍掉目标溢出的部分 ctx.ispointinpath(x,y) x,y这个点是否在路径上4.实例 时钟动画：结合了所有基础api 飞鸟动画：结合图片创建动画 马赛克：像素操作 刮刮卡：合成+像素操作 替换内容&lt;canvas&gt;很容易定义一些替代内容。由于某些较老的浏览器（尤其是IE9之前的IE浏览器） 不支持HTML元素”canvas”， 但在这些浏览器上你应该要给用户展示些替代内容。 这非常简单：我们只需要在标签中提供替换内容就可以。 —&gt;支持的浏览器将会忽略在容器中包含的内容，并且只是正常渲染canvas。 –&gt;不支持的浏览器会显示代替内容 canvas标签的两个属性&lt;canvas&gt; 看起来和&lt;img&gt;元素很相像，唯一的不同就是它并没有 src 和 alt 属性。 实际上，&lt;canvas&gt; 标签只有两个属性—— width和height。这些都是可选的。 当没有设置宽度和高度的时候，canvas会初始化宽度为300像素和高度为150像素。 画布的高宽html属性设置width height时只影响画布本身不影画布内容css属性设置width height时不但会影响画布本身的高宽，还会使画布中的内容等比例缩放（缩放参照于画布默认的尺寸） 渲染上下文&lt;canvas&gt; 元素只是创造了一个固定大小的画布，要想在它上面去绘制内容，我们需要找到它的渲染上下文.&lt;canvas&gt; 元素有一个叫做 getContext() 的方法，这个方法是用来获得渲染上下文和它的绘画功能。 12var canvas = document.getElementById('box');var ctx = canvas.getContext('2d'); 检查支持性 1234var canvas =document.getElementById('tutorial');if (canvas.getContext){ var ctx = canvas.getContext('2d');} 绘制矩形HTML中的元素canvas只支持一种原生的图形绘制：矩形。所有其他的图形的绘制都至少需要生成一条路径. canvas提供了三种方法绘制矩形： 绘制一个填充的矩形（填充色默认为黑色） fillRect(x, y, width, height) 绘制一个矩形的边框（默认边框为:一像素实心黑色） strokeRect(x, y, width, height) 清除指定矩形区域，让清除部分完全透明。 clearRect(x, y, width, height) x与y指定了在canvas画布上所绘制的矩形的左上角（相对于原点）的坐标。width和height设置矩形的尺寸。（存在边框的话，边框会在width上占据一个边框的宽度，height同理） strokeRect时，边框像素渲染问题按理渲染出的边框应该是1px的，canvas在渲染矩形边框时，边框宽度是平均分在偏移位置的两侧。context.strokeRect(10,10,50,50):边框会渲染在10.5 和 9.5之间,浏览器是不会让一个像素只用自己的一半的相当于边框会渲染在9到11之间context.strokeRect(10.5,10.5,50,50):边框会渲染在10到11之间 添加样式和颜色fillStyle :设置图形的填充颜色。strokeStyle :设置图形轮廓的颜色。默认情况下，线条和填充颜色都是黑色（CSS 颜色#000000）ineWidth : 这个属性设置当前绘线的粗细。属性值必须为正数。描述线段宽度的数字。 0、 负数、 Infinity 和 NaN 会被忽略。默认值是1.0。 lineJoin设定线条与线条间接合处的样式（默认是 miter） round : 圆角 bevel : 斜角 miter : 直角 绘制路径基础api图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。1.首先，你需要创建路径起始点。2.然后你使用画图命令去画出路径3.之后你把路径封闭。4.一旦路径生成，你就能通过描边或填充路径区域来渲染图形。 beginPath()新建一条路径，生成之后，图形绘制命令被指向到路径上准备生成路径。本质上，路径是由很多子路径构成，这些子路径都是在一个列表中，所有的子路径（线、弧形、等等）构成图形。而每次这个方法调用之后，列表清空重置，然后我们就可以重新绘制新的图形。 moveTo(x, y)将笔触移动到指定的坐标x以及y上,当canvas初始化或者beginPath()调用后，你通常会使用moveTo()函数设置起点. lineTo(x, y)将笔触移动到指定的坐标x以及y上,绘制一条从当前位置到指定x以及y位置的直线。 closePath()闭合路径之后图形绘制命令又重新指向到上下文中。闭合路径closePath(),不是必需的。这个方法会通过绘制一条从当前点到开始点的直线来闭合图形。如果图形是已经闭合了的，即当前点为开始点，该函数什么也不做当你调用fill()函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用closePath()函数。但是调用stroke()时不会自动闭合. stroke()通过线条来绘制图形轮廓。不会自动调用closePath(). fill()通过填充路径的内容区域生成实心的图形。自动调用closePath(). rect(x, y, width, height)绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。当该方法执行的时候，moveTo()方法自动设置坐标参数（0,0）。也就是说，当前笔触自动重置会默认坐标. save()是 Canvas 2D API 通过将当前状态放入栈中，保存 canvas 全部状态的方法. restore()是 Canvas 2D API 通过在绘图状态栈中弹出顶端的状态，将 canvas 恢复到最近的保存状态的方法。 如果没有保存状态，此方法不做任何改变。 lineCaplineCap 是 Canvas 2D API 指定如何绘制每一条线段末端的属性。有3个可能的值，分别是： lineCap=”butt” :线段末端以方形结束。 round :线段末端以圆形结束 square:线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域 默认值是 butt。 保存到栈中的绘制状态有下面部分组成： 当前的变换矩阵。 当前的剪切区域。 当前的虚线列表. 以下属性当前的值： strokeStyle, fillStyle, lineWidth, lineCap, lineJoin… beginPath\\closePath很重要，不然两个三角形第二次都会生成，后生成的会覆盖前面的。 注意，颜色取决于save restore的嵌套层级，如下图save压栈，restore弹栈 基础模板12345678910111213141516171819202122232425262728293031323334window.onload=function(){ /* 1.路径容器 每次调用路径api时,都会往路径容器里做登记 调用beginPath时,清空整个路径容器 2.样式容器 每次调用样式api时,都会往样式容器里做登记 调用save时候,将样式容器里的状态压入样式栈 调用restor时候,将样式栈的栈顶状态弹出到样式样式容器里,进行覆盖 3.样式栈 调用save时候,将样式容器里的状态压入样式栈 调用restore时候,将样式栈的栈顶状态弹出到样式样式容器里,进行覆盖 */ var canvas = document.querySelector(\"#test\"); if(canvas.getContext){ var ctx = canvas.getContext(\"2d\"); ctx.save(); //关于样式的设置 //save restore成对出现 ctx.beginPath(); //关于路径 ctx.restore(); ctx.save(); //关于样式的设置 ctx.beginPath(); //关于路径 ctx.fill(); ctx.restore(); } 案例 签名12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; *{ margin: 0; padding: 0; } body{ background: gray; } #test{ position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto; background:white; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=\"test\" width=\"500\" height=\"500\"&gt;&lt;/canvas&gt; &lt;/body&gt; &lt;script type=\"text/javascript\"&gt; window.onload=function(){ var canvas =document.getElementById(\"test\"); if(canvas.getContext){ var ctx = canvas.getContext(\"2d\"); } canvas.onmousedown=function(ev){ ev = ev || window.event; if(canvas.setCapture){ canvas.setCapture(); } ctx.beginPath(); ctx.moveTo(ev.clientX -canvas.offsetLeft,ev.clientY -canvas.offsetTop); document.onmousemove=function(ev){ ctx.save(); ctx.strokeStyle=\"pink\"; ev = ev || event; ctx.lineTo(ev.clientX -canvas.offsetLeft,ev.clientY -canvas.offsetTop); ctx.stroke(); ctx.restore(); } document.onmouseup=function(){ document.onmousemove=document.onmouseup=null; if(document.releaseCapture){ document.releaseCapture(); } } return false; } } &lt;/script&gt;&lt;/html&gt; 圆形弧度的js表达式:radians=(Math.PI/180)*degrees。 arc(x,y,radius,startAngle,endAngle,anticlockwise)画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。 ture：逆时针 false:顺时针 x,y为绘制圆弧所在圆上的圆心坐标 radius为半径 startAngle以及endAngle参数用弧度定义了开始以及结束的弧度。这些都是以x轴为基准 参数anticlockwise 为一个布尔值。为true时，是逆时针方向，否则顺时针方向。 arcTo(x1, y1, x2, y2, radius)根据给定的控制点和半径画一段圆弧肯定会从(x1 y1) 但不一定经过(x2 y2);(x2 y2)只是控制一个方向 贝塞尔quadraticCurveTo(cp1x, cp1y, x, y)绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。起始点为moveto时指定的点. bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。起始点为moveto时指定的点. canvas中的变换translate(x, y)我们先介绍 translate 方法，它用来移动 canvas的原点到一个不同的位置。translate 方法接受两个参数。x 是左右偏移量，y 是上下偏移量，在canvas中translate是累加的. rotate(angle)这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。旋转的中心点始终是 canvas 的原点，如果要改变它，我们需要用到 translate 方法,在canvas中rotate是累加的 scale(x, y)scale 方法接受两个参数。x,y 分别是横轴和纵轴的缩放因子，它们都必须是正值。值比 1.0 小表示缩小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有。缩放一般我们用它来增减图形在 canvas 中的像素数目，对形状，位图进行缩小或者放大。在canvas中scale是累称的。 css像素是一个抽象单位 放大:使画布内css像素的个数变少，单个css像素所占据的实际物理尺寸变大 缩小:使画布内css像素的个数变多，单个css像素所占据的实际物理尺寸变小 变换实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; * { margin: 0; padding: 0; } html, body { height: 100%; overflow: hidden; } body { background: pink; } #test { background: gray; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=\"test\" width=\"300\" height=\"300\"&gt; &lt;span&gt;您的浏览器不支持画布元素 请您换成萌萌的谷歌&lt;/span&gt; &lt;/canvas&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function () { var flag = 0; var scale = 0; var flagScale = 0; var canvas = document.querySelector(\"#test\"); if (canvas.getContext) { var ctx = canvas.getContext(\"2d\"); ctx.save(); ctx.translate(150, 150); ctx.beginPath() ctx.fillRect(-50, -50, 100, 100); ctx.restore(); setInterval(function () { flag++ ctx.clearRect(0, 0, canvas.width, canvas.height) ctx.save() ctx.translate(150, 150); ctx.rotate(flag * Math.PI / 180) if (scale == 100) { flagScale = -1; } else if(scale==0){ flagScale = 1 } scale+=flagScale ctx.scale(scale/50,scale/50) ctx.beginPath() ctx.fillRect(-50, -50, 100, 100); ctx.restore() }, 1000 / 60) } }&lt;/script&gt;&lt;/html&gt; 实例 钟表1.初始化 将圆心调整到画布的中间 由于canvas中画圆与旋转所参照的坐标系于正常坐标系有出入 将整个画布逆时针旋转90度 初始化一些样式数据 ctx.lineWidth = 8; ctx.strokeStyle = “black”; ctx.lineCap = “round”;2.外层空心圆盘 圆盘颜色:#325FA2 圆盘宽度:14 圆盘半径:140 3.时针刻度 长度为20 宽度为8 外层空心圆盘与时针刻度之间的距离也为20 4.分针刻度 宽度为4 长度为3 5.时针 宽度为14 圆心外溢出80 收20 6.分针 宽度为10 圆心外溢出112 收28 7.秒针 颜色:D40000 宽度为6 圆心外溢出83 收30 —-&gt;中心实心圆盘 半径为10 ​ —-&gt;秒针头​ 96码开外半径为10的空心圆​ 宽度为6 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; *{ margin: 0; padding: 0; } html,body{ height: 100%; overflow: hidden; background: pink; } #clock{ background: gray; position: absolute; left: 50%; top: 50%; transform: translate3d(-50%,-50%,0); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=\"clock\" width=\"400\" height=\"400\"&gt;&lt;/canvas&gt; &lt;/body&gt; &lt;script type=\"text/javascript\"&gt; window.onload=function(){ var clock = document.querySelector(\"#clock\"); if(clock.getContext){ var ctx = clock.getContext(\"2d\"); setInterval(function(){ ctx.clearRect(0,0,clock.width,clock.height); move(); },1000); move(); function move(){ ctx.save(); ctx.lineWidth = 8; ctx.strokeStyle = \"black\"; ctx.lineCap = \"round\"; ctx.translate(200,200); ctx.scale(.5,.5) ctx.rotate(-90*Math.PI/180); ctx.beginPath(); //外层空心圆盘 ctx.save(); ctx.strokeStyle=\"#325FA2\"; ctx.lineWidth = 14; ctx.beginPath(); ctx.arc(0,0,140,0,360*Math.PI/180); ctx.stroke(); ctx.restore(); //时针刻度 ctx.save(); for(var i=0;i&lt;12;i++){ ctx.rotate(30*Math.PI/180); ctx.beginPath(); ctx.moveTo(100,0) ctx.lineTo(120,0); ctx.stroke(); } ctx.restore(); //分针刻度 ctx.save(); ctx.lineWidth=4; for(var i=0;i&lt;60;i++){ ctx.rotate(6*Math.PI/180); if((i+1)%5!=0){ ctx.beginPath(); ctx.moveTo(117,0) ctx.lineTo(120,0); ctx.stroke(); } } ctx.restore(); //时针 分针 秒针 表座 var date = new Date(); var s = date.getSeconds(); var m = date.getMinutes()+s/60; var h = date.getHours()+m/60; h = h&gt;12?h-12:h; //时针 ctx.save() ctx.lineWidth=14; ctx.rotate(h*30*Math.PI/180) ctx.beginPath() ctx.moveTo(-20,0); ctx.lineTo(80,0); ctx.stroke(); ctx.restore() //分针 ctx.save() ctx.lineWidth=10; ctx.rotate(m*6*Math.PI/180) ctx.beginPath() ctx.moveTo(-28,0); ctx.lineTo(112,0); ctx.stroke(); ctx.restore() //秒针 ctx.save() ctx.lineWidth=6; ctx.strokeStyle=\"#D40000\"; ctx.fillStyle=\"#D40000\"; ctx.rotate(s*6*Math.PI/180) ctx.beginPath(); ctx.moveTo(-30,0); ctx.lineTo(83,0); ctx.stroke(); //表座 ctx.beginPath(); ctx.arc(0,0,10,0,360*Math.PI/180); ctx.fill(); //秒头 ctx.beginPath(); ctx.arc(96,0,10,0,360*Math.PI/180); ctx.stroke(); ctx.restore() ctx.restore(); } } } &lt;/script&gt;&lt;/html&gt; 在canvas中插入图片(需要image对象) canvas操作图片时，必须要等图片加载完才能操作 drawImage(image, x, y, width, height)其中 image 是 image 或者 canvas 对象，x 和 y 是其在目标 canvas 里的起始坐标。这个方法多了2个参数：width 和 height，这两个参数用来控制 当像canvas画入时应该缩放的大小。 可以参考MDN文档了解img对象地各种属性 在canvas中设置背景createPattern(image, repetition) image:图像源epetition: “repeat” “repeat-x” “repeat-y” “no-repeat” 一般情况下，我们都会将createPattern返回的对象作为fillstyle的值。 渐变线性渐变createLinearGradient(x1, y1, x2, y2) 表示渐变的起点 (x1,y1) 与终点 (x2,y2)。 gradient.addColorStop(position, color) gradient :createLinearGradient的返回值 addColorStop 方法接受 2 个参数: position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。例如，0.5 表示颜色会出现在正中间。 color 参数必须是一个有效的 CSS 颜色值（如 #FFF， rgba(0,0,0,1)，等等） 径向渐变createRadialGradient(x1, y1, r1, x2, y2, r2) 前三个参数则定义另一个以(x1,y1) 为原点，半径为 r1 的圆。 后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。 文本相关绘制canvas 提供了两种方法来渲染文本: fillText(text, x, y)在指定的(x,y)位置填充指定文本 strokeText(text, x, y)在指定的(x,y)位置绘制文本边框 文本样式font = value当前我们用来绘制文本的样式. 这个字符串使用和 CSS font 属性相同的语法。默认的字体是 10px sans-serif。font属性在指定时，必须要有大小和字体 缺一不可。 textAlign = value文本对齐选项,可选的值包括： left, right center. left文本左对齐。 right文本右对齐。 center文本居中对齐。 这里的textAlign=”center”比较特殊。textAlign的值为center时候文本的居中是基于你在fillText的时候所给的x的值，也就是说文本一半在x的左边，一半在x的右边。 textBaseline = value描述绘制文本时，当前文本基线的属性。 top文本基线在文本块的顶部。 middle文本基线在文本块的中间。 bottom文本基线在文本块的底部。 measureTextmeasureText() 方法返回一个 TextMetrics 对象，包含关于文本尺寸的信息（例如文本的宽度） canvas中文本水平垂直居中 文本阴影&amp;盒阴影 像素相关到目前为止，我们尚未深入了解Canvas画布真实像素的原理，事实上，你可以直接通过ImageData对象操纵像素数据，直接读取或将数据数组写入该对象中。 得到场景像素数据getImageData():获得一个包含画布场景像素数据的ImageData对像,它代表了画布区域的对象数据。 ctx.getImageData(sx, sy, sw, sh) sx:将要被提取的图像数据矩形区域的左上角 x 坐标。 sy:将要被提取的图像数据矩形区域的左上角 y 坐标。 sw:将要被提取的图像数据矩形区域的宽度。 sh:将要被提取的图像数据矩形区域的高度。 ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性： width:图片宽度，单位是像素 height:图片高度，单位是像素 data:Uint8ClampedArray类型的一维数组，包含着RGBA格式的整型数据，范围在0至255之间（包括255） R:0 –&gt; 255(黑色到白色) G:0 –&gt; 255(黑色到白色) B:0 –&gt; 255(黑色到白色) A:0 –&gt; 255(透明到不透明) 创建一个ImageData对象ctx.createImageData(width, height); width : ImageData 新对象的宽度。 height: ImageData 新对象的高度。 在场景中写入像素数据putImageData()方法去对场景进行像素数据的写入。putImageData(myImageData, dx, dy) dx和dy 参数表示你希望在场景内左上角绘制的像素数据所得到的设备坐标 操作单个像素（行与列） 两个操作函数,注意这里有老生常谈的xy计算问题。 123456789101112131415161718192021222324252627282930function getPxInfo(imgdata, x, y) { var color = []; var data = imgdata.data; var w = imgdata.width; var h = imgdata.height; //(x,y) x*w+y //r color[0] = data[(y * w + x) * 4]; //g color[1] = data[(y * w + x) * 4 + 1]; //b color[2] = data[(y * w + x) * 4 + 2]; //a color[3] = data[(y * w + x) * 4 + 3]; return color;}function setPxInfo(imgdata, x, y, color) { var data = imgdata.data; var w = imgdata.width; var h = imgdata.height; //(x,y) x*w+y x:多少列 y：多少行 //r data[(y * w + x) * 4] = color[0]; //g data[(y * w + x) * 4 + 1] = color[1]; //b data[(y * w + x) * 4 + 2] = color[2]; //a data[(y * w + x) * 4 + 3] = color[3];} 马赛克 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; *{ margin: 0; padding: 0; } html,body{ height: 100%; overflow: hidden; } #msk{ position: absolute; left: 50%; top: 50%; transform: translate3d(-50%,-50%,0); /*background: gray;*/ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=\"msk\" &gt;&lt;/canvas&gt; &lt;/body&gt; &lt;script type=\"text/javascript\"&gt; var oc = document.querySelector(\"#msk\"); if(oc.getContext){ var ctx = oc.getContext(\"2d\"); var img = new Image(); img.src=\"2.png\"; img.onload=function(){ oc.width=img.width*2; oc.height=img.height; draw(); } function draw(){ ctx.drawImage(img,0,0); var oldImgdata = ctx.getImageData(0,0,img.width,img.height); var newImgdata = ctx.createImageData(img.width,img.height); //马赛克 /* 1.选取一个马赛克矩形 2.从马赛克矩形中随机抽出一个像素点的信息(rgba) 3.将整个马赛克矩形中的像素点信息统一调成随机抽出的那个 */ //选取一个马赛克矩形 var size = 5; for(var i=0;i&lt;oldImgdata.width/size;i++){ for(var j=0;j&lt;oldImgdata.height/size;j++){ //(i,j) 每一个马赛克矩形的坐标 //(0,0): (0,0) (4,4);[0,4] //(1,0): (5,0) (9,4) //(0,1): (0,5) (4,9) //(1,1): (5,5) (9,9) //Math.random() [0,1) //Math.random()*size [0,5) //Math.floor(Math.random()*size) [0,4] //从马赛克矩形中随机抽出一个像素点的信息(rgba) var color = getPxInfo(oldImgdata,i*size+Math.floor(Math.random()*size),j*size+Math.floor(Math.random()*size)); //将整个马赛克矩形中的像素点信息统一调成随机抽出的那个 for(var a=0;a&lt;size;a++){ for(var b=0;b&lt;size;b++){ setPxInfo(newImgdata,i*size+a,j*size+b,color) } } } } // ctx.clearRect(0,0,oc.width,oc.height); ctx.putImageData(newImgdata,0,0); } function getPxInfo(imgdata,x,y){ var color = []; var data = imgdata.data; var w = imgdata.width; var h = imgdata.height; color[0]=data[(y*w+x)*4]; color[1]=data[(y*w+x)*4+1]; color[2]=data[(y*w+x)*4+2]; color[3]=data[(y*w+x)*4+3]; return color; } function setPxInfo(imgdata,x,y,color){ var data = imgdata.data; var w = imgdata.width; var h = imgdata.height; data[(y*w+x)*4]=color[0]; data[(y*w+x)*4+1]=color[1]; data[(y*w+x)*4+2]=color[2]; data[(y*w+x)*4+3]=color[3]; } } &lt;/script&gt;&lt;/html&gt; 全局透明度globalAlpha = value这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明）,默认是 1.0。 合成source:新的图像(源)destination:已经绘制过的图形(目标) globalCompositeOperation source-over(默认值):源在上面,新的图像层级比较高 source-in :只留下源与目标的重叠部分(源的那一部分) source-out :只留下源超过目标的部分 source-atop:砍掉源溢出的部分 destination-over:目标在上面,旧的图像层级比较高 destination-in:只留下源与目标的重叠部分(目标的那一部分) destination-out:只留下目标超过源的部分 destination-atop:砍掉目标溢出的部分 案例 刮刮卡123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,user-scalable=no\"&gt; &lt;/meta&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; * { margin: 0; padding: 0; } html, body { height: 100%; overflow: hidden; } #wrap, ul, ul&gt;li { height: 100%; } ul&gt;li { background: url(img/b.png); background-size: 100% 100%; } canvas { position: absolute; left: 0; top: 0; transition: 1s; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"wrap\"&gt; &lt;canvas&gt;&lt;/canvas&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function () { var canvas = document.querySelector(\"canvas\"); canvas.width = document.documentElement.clientWidth; canvas.height = document.documentElement.clientHeight; if (canvas.getContext) { var ctx = canvas.getContext(\"2d\"); var img = new Image(); img.src = \"img/a.png\"; img.onload = function () { draw(); } function draw() { var flag = 0; ctx.drawImage(img, 0, 0, canvas.width, canvas.height); canvas.addEventListener(\"touchstart\", function (ev) { ev = ev || event; var touchC = ev.changedTouches[0]; var x = touchC.clientX - canvas.offsetLeft; var y = touchC.clientY - canvas.offsetTop; ctx.globalCompositeOperation = \"destination-out\"; //这里用destination-out，则每点击一下，只留下原来的图像除了新点的位置的部分 //新点的也将消失，所以等价于每点一下则图片对应圆点消失，则只剩下背景。 ctx.lineWidth = 40; ctx.lineCap = \"round\"; ctx.lineJoin = \"round\"; ctx.save(); ctx.beginPath(); // ctx.arc(x,y,20,0,360*Math.PI/180); ctx.moveTo(x, y); ctx.lineTo(x + 1, y + 1) ctx.stroke(); ctx.restore(); }) canvas.addEventListener(\"touchmove\", function (ev) { ev = ev || event; var touchC = ev.changedTouches[0]; var x = touchC.clientX - canvas.offsetLeft; var y = touchC.clientY - canvas.offsetTop; ctx.save(); // ctx.arc(x,y,20,0,360*Math.PI/180); ctx.lineTo(x, y) ctx.stroke(); ctx.restore(); }) canvas.addEventListener(\"touchend\", function () { var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height) var allPx = imgData.width * imgData.height; for (var i = 0; i &lt; allPx; i++) { if (imgData.data[4 * i + 3] === 0) { flag++; } } if (flag &gt;= allPx / 2) { canvas.style.opacity = 0; } }) canvas.addEventListener(\"transitionend\", function () { this.remove(); }) } } }&lt;/script&gt;&lt;/html&gt; 导出为图像toDataURL(注意是canvas元素接口上的方法) 1234567891011window.onload=function(){ //querySelector身上有坑 //拿到画布 var canvas = document.querySelector(\"#test\"); if(canvas.getContext){ var ctx = canvas.getContext(\"2d\"); ctx.fillRect(0,0,199,199); var result = canvas.toDataURL(); console.log(result); }} 事件操作ctx.isPointInPath(x, y)判断在当前路径中是否包含检测点 x:检测点的X坐标 y:检测点的Y坐标 !注意，此方法只作用于最新一次性画出的canvas图像。","link":"/2020/05/16/%E5%A4%A7%E5%89%8D%E7%AB%AF/Html/"},{"title":"CSS","text":"记录CSS相关 长度单位 像素 px像素是我们在网页中使用的最多的一个单位，一个像素就相当于我们屏幕中的一个小点，我们的屏幕实际上就是由这些像素点构成的但是这些像素点，是不能直接看见。不同显示器一个像素的大小也不相同，显示效果越好越清晰，像素就越小，反之像素越大。 百分比 %也可以将单位设置为一个百分比的形式，这样浏览器将会根据其父元素的样式来计算该值使用百分比的好处是，当父元素的属性值发生变化时，子元素也会按照比例发生改变。在我们创建一个自适应的页面时，经常使用百分比作为单位。 em em和百分比类似，它是相对于当前元素的字体大小来计算的 1em = 1font-size 使用em时，当字体大小发生改变时，em也会随之改变 当设置字体相关的样式时，经常会使用em 颜色单位在CSS可以直接使用颜色的单词来表示不同的颜色红色：red蓝色：blue绿色：green也可以使用RGB值来表示不同的颜色 所谓的RGB值指的是通过Red Green Blue三元色，通过这三种颜色的不同的浓度，来表示出不同的颜色例子：rgb(红色的浓度,绿色的浓度,蓝色的浓度); 颜色的浓度需要一个0-255之间的值，255表示最大，0表示没有 浓度也可以采用一个百分数来设置，需要一个0% - 100%之间的数字使用百分数最终也会转换为0-255之间的数0%表示0,100%表示255. 也可以使用十六进制的rgb值来表示颜色，原理和上边RGB原理一样，只不过使用十六进制数来代替，使用三组两位的十六进制数组来表示一个颜色.每组表示一个颜色. 第一组表示红色的浓度，范围00-ff第二组表示绿色的浓度，范围是00-ff第三组表示蓝色的浓度，范围00-ff语法：#红色绿色蓝色十六进制：0 1 2 3 4 5 6 7 8 9 a b c d e f00 - ff00表示没有，相当于rgb中的0ff表示最大，相当于rgb中255红色： #ff0000像这种两位两位重复的颜色，可以简写 比如：#ff0000 可以写成 #f00 #abc #aabbcc 12345background-color: rgb(161,187,215); background-color: rgb(100%,50%,50%); background-color: #00f; background-color: #abc; /*#aabbcc*/background-color: #084098; 字体12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/*设置文字的大小,浏览器中一般默认的文字大小都是16pxfont-size设置的并不是文字本身的大小，在页面中，每个文字都是处在一个看不见的框中的我们设置的font-size实际上是设置格的高度，并不是字体的大小.一般情况下文字都要比这个格要小一些，也有时会比格大，根据字体的不同，显示效果也不能 * */font-size: 30px; /* * 通过font-family可以指定文字的字体 * 当采用某种字体时，如果浏览器支持则使用该字体， * 如果字体不支持，则使用默认字体 * 该样式可以同时指定多个字体，多个字体之间使用,分开 * 当采用多个字体时，浏览器会优先使用前边的字体， * 如果前边没有在尝试下一个 */font-family: arial , 微软雅黑; /* * 浏览器使用的字体默认就是计算机中的字体， * 如果计算机中有，则使用，如果没有就不用 * 在开发中，如果字体太奇怪，用的太少了，尽量不要使用， * 有可能用户的电脑没有，就不能达到想要的效果。 */ font-family: \"curlz mt\";/* * font-style可以用来设置文字的斜体 * - 可选值： * normal，默认值，文字正常显示 * italic 文字会以斜体显示 * oblique 文字会以倾斜的效果显示 * - 大部分浏览器都不会对倾斜和斜体做区分， * 也就是说我们设置italic和oblique它们的效果往往是一样的 * - 一般我们只会使用italic */font-style: italic; /* * font-weight可以用来设置文本的加粗效果： * 可选值： * normal，默认值，文字正常显示 * bold，文字加粗显示 * 该样式也可以指定100-900之间的9个值， * 但是由于用户的计算机往往没有这么多级别的字体，所以达到 * 也就是200有可能比100粗，300有可能比200粗 */font-weight: bold; /* * font-variant可以用来设置小型大写字母 * 可选值： * normal，默认值，文字正常显示 * small-caps 文本以小型大写字母显示 * 小型大写字母： * 将所有的字母都以大写形式显示，但是小写字母的大写， * 要比大写字母的大小小一些。 */font-variant: small-caps ;/* * 在CSS并没有为我们提供一个直接设置行间距的方式， * 我们只能通过设置行高来间接的设置行间距，行高越大行间距越大 * 使用line-height来设置行高 * 行高类似于我们上学单线本，单线本是一行一行，线与线之间的距离就是行高， * 网页中的文字实际上也是写在一个看不见的线中的，而文字会默认在行高中垂直居中显示 * 行间距 = 行高 - 字体大小 */.p1{ font-size: 20px; /* * 通过设置line-height可以间接的设置行高， * 可以接收的值： * 1.直接就收一个大小 * 2.可以指定一个百分数，则会相对于字体去计算行高 * 3.可以直接传一个数值，则行高会设置字体大小相应的倍数 */ /*line-height: 200%;*/ line-height: 2;}/* * 对于单行文本来说，可以将行高设置为和父元素的高度一致， * 这样可以是单行文本在父元素中垂直居中 */line-height: 200px;/* * 在font中也可以指定行高 * 在字体大小后可以添加/行高，来指定行高，该值是可选的，如果不指定则会使用默认值 */font: 30px \"微软雅黑\";line-height: 50px; 字体图标字体图标使用场景： 主要用于显示网页中通用、常用的一些小图标。 精灵图是有诸多优点的，但是缺点很明显。 图片文件还是比较大的。 图片本身放大和缩小会失真。 一旦图片制作完毕想要更换非常复杂。 此时，有一种技术的出现很好的解决了以上问题，就是字体图标 iconfont。 字体图标可以为前端工程师提供一种方便高效的图标使用方式，展示的是图标，本质属于字体。 使用下载 引入 文本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * text-transform可以用来设置文本的大小写 * 可选值： * none 默认值，该怎么显示就怎么显示，不做任何处理 * capitalize 单词的首字母大写，通过空格来识别单词 * uppercase 所有的字母都大写 * lowercase 所有的字母都小写 */text-transform: lowercase;/* * text-decoration可以用来设置文本的修饰 * 可选值： * none：默认值，不添加任何修饰，正常显示 * underline 为文本添加下划线 * overline 为文本添加上划线 * line-through 为文本添加删除线 */text-decoration: line-through;a {/*超链接会默认添加下划线，也就是超链接的text-decoration的默认值是underline如果需要去除超链接的下划线则需要将该样式设置为none* */ text-decoration: none;}/** * letter-spacing可以指定字符间距 *//*letter-spacing: 10px;*/ /* * word-spacing可以设置单词之间的距离 * 实际上就是设置词与词之间空格的大小 */word-spacing: 120px;/* * text-align用于设置文本的对齐方式 * 可选值： * left 默认值，文本靠左对齐 * right 文本靠右对齐 * center 文本居中对齐 * justify 两端对齐 * - 通过调整文本之间的空格的大小，来达到一个两端对齐的目的 */text-align: justify ;/* * text-indent用来设置首行缩进 * 当给它指定一个正值时，会自动向右侧缩进指定的像素 * 如果为它指定一个负值，则会向左移动指定的像素, * 通过这种方式可以将一些不想显示的文字隐藏起来 * 这个值一般都会使用em作为单位 */text-indent: -99999px; css3text-shadow: h-shadow v-shadow blur color; 盒子模型盒子可见框的大小由内容区，内边距和边框共同决定 盒子模型：就是把 HTML 页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。 CSS 盒子模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边框、外边距、内边距、和实际内容 123456789/* * 使用width来设置盒子内容区的宽度 * 使用height来设置盒子内容区的高度 * * width和height只是设置的盒子内容区的大小，而不是盒子的整个大小， * !!!盒子可见框的大小由内容区，内边距和边框共同决定 */width: 300px;height: 300px; 边框1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* * 为元素设置边框 * 要为一个元素设置边框必须指定三个样式 * border-width:边框的宽度 * border-color:边框颜色 * border-style:边框的样式 */ /* * 设置边框的宽度 */border-width:10px ; /*使用border-width可以分别指定四个边框的宽度如果在border-width指定了四个值，则四个值会分别设置给 上 右 下 左，按照顺时针的方向设置的如果指定三个值， 则三个值会分别设置给 上 左右 下如果指定两个值， 则两个值会分别设置给 上下 左右 如果指定一个值，则四边全都是该值 除了border-width，CSS中还提供了四个border-xxx-widthxxx的值可能是top right bottom left专门用来设置指定边的宽度 * */border-width:10px 20px 30px 40px ;border-width:10px 20px 30px ;border-width: 10px 20px ;border-width: 10px; border-left-width:100px ; /* * 设置边框的颜色 * 和宽度一样，color也提供四个方向的样式，可以分别指定颜色 * border-xxx-color */border-color: red;border-color: red yellow orange blue;border-color: red yellow orange;border-color: red yellow; /* * 设置边框的样式 * 可选值： * none，默认值，没有边框 * solid 实线 * dotted 点状边框 * dashed 虚线 * double 双线 * * style也可以分别指定四个边的边框样式，规则和width一致， * 同时它也提供border-xxx-style四个样式，来分别设置四个边 */border-style: double;border-style: solid dotted dashed double; /*设置边框大部分的浏览器中，边框的宽度和颜色都是有默认值，而边框的样式默认值都是none * */border-width:10px ;border-color: red;border-style: solid; /* * border * 边框的简写样式，通过它可以同时设置四个边框的样式，宽度，颜色 * 而且没有任何的顺序要求 * border一指定就是同时指定四个边不能分别指定 * border-top border-right border-bottom border-left * 可以单独设置四个边的样式，规则和border一样，只不过它只对一个边生效border : border-width || border-style || border-color */border: red solid 10px ;border-left: red solid 10px ; border-top: red solid 10px;border-bottom: red solid 10px;border-left: red solid 10px; border: red solid 10px;border-right: none;/*border-collapse 属性控制浏览器绘制表格边框的方式。它控制相邻单元格的边框。语法：border-collapse:collapse; collapse 单词是合并的意思border-collapse: collapse; 表示相邻边框合并在一起边框会额外增加盒子的实际大小。因此我们有两种方案解决:1. 测量盒子大小的时候,不量边框.2. 如果测量的时候包含了边框,则需要 width/height 减去边框宽度*/ CSS3新增的关于边框border-radius属性用于设置元素的外边框圆角。 border-radius:length; 参数值可以为数值或百分比的形式 如果是正方形，想要设置为一个圆，把数值修改为高度或者宽度的一半即可，或者直接写为 50% 该属性是一个简写属性，可以跟四个值，分别代表左上角、右上角、右下角、左下角 分开写：border-top-left-radius、border-top-right-radius、border-bottom-right-radius 和 border-bottom-left-radius 兼容性 ie9+ 浏览器支持, 但是不会影响页面布局,可以放心使用. box-shadow: h-shadow v-shadow blur spread color inset; 默认的是外阴影(outset), 但是不可以写这个单词,否则造成阴影无效 盒子阴影不占用空间，不会影响其他盒子排列。 内边距（padding）1234567891011121314151617181920212223242526272829303132333435/* * 内边距（padding），指的是盒子的内容区与盒子边框之间的距离 * 一共有四个方向的内边距，可以通过： * padding-top * padding-right * padding-bottom * padding-left * 来设置四个方向的内边距 * * 内边距会影响盒子的可见框的大小，元素的背景会延伸到内边距, * 盒子的大小由内容区、内边距和边框共同决定 * 盒子可见框的宽度 = border-left-width + padding-left + width + padding-right + border- * 可见宽的高度 = border-top-width + padding-top + height + padding-bottom + border-bott当我们给盒子指定 padding 值之后，发生了 2 件事情：1. 内容和边框有了距离，添加了内边距。2. padding影响了盒子实际大小。也就是说，如果盒子已经有了宽度和高度，此时再指定内边框，会撑大盒子。解决方案：如果保证盒子跟效果图大小保持一致，则让 width/height 减去多出来的内边距大小即可。 */ /*设置上内边距*/padding-top: 100px;/*设置右内边距*/padding-right: 100px;padding-bottom: 100px;padding-left: 100px; /* * 使用padding可以同时设置四个边框的样式，规则和border-width一致 */padding: 100px; padding: 100px 200px; padding: 100px 200px 300px; padding: 100px 200px 300px 400px; 外边距1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * 外边距指的是当前盒子与其他盒子之间的距离， * 他不会影响可见框的大小，而是会影响到盒子的位置。 * 盒子有四个方向的外边距： * margin-top * margin-right * margin-bottom * margin-left * 由于页面中的元素都是靠左靠上摆放的， * 所以注意当我们设置上和左外边距时，会导致盒子自身的位置发生改变，而如果是设置右和下外边距会改变其他盒子的位置 *//* * 设置box1的上外边距，盒子上边框和其他的盒子的距离 */margin-top: 100px; /* * 左外边距 */margin-left: 100px; /*设置右和下外边距*/margin-right: 100px;margin-bottom: 100px; /* * 外边距也可以指定为一个负值， * 如果外边距设置的是负值，则元素会向反方向移动 */margin-left: -150px;margin-top: -100px;margin-bottom: -100px;margin-bottom: -100px; /* * margin还可以设置为auto，auto一般只设置给水平方向的margin * 如果只指定，左外边距或右外边距的margin为auto则会将外边距设置为最大值 * 垂直方向外边距如果设置为auto，则外边距默认就是0 * 如果将left和right同时设置为auto，则会将两侧的外边距设置为相同的值， * 就可以使元素自动在父元素中居中，所以我们经常将左右外边距设置为auto * 以使子元素在父元素中水平居中 */margin-left: auto;margin-right: auto; /* * 外边距同样可以使用简写属性 margin，可以同时设置四个方向的外边距, * 规则和padding一样 */margin: 0 auto; 垂直外边距的重叠 简单来说就是： 相邻块元素垂直外边距的合并 当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距 margin-bottom，下面的元素有 上外边距 margin-top ，则他们之间的垂直间距不是 margin-bottom 与 margin-top 之和。取两个值中的 较大者这种现象被称为相邻块元素垂直外边距的合并。 解决方案： 尽量只给一个盒子添加 margin 值。 嵌套块元素垂直外边距的塌陷 对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。 解决方案： 可以为父元素定义上边框。 以为父元素定义上内边距。 可以为父元素添加 overflow:hidden 还有其他方法，比如浮动、固定，绝对定位的盒子不会有塌陷问题，后面咱们再总结。 内联元素的盒子12345678910111213141516171819202122232425262728293031323334353637383940414243/* 内容区、内边距 、边框 、外边距 * */ /* * 内联元素不能设置width和height */width: 200px;height: 200px; /* * 设置水平内边距,内联元素可以设置水平方向的内边距 */padding-left: 100px ;padding-right: 100px ; /* * 垂直方向内边距，内联元素可以设置垂直方向内边距，但是不会影响页面的布局 */padding-top: 50px;padding-bottom: 50px; /* * 为元素设置边框, * 内联元素可以设置边框，但是垂直的边框不会影响到页面的布局 */border: 1px blue solid; /* * 水平外边距 * 内联元素支持水平方向的外边距 */margin-left:100px ;margin-right: 100px; /* * 内联元素不支持垂直外边距 */margin-top: 200px;margin-bottom: 200px; /* * 设置一个左外边距 * 水平方向的相邻外边距不会重叠，而是求和 */margin-left: 100px; display&amp;visibility&amp;opacity123456789101112/* * 将一个内联元素变成块元素， * 通过display样式可以修改元素的类型 * 可选值： * inline：可以将一个元素作为内联元素显示 * block: 可以将一个元素设置块元素显示 * inline-block：将一个元素转换为行内块元素 * - 可以使一个元素既有行内元素的特点又有块元素的特点 * 既可以设置宽高，又不会独占一行 * none: 不显示元素，并且元素不会在页面中继续占有位置 */display: none; 123456789/* * visibility * - 可以用来设置元素的隐藏和显示的状态 * - 可选值： * visible 默认值，元素默认会在页面显示 * hidden 元素会隐藏不显示 * 使用 visibility:hidden;隐藏的元素虽然不会在页面中显示，但是它的位置会依然保持 */visibility:hidden ; 123456789101112131415161718192021/* * 设置元素的透明背景 * opacity可以用来设置元素背景的透明， * 它需要一个0-1之间的值 * 0 表示完全透明 * 1 表示完全不透明 * 0.5 表示半透明 */opacity: 0.5; /* * opacity属性在IE8及以下的浏览器中不支持 * IE8及以下的浏览器需要使用如下属性代替 * alpha(opacity=透明度) * 透明度，需要一个0-100之间的值 * 0 表示完全透明 * 100 表示完全不透明 * 50 半透明 * 这种方式支持IE6，但是这种效果在IE Tester中无法测试 */filter: alpha(opacity=50); overflow1234567891011121314151617/* * 子元素默认是存在于父元素的内容区中， * 理论上讲子元素的最大可以等于父元素内容区大小 * 如果子元素的大小超过了父元素的内容区，则超过的大小会在父元素以外的位置显示， * 超出父元素的内容，我们称为溢出的内容 * 父元素默认是将溢出内容，在父元素外边显示， * 通过overflow可以设置父元素如何处理溢出内容： * 可选值： * - visible，默认值，不会对溢出内容做处理，元素会在父元素以外的位置显示 * - hidden, 溢出的内容，会被修剪，不会显示 * - scroll, 会为父元素添加滚动条，通过拖动滚动条来查看完整内容。该属性不论内容是否溢出，都会添加水平和垂直双方向的滚动条 * - auto，会根据需求自动添加滚动条， * 需要水平就添加水平 * 需要垂直就添加垂直 * 都不需要就都不加 */overflow: auto; 文档流1234567891011121314151617181920212223242526&lt;!-- 文档流文档流处在网页的最底层，它表示的是一个页面中的位置，我们所创建的元素默认都处在文档流中。元素在文档流中的特点 块元素 1.块元素在文档流中会独占一行，块元素会自上向下排列。 2.块元素在文档流中默认宽度是父元素的100% 3.块元素在文档流中的高度默认被内容撑开 内联元素 1.内联元素在文档流中只占自身的大小，会默认从左向右排列，如果一行中不足以容纳所有的内联元素，则换到下一行，继续自左向右。 2.在文档流中，内联元素的宽度和高度默认都被内容撑开 --&gt; &lt;!-- 当元素的宽度的值为auto时，此时指定内边距不会影响可见框的大小，而是会自动修改宽度，以适应内边距。--&gt;&lt;div style=\"background-color: #bfa;\"&gt; &lt;div style=\"height: 50px;\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=\"width: 100px; height: 100px; background-color: #ff0;\"&gt;&lt;/div&gt; &lt;span style=\"background-color: yellowgreen;\"&gt;我是一个span&lt;/span&gt;&lt;span style=\"background-color: yellowgreen;\"&gt;我是一个span&lt;/span&gt;&lt;span style=\"background-color: yellowgreen;\"&gt;我是一个span&lt;/span&gt;&lt;span style=\"background-color: yellowgreen;\"&gt;我是一个span&lt;/span&gt;&lt;span style=\"background-color: yellowgreen;\"&gt;我是一个span&lt;/span&gt;&lt;span style=\"background-color: yellowgreen;\"&gt;我是一个span&lt;/span&gt; 浮动网页布局的本质——用 CSS 来摆放盒子。 把盒子摆放到相应位置. CSS 提供了三种传统布局方式(简单说,就是盒子如何进行排列顺序)：普通流（标准流）浮动 定位 为什么需要浮动？ 虽然转换为行内块元素可以实现一行显示，但是他们之间会有大的空白缝隙，很难控制。 有很多的布局效果，标准流没有办法完成，此时就可以利用浮动完成布局。 因为浮动可以改变元素标 签默认的排列方式. 浮动最典型的应用：可以让多个块级元素一行内排列显示。 网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动。 浮动特性: 浮动元素会脱离标准流(脱标) 浮动的元素会一行内显示并且元素顶部对齐 浮动的元素会具有行内块元素的特性. 设置了浮动（float）的元素最重要特性： 脱离标准普通流的控制（浮） 移动到指定位置（动）, （俗称脱标） 浮动的盒子不再保留原先的位置 任何元素都可以浮动。不管原先是什么模式的元素，添加浮动之后具有行内块元素相似的特性。 如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动后，它的大小根据内容来决定 浮动的盒子中间是没有缝隙的，是紧挨着一起的 行内元素同理 1234567891011/* * 块元素在文档流中默认垂直排列，所以这个三个div自上至下依次排开， * 如果希望块元素在页面中水平排列，可以使块元素脱离文档流 * 使用float来使元素浮动，从而脱离文档流 * 可选值： * none，默认值，元素默认在文档流中排列 * left，元素会立即脱离文档流，向页面的左侧浮动 * right，元素会立即脱离文档流，向页面的右侧浮动 * 当为一个元素设置浮动以后（float属性是一个非none的值）， */float: left; 浮动的元素不会盖住文字，文字会自动环绕在浮动元素的周围，所以我们可以通过浮动来设置文字环绕图片的效果。 内联元素脱离文档流以后会变成块元素。 清除浮动、高度塌陷由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会 影响下面的标准流盒子。 由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响。 清除浮动的本质 是清除浮动元素造成的影响 如果父盒子本身有高度，则不需要清除浮动 清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了 选择器{clear:属性值;} 我们实际工作中， 几乎只用 clear: both; 清除浮动的策略是: 闭合浮动. 其他方法在文档流中，父元素的高度默认是被子元素撑开的，也就是子元素多高，父元素就多高。但是当为子元素设置浮动以后，子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，这样将会导致页面布局混乱。所以在开发中一定要避免出现高度塌陷的问题,我们可以将父元素的高度写死，以避免塌陷的问题出现，但是一旦高度写死，父元素的高度将不能自动适应子元素的高度，所以这种方案是不推荐使用的。 根据W3C的标准，在页面中元素都一个隐含的属性叫做Block Formatting Context,简称BFC，该属性可以设置打开或者关闭，默认是关闭的。 当开启元素的BFC以后，元素将会具有如下的特性： 1.父元素的垂直外边距不会和子元素重叠 2.开启BFC的元素不会被浮动元素所覆盖 3.开启BFC的元素可以包含浮动的子元素 如何开启元素的BFC 1.设置元素浮动 使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失而且使用这种方式也会导致下边的元素上移，不能解决问题 2.设置元素绝对定位 3.设置元素为inline-block 可以解决问题，但是会导致宽度丢失，不推荐使用这种方式 4.将元素的overflow设置为一个非visible的值 推荐方式：将overflow设置为hidden是副作用最小的开启BFC的方式。 overflow: hidden; 但是在IE6及以下的浏览器中并不支持BFC，所以使用这种方式不能兼容IE6。在IE6中虽然没有BFC，但是具有另一个隐含的属性叫做hasLayout，该属性的作用和BFC类似，所在IE6浏览器可以通过开hasLayout来解决该问题开启方式很多，我们直接使用一种副作用最小的：直接将元素的zoom设置为1即可。 zoom表示放大的意思，后边跟着一个数值，写几就将元素放大几倍。zoom:1表示不放大元素，但是通过该样式可以开启hasLayout。zoom这个样式，只在IE中支持，其他浏览器都不支持。 12zoom:1;overflow: hidden; 最终办法 12345678910111213141516171819202122232425262728293031323334353637/*通过after伪类，选中box1的后边*//* * 可以通过after伪类向元素的最后添加一个空白的块元素，然后对其清除浮动， * 这样做和添加一个div的原理一样，可以达到一个相同的效果， * 而且不会在页面中添加多余的div，这是我们最推荐使用的方式，几乎没有副作用 */.clearfix:after{ /*添加一个内容*/ content: \"\"; /*转换为一个块元素*/ display: block; /*清除两侧的浮动*/ clear: both;} /* * 在IE6中不支持after伪类, * 所以在IE6中还需要使用hasLayout来处理 */.clearfix{ zoom:1;}/* * 经过修改后的clearfix是一个多功能的 * 既可以解决高度塌陷，又可以确保父元素和子元素的垂直外边距不会重叠 */.clearfix:before,.clearfix:after{ content: \"\"; display: table; clear: both;} .clearfix{ zoom: 1;}style&gt; 框架集123456789101112131415161718192021222324252627282930&lt;!-- 框架集和内联框架的作用类似，都是用于在一个页面中引入其他的外部的页面， 框架集可以同时引入多个页面，而内联框架只能引入一个， 在h5标准中，推荐使用框架集，而不使用内联框架 使用frameset来创建一个框架集，注意frameset不能和body出现在同一个页面中 所以要使用框架集，页面中就不可以使用body标签 属性： rows，指定框架集中的所有的框架，一行一行的排列 cols， 指定框架集中的所有的页面，一列一列的排列 这两个属性frameset必须选择一个，并且需要在属性中指定每一部分所占的大小 frameset中也可以再嵌套frameset frameset和iframe一样，它里边的内容都不会被搜索引擎所检索， 所以如果搜索引擎检索到的页面是一个框架页的话，它是不能去判断里边的内容的 使用框架集则意味着页面中不能有自己的内容，只能引入其他的页面，而我们每单独加载一个页面 浏览器都需要重新发送一次请求，引入几个页面就需要发送几次请求，用户的体验比较差 如果非得用建议使用frameset而不使用iframe --&gt;&lt;frameset cols=\"30% , * , 30%\"&gt; &lt;!-- 在frameset中使用frame子标签来指定要引入的页面 引入几个页面就写几个frame --&gt; &lt;frame src=\"01.表格.html\" /&gt; &lt;frame src=\"02.表格.html\" /&gt; &lt;!-- 嵌套一个frameset --&gt; &lt;frameset rows=\"30%,50%,*\"&gt; &lt;frame src=\"04.表格的布局.html\" /&gt; &lt;frame src=\"05.完善clearfix.html\" /&gt; &lt;frame src=\"06.表单.html\" /&gt; &lt;/frameset&gt;&lt;/frameset&gt; 定位定位指的就是将指定的元素摆放到页面的任意位置通过定位可以任意的摆放元素 当开启了元素的定位（position属性值是一个非static的值）时，可以通过left right top bottom四个属性来设置元素的偏移量 left：元素相对于其定位位置的左侧偏移量 right：元素相对于其定位位置的右侧偏移量 top：元素相对于其定位位置的上边的偏移量 bottom：元素相对于其定位位置下边的偏移量通常偏移量只需要使用两个就可以对一个元素进行定位，一般选择水平方向的一个偏移量和垂直方向的偏移量来为一个元素进行定位 通过position属性来设置元素的定位可选值： static：默认值，元素没有开启定位 relative：开启元素的相对定位 absolute：开启元素的绝对定位 fixed：开启元素的固定定位（也是绝对定位的一种） 相对定位当元素的position属性设置为relative时，则开启了元素的相对定位1.当开启了元素的相对定位以后，而不设置偏移量时，元素不会发生任何变化2.相对定位是相对于元素在文档流中原来的位置进行定位3.相对定位的元素不会脱离文档流4.相对定位会使元素提升一个层级5.相对定位不会改变元素的性质，块还是块，内联还是内联 绝对定位当position属性值设置为absolute时，则开启了元素的绝对定位绝对定位： 1.开启绝对定位，会使元素脱离文档流 2.开启绝对定位以后，如果不设置偏移量，则元素的位置不会发生变化 3.绝对定位是相对于离他最近的开启了定位的祖先元素进行定位的（一般情况，开启了子元素的绝对定位都如果所有的祖先元素都没有开启定位，则会相对于浏览器窗口进行定位） 4.绝对定位会使元素提升一个层级 5.绝对定位会改变元素的性质，内联元素变成块元素，块元素的宽度和高度默认都被内容撑开。 固定定位当元素的position属性设置fixed时，则开启了元素的固定定位，固定定位也是一种绝对定位，它的大部分特点都和绝对定位一样，不同的是： 固定定位永远都会相对于浏览器窗口进行定位 固定定位会固定在浏览器窗口某个位置，不会随滚动条滚动IE6不支持固定定位 层级123456789/* * 如果定位元素的层级是一样，则下边的元素会盖住上边的 * 通过z-index属性可以用来设置元素的层级 * 可以为z-index指定一个正整数作为值，该值将会作为当前元素的层级 * 层级越高，越优先显示 * * 对于没有开启定位的元素不能使用z-index */z-index: 25; 背景123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* * 使用background-image来设置背景图片 * - 语法：background-image:url(相对路径); * * - 如果背景图片大于元素，默认会显示图片的左上角 * - 如果背景图片和元素一样大，则会将背景图片全部显示 * - 如果背景图片小于元素大小，则会默认将背景图片平铺以充满元素 * * 可以同时为一个元素指定背景颜色和背景图片， * 这样背景颜色将会作为背景图片的底色 * 一般情况下设置背景图片时都会同时指定一个背景颜色 */background-image:url(img/1.png); /* * background-repeat用于设置背景图片的重复方式 * 可选值： * repeat，默认值，背景图片会双方向重复（平铺） * no-repeat ，背景图片不会重复，有多大就显示多大 * repeat-x， 背景图片沿水平方向重复 * repeat-y，背景图片沿垂直方向重复 */background-repeat: repeat-y;/* * 设置一个背景颜色 */background-color: #bfa;/* * 背景图片默认是贴着元素的左上角显示 * 通过background-position可以调整背景图片在元素中的位置 * 可选值： * 该属性可以使用 top right left bottom center中的两个值 * 来指定一个背景图片的位置 * top left 左上 * bottom right 右下 * 如果只给出一个值，则第二个值默认是center * * 也可以直接指定两个偏移量， * 第一个值是水平偏移量 * - 如果指定的是一个正值，则图片会向右移动指定的像素 * - 如果指定的是一个负值，则图片会向左移动指定的像素 * 第二个是垂直偏移量 * - 如果指定的是一个正值，则图片会向下移动指定的像素 * - 如果指定的是一个负值，则图片会向上移动指定的像素 * */background-position: -80px -40px;/* * 当背景图片的background-attachment设置为fixed时， * 背景图片的定位永远相对于浏览器的窗口 */background-attachment: fixed;/* * background * - 通过该属性可以同时设置所有背景相关的样式 * - 没有顺序的要求，谁在前睡在后都行 * 也没有数量的要求，不写的样式就使用默认值 */background: #bfa url(img/3.png) center center no-repeat fixed; 表格表格在日常生活中使用的非常的多，比如excel就是专门用来创建表格的工具，表格就是用来表示一些格式化的数据的，比如：课程表、银行对账单。在网页中也可以来创建出不同的表格。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!-- 在HTML中，使用table标签来创建一个表格--&gt;&lt;table border=\"1\" width=\"40%\" align=\"center\"&gt;&lt;!-- 在table标签中使用tr来表示表格中的一行，有几行就有几个tr--&gt;&lt;tr&gt; &lt;!-- 在tr中需要使用td来创建一个单元格，有几个单元格就有几个td --&gt; &lt;td&gt;A1&lt;/td&gt; &lt;td&gt;A2&lt;/td&gt; &lt;td&gt;A3&lt;/td&gt; &lt;td&gt;A4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;!-- 可以使用th标签来表示表头中的内容， 它的用法和td一样，不同的是它会有一些默认效果 --&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;住址&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;B1&lt;/td&gt; &lt;td&gt;B2&lt;/td&gt; &lt;td&gt;B3&lt;/td&gt; &lt;!-- rowspan用来设置纵向的合并单元格 --&gt; &lt;td rowspan=\"2\"&gt;B4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;C1&lt;/td&gt; &lt;td&gt;C2&lt;/td&gt; &lt;td&gt;C3&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;D1&lt;/td&gt; &lt;td&gt;D2&lt;/td&gt; &lt;!-- colspan横向的合并单元格 --&gt; &lt;td colspan=\"2\"&gt;D3&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* * 设置表格的宽度 */table{ width: 300px; /*居中*/ margin: 0 auto; /*边框*/ /*border:1px solid black;*/ /* * table和td边框之间默认有一个距离 * 通过border-spacing属性可以设置这个距离 */ /*border-spacing:0px ;*/ /* * border-collapse可以用来设置表格的边框合并 * 如果设置了边框合并，则border-spacing自动失效 */ border-collapse: collapse; /*设置背景样式*/ /*background-color: #bfa;*/} /* * 设置边框 */td , th{ border: 1px solid black;} /* * 设置隔行变色 */tr:nth-child(even){ background-color: #bfa;} /* * 鼠标移入到tr以后，改变颜色 */tr:hover{ background-color: #ff0;} 长表格 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;table&gt; &lt;!-- 有一些情况下表格是非常的长的， 这时就需要将表格分为三个部分，表 在HTML中为我们提供了三个标签： thead 表头 tbody 表格主体 tfoot 表格底部 这三个标签的作用，就来区分表格的不 都需要直接写到table中，tr需要写 thead中的内容，永远会显示在表格的 tfoot中的内容，永远都会显示表格的 tbody中的内容，永远都会显示表格的 如果表格中没有写tbody，浏览器会自 并且将所有的tr都放到tbody中，所以 通过table &gt; tr 无法选中行 需要通过 --&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;日期&lt;/th&gt; &lt;th&gt;收入&lt;/th&gt; &lt;th&gt;支出&lt;/th&gt; &lt;th&gt;合计&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;合计&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;10.24&lt;/td&gt; &lt;td&gt;500&lt;/td&gt; &lt;td&gt;300&lt;/td&gt; &lt;td&gt;200&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;10.24&lt;/td&gt; &lt;td&gt;500&lt;/td&gt; &lt;td&gt;300&lt;/td&gt; &lt;td&gt;200&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 表格布局123456789101112131415161718192021222324252627&lt;!-- 以前表格更多的情况实际上是用来对页面进行布局的，但是这种方式早已被CSS所淘汰了 表格的列数由td最多的那行决定 表格是可以嵌套，可以在td中在放置一个表格--&gt; &lt;table border=\"1\" width=\"100%\"&gt; &lt;tr height=\"100px\"&gt; &lt;td colspan=\"2\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=\"400px\"&gt; &lt;td width=\"20%\"&gt;&lt;/td&gt; &lt;td width=\"80%\"&gt; &lt;table border=\"1\" width=\"100%\" height=\"100%\"&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr height=\"100px\"&gt; &lt;td colspan=\"2\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; Flex布局菜鸟 阮一峰练手 采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 以下6个属性设置在容器上。 flex-direction row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 nowrap:不换行 wrap:换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flow flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 1flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;; justify-content align-items align-items属性定义项目在交叉轴上如何对齐。 align-content align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 以下6个属性设置在项目上。 order 定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 flex-basis 定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flex flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 1flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ] align-self 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 1align-self: auto | flex-start | flex-end | center | baseline | stretch; 除了auto，其他都与align-items属性完全一致。 CSS3动画 使用CSS3技术来控制页面元素CSS属性的变化 不需要js也能写 由浏览器执行，更加流畅 减少代码量 应用场景 网页特效 用户交互 抽奖动画 网页小游戏 transition transition-property 指定应用过渡属性的名称1234567div{ transition-property:width 2s; width:100px;}div:hover{ width:200px;} 避免使用transition时所有元素都加入动画。 transition-delay 延迟动画的时间transform转换transform是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、缩放等效果。 移动：translate 旋转：rotate 缩放：scale transform 2D transform-origin: 转换中心点 transform-origin: x y; 注意后面的参数 x 和 y 用空格隔开 x y 默认转换的中心点是元素的中心点 (50% 50%) 还可以给x y 设置 像素 或者 方位名词 （top bottom left right center） translate： transform: translate(x,y); 或者分开写 transform: translateX(n); transform: translateY(n); 定义 2D 转换中的移动，沿着 X 和 Y 轴移动元素 translate最大的优点：不会影响到其他元素的位置 translate中的百分比单位是相对于自身元素的 translate:(50%,50%); 对行内标签没有效果 rotate： transform:rotate(度数) rotate里面跟度数， 单位是 deg 比如 rotate(45deg) 角度为正时，顺时针，负时，为逆时针 默认旋转的中心点是元素的中心点 scale： transform:scale(x,y); 注意其中的x和y用逗号分隔 transform:scale(1,1) ：宽和高都放大一倍，相对于没有放大 transform:scale(2,2) ：宽和高都放大了2倍 transform:scale(2) ：只写一个参数，第二个参数则和第一个参数一样，相当于 scale(2,2) transform:scale(0.5,0.5)：缩小 sacle缩放最大的优势：可以设置转换中心点缩放，默认以中心点缩放的，而且不影响其他盒子 注意： 同时使用多个转换，其格式为：transform: translate() rotate() scale() ...等， 其顺序会影转换的效果。（先旋转会改变坐标轴方向） 当我们同时有位移和其他属性的时候，记得要将位移放到最前 transform 3D translate3d: 3D移动在2D移动的基础上多加了一个可以移动的方向，就是z轴方向。 translform:translateX(100px)：仅仅是在x轴上移 translform:translateY(100px)：仅仅是在Y轴上移动 translform:translateZ(100px)：仅仅是在Z轴上移动（注意：translateZ一般用px单位） transform:translate3d(x,y,z)：其中 x、y、z 分别指要移动的轴的方向的距离 因为z轴是垂直屏幕，由里指向外面，所以默认是看不到元素在z轴的方向上移动。 perspective: translform:translateZ(100px)：仅仅是在Z轴上移动。有了透视，就能看到translateZ 引起的变化了 rotate3d: 3D旋转指可以让元素在三维平面内沿着 x轴，y轴，z轴或者自定义轴进行旋转。 transform:rotateX(45deg)：沿着x轴正方向旋转 45度 transform:rotateY(45deg) ：沿着y轴正方向旋转 45deg transform:rotateZ(45deg) ：沿着Z轴正方向旋转 45deg transform:rotate3d(x,y,z,deg)： 沿着自定义轴旋转 deg为角度（了解即可）xyz是表示旋转轴的矢量，是标示你是否希望沿着该轴旋转，最后一个标示旋转的角度。transform:rotate3d(1,1,0,45deg) 就是沿着对角线旋转 45deg transfrom-style: 控制子元素是否开启三维立体环境。 transform-style: flat; 子元素不开启3d立体空间 默认的 ltransform-style: preserve-3d; 子元素开启立体空间 代码写给父级，但是影响的是子盒子。这个属性很重要，后面必用。 动画（animation）是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。 相比较过渡，动画可以实现更多变化，更多控制，连续自动播放等效果。 用keyframes定义动画12345678@keyframes 动画名称 { 0%{ width:100px; } 100%{ width:200px; }} 0% 是动画的开始，100% 是动画的完成。这样的规则就是动画序列。 在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。 动画是使元素从一种样式逐渐变化为另一种样式的效果。您可以改变任意多的样式任意多的次数。 请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。 使用动画1234/* 调用动画 */animation-name: 动画名称;/* 持续时间 */animation-duration: 持续时间; animation：动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或者结束的状态; 简写属性里面不包含 animation-play-state 暂停动画：animation-play-state: puased; 经常和鼠标经过等其他配合使用 想要动画走回来 ，而不是直接跳回来：animation-direction:alternate; 盒子动画结束后，停在结束位置： animation-fill-mode:forwards; animation-timing-function： 规定动画的速度曲线，默认是“ease” 旋转木马案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body{ perspective: 1000px; } section{ position: relative; height: 200px; width: 300px; margin: 200px auto; transform-style: preserve-3d; animation: rota 0.5s linear infinite; } section:hover{ animation-play-state: paused; } @keyframes rota { 0%{ transform:rotateY(0) ; } 100%{ transform: rotateY(360deg); } } section div{ position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: url('http://pic0.iqiyipic.com/common/lego/20200209/ccc614312b7048f19408192c91a8ecf9.jpg') no-repeat ; } section div:nth-child(1){ transform: translateZ(300px); } section div:nth-child(2){ transform: rotateY(60deg) translateZ(300px); } section div:nth-child(3){ transform: rotateY(120deg) translateZ(300px); } section div:nth-child(4){ transform: rotateY(180deg) translateZ(300px); } section div:nth-child(5){ transform: rotateY(240deg) translateZ(300px); } section div:nth-child(6){ transform: rotateY(300deg) translateZ(300px); } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 技巧及零碎知识点 提高幸福感的 9 个 CSS 技巧 掘金 总结： 建议使用 padding 代替 margin，所有毗邻的两个或多个盒元素的 margin 将会合并为一个 margin 共享。 毗邻的定义为：同级或者嵌套的盒元素，并且它们之间没有非空内容、Padding 或 Border 分隔。 文字超出省略、文字两端对齐 1234567891011121314// html两端对齐&lt;div&gt;姓名&lt;/div&gt;&lt;div&gt;手机号码&lt;/div&gt;&lt;div&gt;账号&lt;/div&gt;&lt;div&gt;密码&lt;/div&gt;// cssdiv { margin: 10px 0; width: 100px; border: 1px solid red; text-align: justify; text-align-last:justify}","link":"/2020/05/16/%E5%A4%A7%E5%89%8D%E7%AB%AF/CSS/"},{"title":"Linux 命令总结","text":"一些shell命令整理&amp;linux整体学习 linux的目录结构打开终端，输入ls查看linux根目录下的情况 123$ ls /----------------bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var /bin (/usr/bin /usr/local/bin ) 是Binary的缩写, 这个目录存放着最经常使用的命令 /sbin (/usr/sbin 、 /usr/local/sbin)s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序 /home存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /root该目录为系统管理员，也称作超级权限者的用户主目录。 /lib 系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /etc 所有的系统管理所需要的配置文件和子目录。 /usr 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。 /boot 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件，自己的安装别放这里 /proc 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。 /srv service缩写，该目录存放一些服务启动之后需要提取的数据。 /sys 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。 /tmp 这个目录是用来存放一些临时文件的。 /dev 类似于windows的设备管理器，把所有的硬件用文件的形式存储，在linux中一切皆文件。 /media linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了，比如你挂载的其他硬盘或者u盘等 /opt 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。hadoop就可以安装在此 /usr/local 这是另一个给主机额外安装软件所摆放的目录。一般是通过编译源码方式安装的程序。 /var 这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /selinux SELinux是一种安全子系统,它能控制程序只能访问特定文件。 环境变量输入echo $SHELL后，我的电脑显示bash，说明是Bourne Shell的一个变种，可以把你要添加的环境变量添加到你主目录下面的.profile或者.bash_profile，如果存在没有关系添加进去即可，如果没有生成一个。 Mac配置环境变量的地方 1./etc/profile （建议不修改这个文件 ）全局（公有）配置，不管是哪个用户，登录时都会读取该文件。 2./etc/bashrc （一般在这个文件中添加系统级环境变量）全局（公有）配置，bash shell执行时，不管是何种方式，都会读取此文件。 3.~/.bash_profile （一般在这个文件中添加用户级环境变量）每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次! Mac系统的环境变量，加载顺序为：a. /etc/profileb. /etc/pathsc. ~/.bash_profiled. ~/.bash_logine. ~/.profilef. ~/.bashrc 其中a和b是系统级别的，系统启动就会加载，其余是用户接别的。c,d,e按照从前往后的顺序读取，如果c文件存在，则后面的几个文件就会被忽略不读了，以此类推。~/.bashrc没有上述规则，它是bash shell打开的时候载入的。这里建议在c中添加环境变量，以下也是以在c中添加环境变量来演示的。 MAC 修改host文件sudo vi /etc/hosts 查看环境变量$PATH``` 需要在名字前加上$，如echo $HOME，还能 ls $HOME123```shellenv 1printenv 后面加上具体的名字可以查看单个变量，如printenv HOME 添加环境变量12345echo $mymy=helloecho $my #hello my、=、hello中间不能有空格,若赋予的字符串有空格，需要 my=”hello wo” 若要把一个临时变量变成全局变量 1export 变量名(前面不需要$) 同时注意，子shell无法使用export改变父shell中全局环境变量的值 删除环境变量1unset 变量名（也不用加$） 当操作变量时不需要加$,用到变量时则要加，唯一例外就是printenv （不需要加） 添加的path格式PATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:——:中间用冒号隔开 $PATH指的是整个path语句，所以上述命令加上：《path》即在后面追加 比如export PATH=/opt/STM/STLinux-2.3/devkit/sh4/bin:$PATH 想立即生效请运行：# source /etc/profile 不报错则成功 flutter例子中，我用了用户变量，生效运行 source $HOME/.bash_profile 注意Mac 系统，如果只在终端使用 export 这个命令写入环境变量，它配置的只是临时变量，不能长期保存，电脑开关机后或重新打开终端或另开一个窗口，仍然会回到没有配置环境变量的状态。 文件权限命令权限介绍当执行ls -l 或 ls -al 命令后显示的结果中，最前面的第2～10个字符是用来表示权限。第一个字符一般用来区分文件和目录： d：表示是一个目录，事实上在ext2fs中，目录是一个特殊的文件。 －：表示这是一个普通的文件。 l: 表示这是一个符号链接文件，实际上它指向另一个文件。 b、c：分别表示区块设备和其他的外围设备，是特殊类型的文件。 s、p：这些文件关系到系统的数据结构和管道，通常很少见到。 第2～10个字符当中的每3个为一组，左边三个字符表示所有者权限，中间3个字符表示与所有者同一组的用户的权限，右边3个字符是其他用户的权限。这三个一组共9个字符，代表的意义如下： r(Read，读取)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权 w(Write,写入)：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。** x(eXecute，执行)：对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。 －：表示不具有该项权限。下面举例说明： －rwx——: 文件所有者对文件具有读取、写入和执行的权限。-rwxr―r–: 文件所有者具有读、写与执行的权限，其他用户则具有读取的权限。-rw-rw-r-x: 文件所有者与同组用户对文件具有读写的权限，而其他用户仅具有读取和执行的权限。drwx–x–x: 目录所有者具有读写与进入目录的权限,其他用户近能进入该目录，却无法读取任何数据。Drwx——: 除了目录所有者具有完整的权限之外，其他用户对该目录完全没有任何权限。 还有所谓的特殊权限。由于特殊权限会拥有一些“特权”，因而用户若无特殊需求，不应该启用这些权限，避免安全方面出现严重漏洞，造成黑客入侵，甚至摧毁系统!!! s或S（SUID,Set UID）：可执行的文件搭配这个权限，便能得到特权，任意存取该文件的所有者能使用的全部系统资源。请注意具备SUID权限的文件，黑客经常利用这种权限，以SUID配上root帐号拥有者，无声无息地在系统中开扇后门，供日后进出使用。 s或S（SGID，Set GID）：设置在文件上面，其效果与SUID相同，只不过将文件所有者换成用户组，该文件就可以任意存取整个用户组所能使用的系统资源。 T或T（Sticky）：/tmp和 /var/tmp目录供所有用户暂时存取文件，亦即每位用户皆拥有完整的权限进入该目录，去浏览、删除和移动文件。 因为SUID、SGID、Sticky占用x的位置来表示，所以在表示上会有大小写之分。加入同时开启执行权限和SUID、SGID、Sticky，则权限表示字符是小写的： -rwsr-sr-t 1 root root 4096 6月 23 08：17 conf 如果关闭执行权限，则表示字符会变成大写： -rwSr-Sr-T 1 root root 4096 6月 23 08：17 conf 文件基本属性介绍，如图所示： （1）如果查看到是文件：链接数指的是硬链接个数。创建硬链接方法 12$ ln [原文件] [目标文件] [root@hadoop101 ~]# ln xiyou/dssz/houge.txt ./hg.txt （2）如果查看的是文件夹：链接数指的是子文件夹个数。 1234567[root@hadoop101 ~]# ls -al xiyou/--------------------------总用量 16drwxr-xr-x. 4 root root 4096 1月 12 14:00 .dr-xr-x---. 29 root root 4096 1月 12 14:32 ..drwxr-xr-x. 2 root root 4096 1月 12 14:30 dsszdrwxr-xr-x. 2 root root 4096 1月 12 14:04 mingjie chmod 改变权限123456chmod [ugoa][+-=][rwx] [-R] 文件名或目录/chmod nnn [-R] 文件名或目录名第一个n: 属主的权限值第二个n：属组的权限值第三个n：其它用户的权限值 简单的八进制格式：chmod 760 newfile 复杂的符号模式 1[ugoa...][[+-=][rwxX]...][,...] 其中： u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 + 表示增加权限、- 表示移除权限、= 表示等于左边的权限。 r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。t保留文件目录，s运行时重新设置uid或gid，u权限设置和属主一样，g权限设置和属组一样，o权限设置和其他用户一样 其他参数说明： -c : 若该文件权限确实已经更改，才显示其更改动作 -f : 若该文件权限无法被更改也不要显示错误讯息 -v : 显示权限变更的详细资料 -R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更) –help : 显示辅助说明 –version : 显示版本 案例（1）修改文件使其所属主用户具有执行权限 12[root@hadoop101 ~]# cp xiyou/dssz/houge.txt ./[root@hadoop101 ~]# chmod u+x houge.txt （2）修改文件使其所属组用户具有执行权限 1[root@hadoop101 ~]# chmod g+x houge.txt （3）修改文件所属主用户执行权限,并使其他用户具有执行权限 1[root@hadoop101 ~]# chmod u-x,o+x houge.txt （4）采用数字的方式，设置文件所有者、所属组、其他用户都具有可读可写可执行权限。 1[root@hadoop101 ~]# chmod 777 houge.txt （5）修改整个文件夹里面的所有文件的所有者、所属组、其他用户都具有可读可写可执行权限。 1[root@hadoop101 ~]# chmod -R 777 xiyou/ —修改当前目录下文件ana.cfg的权限为属主读写执行，属组读写，其它用户为读chmod u+x,g=rw,o=r ana.cfg–修改当前目录下文件ana.cfg的权限所有用户都为读写chmod a=rw ana.cfg—递归修改当前目录下aaa目录以及子目录子文件的权限都为所有用户读写执行chmod -R a=rwx aaa 读： 4写： 2执行： 1 读写执行：4+2+1=7读写： 4+2=6—递归修改当前目录下aaa目录以及子目录子文件的权限都为所有用户读写执行chmod -R 777 aaa—修改当前目录下文件ana.cfg的权限为属主读写执行，属组读写，其它用户为读chmod 764 ana.cfg chown 改变文件/目录属主12345chown [-cfhvR] [--help] [--version] user[:group] file...常用： chown 属主 [-R] 文件或目录 chown :属组 [-R] 文件或目录 chown 属主:属组 [-R] 文件或目录 参数 : user : 新的文件拥有者的使用者 ID group : 新的文件拥有者的使用者组(group) -c : 显示更改的部分的信息 -f : 忽略错误信息 -h :修复符号链接 -v : 显示详细的处理信息 -R : 处理指定目录以及其子目录下的所有文件 –help : 显示辅助说明 –version : 显示版本 只有root能改变文件的属主，任何属主都能改变文件的属组，只要属主使原属组和目标属组的成员 案例（1）修改文件所有者 1234[root@hadoop101 ~]# chown neuedu houge.txt [root@hadoop101 ~]# ls -al----------------------------rwxrwxrwx. 1 neuedu root 551 5月 23 13:02 houge.txt （2）递归改变文件所有者和所有组 12345678[root@hadoop101 xiyou]# ll---------------------------------------drwxrwxrwx. 2 root root 4096 9月 3 21:20 xiyou----------------------------------------[root@hadoop101 xiyou]# chown -R neuedu:neuedu xiyou/[root@hadoop101 xiyou]# ll-----------------------------------------------------drwxrwxrwx. 2 neuedu neuedu 4096 9月 3 21:20 xiyou —修改当前目录ana.cfg 属主为test2, 属组为neusoftchown test2:neusoft ana.cfg-修改当前目录下的aaa目录以及子目录子文件的属主为test2, 属组为neusoftchown test2:neusoft -R aaa chgrp 改变文件/目录属组在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。 语法 12$ chgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference=&lt;参考文件或目录&gt;][--version][文件或目录...]$ chgrp [最终用户组] [文件或目录] （功能描述：改变文件或者目录的所属组） 参数说明 -c或–changes 效果类似”-v”参数，但仅回报更改的部分。 -f或–quiet或–silent 不显示错误信息。 -h或–no-dereference 只对符号连接的文件作修改，而不更动其他任何相关文件。 -R或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。 -v或–verbose 显示指令执行过程。 –help 在线帮助。 –reference=&lt;参考文件或目录&gt; 把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。 –version 显示版本信息。 实例：改变文件的群组属性： 1chgrp -v bin log2012.log 修改文件的所属组 1234[root@hadoop101 ~]# chgrp root houge.txt[root@hadoop101 ~]# ls -al-------------------------------------rwxrwxrwx. 1 neuedu root 551 5月 23 13:02 houge.txt 搜索查找命令find 查找文件/目录有一个相似的命令：which —查找命令程序的位置，查找范围是$PATH环境变量中所列出的路径。 find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件显示在终端。 基本语法1$ find [搜索范围] [选项] 选项说明/: 在整个linux系统中进行查找/etc: 查找配置文件时指定的路径 选项 功能 -name&lt;查询方式&gt; 按照指定的文件名查找模式查找文件 -user&lt;用户名&gt; 查找属于指定用户名所有文件 -size&lt;文件大小&gt; 按照指定的文件大小查找文件。 -type 按文件类型 f: 普通文件 d: 目录文件 l: 链接文件 b: 块设备文件 c: 字符设备文件 案例（1）按文件名：根据名称查找/目录下的filename.txt文件。 1[root@hadoop101 ~]# find xiyou/ -name “*.txt” （2）按拥有者：查找/opt目录下，用户名称为-user的文件 1[root@hadoop101 ~]# find xiyou/ -user neuedu （3）按文件大小：在/home目录下查找大于200m的文件（+n 大于 -n小于 n等于） 1[root@hadoop101 ~]find /home -size +204800 grep 过滤查找及“|”管道符管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。 前一个命令的输出是后一个命令的输入。 ls -R / | more —将查找根目录以及子目录的列表分页显示 基本语法1$ grep 选项 查找内容 源文件 选项说明 选项 功能 -n 显示匹配行及行号。 案例（1）查找某文件在第几行 1[root@hadoop101 ~]# ls | grep -n test which 查找命令查找命令在那个目录下 基本语法1$ which 命令 案例1$ which ll 压缩和解压命令gzip/gunzip 压缩特点注意： 一个压缩包只能压缩一个文件只能压缩文件不能压缩目录压缩后原文件不保留解压后压缩文件不保留 基本语法123$ gzip 文件 （功能描述：压缩文件，只能将文件压缩为*.gz文件）$ gunzip 文件.gz （功能描述：解压缩文件命令） 经验技巧（1）只能压缩文件不能压缩目录 （2）不保留原来的文件 案例（1）gzip压缩 12345678[root@hadoop101 ~]# ls------test.java-----[root@hadoop101 ~]# gzip houge.txt[root@hadoop101 ~]# ls----------houge.txt.gz （2）gunzip解压缩文件 123[root@hadoop101 ~]# gunzip houge.txt.gz [root@hadoop101 ~]# lshouge.txt zip/unzip 压缩压缩和解压.zip包 基本语法12$ zip [选项] XXX.zip 将要压缩的内容 （功能描述：压缩文件和目录的命令）$ unzip [选项] XXX.zip （功能描述：解压缩文件） 选项说明 zip选项 功能 -r 压缩目录 unzip选项 功能 -d&lt;目录&gt; 指定解压后文件的存放目录 经验技巧zip 压缩命令在window/linux都通用，可以压缩目录且保留源文件。 案例（1）压缩 1.txt 和2.txt，压缩后的名称为mypackage.zip 123456789[root@hadoop101 opt]# touch bailongma.txt[root@hadoop101 ~]# zip houma.zip houge.txt bailongma.txt ----------------------------- adding: houge.txt (stored 0%) adding: bailongma.txt (stored 0%)[root@hadoop101 opt]# ls-------------------houge.txt bailongma.txt houma.zip （2）解压 mypackage.zip 123456789[root@hadoop101 ~]# unzip houma.zip ----------------------Archive: houma.zipextracting: houge.txt extracting: bailongma.txt [root@hadoop101 ~]# ls-----------------------houge.txt bailongma.txt houma.zip （3）解压mypackage.zip到指定目录-d 12[root@hadoop101 ~]# unzip houma.zip -d /opt[root@hadoop101 ~]# ls /opt/ tar 打包基本语法1$ tar [选项] XXX.tar.gz 将要打包进去的内容 （功能描述：打包目录，压缩后的文件格式.tar.gz） 压缩.tar tar -cvf 压缩包名.tar 压缩的文件或目录列表压缩.tar.gz tar -zcvf 压缩包名.tar.gz 压缩的文件或目录列表解压.tar: tar -xvf 压缩包名.tar [-C 目标解压目录]解压.tar.gz: tar -zxvf 压缩包名.tar.gz [-C 目标解压目录] 选项说明 选项 功能 -z 打包同时压缩 -c 产生.tar打包文件 -v 显示详细信息 -f 指定压缩后的文件名 -x 解包.tar文件 案例（1）压缩多个文件 12345678[root@hadoop101 opt]# tar -zcvf houma.tar.gz houge.txt bailongma.txt ------------houge.txtbailongma.txt[root@hadoop101 opt]# ls----------------houma.tar.gz houge.txt bailongma.txt （2）压缩目录 123456[root@hadoop101 ~]# tar -zcvf xiyou.tar.gz xiyou/----------xiyou/xiyou/mingjie/xiyou/dssz/xiyou/dssz/houge.txt （3）解压到当前目录 1[root@hadoop101 ~]# tar -zxvf houma.tar.gz （4）解压到指定目录 12[root@hadoop101 ~]# tar -zxvf xiyou.tar.gz - /opt[root@hadoop101 ~]# ll /opt/ 磁盘分区命令df 查看磁盘空间使用情况df: disk free 空余硬盘 基本语法1$ df 选项 （功能描述：列出文件系统的整体磁盘使用量，检查文件系统的磁盘空间占用情况） 选项说明 选项 功能 -h 以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示； -t 查看指定文件系统的空间占用情况 -T 在结果中显示文件系统类型 案例（1）查看磁盘使用情况 123456[root@hadoop101 ~]# df -h------------------------Filesystem Size Used Avail Use% Mounted on/dev/sda2 15G 3.5G 11G 26% /tmpfs 939M 224K 939M 1% /dev/shm/dev/sda1 190M 39M 142M 22% /boot fdisk 查看分区基本语法1$ fdisk -l （功能描述：查看磁盘分区详情） 选项说明 选项 功能 -l 显示所有硬盘的分区列表 经验技巧该命令必须在root用户下才能使用 功能说明（1）Linux分区 12345678910111213Device：分区序列Boot：引导Start：从X磁柱开始End：到Y磁柱结束Blocks：容量Id：分区类型IDSystem：分区类型 （2）Win7分区，如图 案例（1）查看系统分区情况 12345678910111213[root@hadoop101 /]# fdisk -l----------------------------Disk /dev/sda: 21.5 GB, 21474836480 bytes255 heads, 63 sectors/track, 2610 cylindersUnits = cylinders of 16065 * 512 = 8225280 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk identifier: 0x0005e654Device Boot Start End Blocks Id System/dev/sda1 * 1 26 204800 83 LinuxPartition 1 does not end on cylinder boundary./dev/sda2 26 1332 10485760 83 Linux/dev/sda3 1332 1593 2097152 82 Linux swap / Solaris mount/umount 挂载/卸载​ 对于Linux用户来讲，不论有几个分区，分别分给哪一个目录使用，它总归就是一个根目录、一个独立且唯一的文件结构。 ​ Linux中每个分区都是用来组成整个文件系统的一部分，它在用一种叫做“挂载”的处理方法，它整个文件系统中包含了一整套的文件和目录，并将一个分区和一个目录联系起来，要载入的那个分区将使它的存储空间在这个目录下获得。 1．挂载前准备（必须要有光盘或者已经连接镜像文件） 基本语法123$ mount [-t vfstype] [-o options] device dir （功能描述：挂载设备）$ umount 设备文件名或挂载点 （功能描述：卸载设备） 参数说明 参数 功能 -t vfstype 指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常用类型有：光盘或光盘镜像：iso9660DOS fat16文件系统：msdosWindows 9x fat32文件系统：vfatWindows NT ntfs文件系统：ntfsMount Windows文件网络共享：smbfsUNIX(LINUX) 文件网络共享：nfs -o options 主要用来描述设备或档案的挂接方式。常用的参数有：loop：用来把一个文件当成硬盘分区挂接上系统ro：采用只读方式挂接设备rw：采用读写方式挂接设备 iocharset：指定访问文件系统所用字符集 device 要挂接(mount)的设备 dir 设备在系统上的挂接点(mount point) 案例（1）挂载光盘镜像文件 123[root@hadoop101 ~]# mkdir /mnt/cdrom/ 建立挂载点[root@hadoop101 ~]# mount -t iso9660 /dev/cdrom /mnt/cdrom/ 设备/dev/cdrom挂载到 挂载点 ： /mnt/cdrom中[root@hadoop101 ~]# ll /mnt/cdrom/ （2）卸载光盘镜像文件 1[root@hadoop101 ~]# umount /mnt/cdrom 5．设置开机自动挂载 1[root@hadoop101 ~]# vi /etc/fstab 添加红框中内容，保存退出。 进程线程命令进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。 freefree -h:以易读方式显示内存的空间占用情况 ps 查看当前系统进程状态ps:process status 进程状态 基本语法12$ ps aux | grep xxx （功能描述：查看系统中所有进程）$ ps -ef | grep xxx （功能描述：可以查看子父进程之间的关系） 选项说明 选项 功能 -a 选择所有进程 -u 显示所有用户的所有进程 -x 显示没有终端的进程 功能说明（1）ps aux显示信息说明 ​ USER：该进程是由哪个用户产生的 ​ PID：进程的ID号 ​ %CPU：该进程占用CPU资源的百分比，占用越高，进程越耗费资源； ​ %MEM：该进程占用物理内存的百分比，占用越高，进程越耗费资源； ​ VSZ：该进程占用虚拟内存的大小，单位KB； ​ RSS：该进程占用实际物理内存的大小，单位KB； ​ TTY：该进程是在哪个终端中运行的。其中tty1-tty7代表本地控制台终端，tty1-tty6是本地的字符界面终端， ​ tty7是图形终端。pts/0-255代表虚拟终端。 ​ STAT：进程状态。常见的状态有：R：运行、S：睡眠、T：停止状态、s：包含子进程、+：位于后台 ​ START：该进程的启动时间 ​ TIME：该进程占用CPU的运算时间，注意不是系统时间 ​ COMMAND：产生此进程的命令名 （2）ps -ef显示信息说明 ​ UID：用户ID ​ PID：进程ID ​ PPID：父进程ID ​ C：CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低；数值越 小，表明进程是I/O密集型运算，执行优先级会提高 ​ STIME：进程启动的时间 ​ TTY：完整的终端名称 ​ TIME：CPU时间 ​ CMD：启动进程所用的命令和参数 经验技巧​ 如果想查看进程的CPU占用率和内存占用率，可以使用aux; 如果想查看进程的父进程ID可以使用ef; 案例1[root@hadoop101 datas]# ps aux 1[root@hadoop101 datas]# ps -ef kill 终止进程基本语法12$ kill [选项] 进程号 （功能描述：通过进程号杀死进程）$ killall 进程名称 （功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用） 选项说明 选项 功能 -9 表示强迫进程立即停止 案例（1）杀死浏览器进程 1[root@hadoop101 桌面]# kill -9 5102 （2）通过进程名称杀死进程 1[root@hadoop101 桌面]# killall firefox pstree 查看进程树pstree命令在centos minimal版中要单独安装 1$ yum -y install psmisc 基本语法1$ pstree [选项] 选项说明 选项 功能 -p 显示进程的PID -u 显示进程的所属用户 案例（1）显示进程pid 1[root@hadoop101 datas]# pstree -p （2）显示进程所属用户 1[root@hadoop101 datas]# pstree -u top 查看系统健康状态基本语法1$ top [选项] 选项说明 选项 功能 -d 秒数 指定top命令每隔几秒更新。默认是3秒在top命令的交互模式当中可以执行的命令： -i 使top不显示任何闲置或者僵死进程。 -p 通过指定监控进程ID来仅仅监控某个进程的状态。 -b 批处理模式 -n 设置迭代数量 -u 可以用这些选项浏览特定用户的进程。用户名或者UID可以在选项中指定。-p、-u和-U选项是互斥的，同时只可以使用这其中一个选项。当你试图组合使用这些选项时，你会得到一个错误。 操作说明（交互命令） 操作 功能 P 以CPU使用率排序，默认就是此项 M 以内存的使用率排序 N 以PID排序 q 退出top h 帮助 会车或空格 手动刷新 A 切换交替显示模式，这个命令在全屏和交替模式间切换。在交替模式下会显示4个窗口（译注：分别关注不同的字段）。这四组字段共有一个独立的可配置的概括区域和它自己的可配置任务区域。4个窗口中只有一个窗口是当前窗口。当前窗口的名称显示在左上方。（译注：只有当前窗口才会接受你键盘交互命令）我们可以用’a’和’w’在4个 窗口间切换。’a’移到后一个窗口，’w’移到前一个窗口。用’g’命令你可以输入一个数字来选择当前窗口。 B 触发粗体显示 d/s 当按下’d’或’s’时，你将被提示输入一个值（以秒为单位），它会以设置的值作为刷新间隔。 l/t/m 切换负载、任务、内存信息的显示，这会相应地切换顶部的平均负载、任务/CPU状态和内存信息的概况显示。 f 用于选择你想要显示的字段。用’*’标记的是已选择的。上下光标键在字段内导航，左光标键可以选择字段，回车或右光标键确认。按’&lt;‘移动已排序的字段到左边，’&gt;’则移动到右边。 R 切换反向/常规排序。 c 切换是否显示进程启动时的完整路径和程序名。 i 切换显示空闲任务。 v 切换树视图。 Z 按下’Z’向用户显示一个改变top命令的输出颜色的屏幕。可以为8个任务区域选择8种颜色。 z 切换彩色，即打开或关闭彩色显示。 x/y 切换高亮信息：’x’将排序字段高亮显示（纵列）；’y’将运行进程高亮显示（横行）。依赖于你的显示设置，你可能需要让输出彩色来看到这些高亮。 u 显示特定用户的进程。你会被提示输入用户名。空白将会显示全部用户。 n/# 设置最大显示的任务数量 k top命令中最重要的一个命令之一。用于发送信号给任务（通常是结束任务）。 r 重新设置一个任务的调度优先级。 查询结果字段解释 第一行信息为任务队列信息 内容 说明 12:26:46 系统当前时间 up 1 day, 13:32 系统的运行时间，本机已经运行1天13小时32分钟 2 users 当前登录了两个用户 load average: 0.00, 0.00, 0.00 系统在之前1分钟，5分钟，15分钟的平均负载。一般认为小于1时，负载较小。如果大于1，系统已经超出负荷。 第二行为进程信息 Tasks: 95 total 系统中的进程总数 1 running 正在运行的进程数 94 sleeping 睡眠的进程 0 stopped 正在停止的进程 0 zombie 僵尸进程。如果不是0，需要手工检查僵尸进程 第三行为CPU信息 Cpu(s): 0.1%us 用户模式占用的CPU百分比 0.1%sy 系统模式占用的CPU百分比 0.0%ni 改变过优先级的用户进程占用的CPU百分比 99.7%id 空闲CPU的CPU百分比 0.1%wa 等待输入/输出的进程的占用CPU百分比 0.0%hi 硬中断请求服务占用的CPU百分比 0.1%si 软中断请求服务占用的CPU百分比 0.0%st st（Steal time）虚拟时间百分比。就是当有虚拟机时，虚拟CPU等待实际CPU的时间百分比。 第四行为物理内存信息 Mem: 625344k total 物理内存的总量，单位KB 571504k used 已经使用的物理内存数量 53840k free 空闲的物理内存数量，我们使用的是虚拟机，总共只分配了628MB内存，所以只有53MB的空闲内存了 65800k buffers 作为缓冲的内存数量 第五行为交换分区（swap）信息 Swap: 524280k total 交换分区（虚拟内存）的总大小 0k used 已经使用的交互分区的大小 524280k free 空闲交换分区的大小 409280k cached 作为缓存的交互分区的大小 在横向列出的系统属性和状态下面，是以列显示的进程。不同的列代表下面要解释的不同属性。 默认上，top显示这些关于进程的属性： PID 进程ID，进程的唯一标识符 USER 进程所有者的实际用户名。 PR 进程的调度优先级。这个字段的一些值是’rt’。这意味这这些进程运行在实时态 NI 进程的nice值（优先级）。越小的值意味着越高的优先级。 VIRT 进程使用的虚拟内存。 RES 驻留内存大小。驻留内存是任务使用的非交换物理内存大小。 SHR SHR是进程使用的共享内存。 S 这个是进程的状态。它有以下不同的值: D – 不可中断的睡眠态。 R – 运行态 S – 睡眠态 T – 被跟踪或已停止 Z – 僵尸态 %CPU 自从上一次更新时到现在任务所使用的CPU时间百分比。 %MEM 进程使用的可用物理内存百分比。 TIME+ 任务启动后到现在所使用的全部CPU时间，精确到百分之一秒。 COMMAND 运行进程所使用的命令。 还有许多在默认情况下不会显示的输出，它们可以显示进程的页错误、有效组和组ID和其他更多的信息。 案例123[root@hadoop101 neuedu]# top -d 1[root@hadoop101 neuedu]# top -i[root@hadoop101 neuedu]# top -p 2575 执行上述命令后，可以按P、M、N对查询出的进程结果进行排序。 lsof lsof -i:端口号 查看端口占用情况 lsof -i:8080：查看8080端口占用 lsof abc.txt：显示开启文件abc.txt的进程 lsof -c abc：显示abc进程现在打开的文件 lsof -c -p 1234：列出进程号为1234的进程所打开的文件 lsof -g gid：显示归属gid的进程情况 lsof +d /usr/local/：显示目录下被进程开启的文件 lsof +D /usr/local/：同上，但是会搜索目录下的目录，时间较+ 长 lsof -d 4：显示使用fd为4的进程 lsof -i -U：显示所有打开的端口和UNIX domain文件 netstat 显示网络统计信息和端口占用情况基本语法12$ netstat -anp |grep 进程号 （功能描述：查看该进程网络信息）$ netstat -nlp | grep 端口号 （功能描述：查看网络端口号占用情况） 选项说明 选项 功能 -n 拒绝显示别名，能显示数字的全部转化成数字 -l 仅列出有在listen（监听）的服务状态 -p 表示显示哪个进程在调用 案例（1）通过进程号查看该进程的网络信息 123456[root@hadoop101 hadoop-2.7.2]# netstat -anp | grep 火狐浏览器进程号--------------unix 2 [ ACC ] STREAM LISTENING **20670** 3115/firefox /tmp/orbit-root/linc-c2b-0-5734667cbe29unix 3 [ ] STREAM CONNECTED 20673 3115/firefox /tmp/orbit-root/linc-c2b-0-5734667cbe29unix 3 [ ] STREAM CONNECTED 20668 3115/firefox unix 3 [ ] STREAM CONNECTED 20666 3115/firefox （2）查看某端口号是否被占用 123[root@hadoop101 桌面]# netstat -nlp | grep 20670----------------------------unix 2 [ ACC ] STREAM LISTENING 20670 3115/firefox /tmp/orbit-root/linc-c2b-0-5734667cbe29 crond 定时任务crond 服务管理重新启动crond服务 1[root@hadoop101 ~]# sytemctl restart crond crontab 定时任务设置基本语法1$ crontab [选项] 选项说明 选项 功能 -e 编辑crontab定时任务 -l 查询crontab任务 -r 删除当前用户所有的crontab任务 参数说明1[root@hadoop101 ~]# crontab -e （1）进入crontab编辑界面。会打开vim编辑你的工作。 * * * * * 执行的任务 项目 含义 范围 第一个“*” 一小时当中的第几分钟 0-59 第二个“*” 一天当中的第几小时 0-23 第三个“*” 一个月当中的第几天 1-31 第四个“*” 一年当中的第几月 1-12 第五个“*” 一周当中的星期几 0-7（0和7都代表星期日） （2）特殊符号 特殊符号 含义 * 代表任何时间。比如第一个“*”就代表一小时中每分钟都执行一次的意思。 ， 代表不连续的时间。比如“0 8,12,16 * * * 命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令 - 代表连续的时间范围。比如“0 5 * * 1-6命令”，代表在周一到周六的凌晨5点0分执行命令 */n 代表每隔多久执行一次。比如“*/10 * * * * 命令”，代表每隔10分钟就执行一遍命令 （3）特定时间执行命令 时间 含义 45 22 * * * 命令 在22点45分执行命令 0 17 * * 1 命令 每周1 的17点0分执行命令 0 5 1,15 * * 命令 每月1号和15号的凌晨5点0分执行命令 40 4 * * 1-5 命令 每周一到周五的凌晨4点40分执行命令 */10 4 * * * 命令 每天的凌晨4点，每隔10分钟执行一次命令 0 0 1,15 * 1 命令 每月1号和15号，每周1的0点0分都会执行命令。注意：星期几和几号最好不要同时出现，因为他们定义的都是天。非常容易让管理员混乱。 案例（1）每隔1分钟，向/root/bailongma.txt文件中添加一个11的数字 1$ */1 * * * * /bin/echo ”11” &gt;&gt; /root/bailongma.txt 基本文件命令man 获得帮助信息基本语法1$ man [命令或配置文件] （功能描述：获得帮助信息） 显示说明 信息 功能 NAME 命令的名称和单行描述 SYNOPSIS 怎样使用命令 DESCRIPTION 命令功能的深入讨论 EXAMPLES 怎样使用命令的例子 SEE ALSO 相关主题（通常是手册页） 案例查看ls命令的帮助信息 1$ man ls help 获得shell内置命令的帮助信息注意：help命令只能获取shell脚本对应的内置命令 基本语法1$ help 命令 （功能描述：获得shell内置命令的帮助信息 案例查看cd命令的帮助信息help cd pwd 显示当前工作目录绝对路径 用于切换到新的工作目录 基本语法1$ pwd （功能描述：显示当前工作目录的绝对路径） 案例显示当前工作目录的绝对路径 12[root@hadoop150 ~]# pwd/root ls 列出目录的内容基本 ls -alF #直接使用用于按列排序输出当前目录下的文件和目录 ls -F 区分文件和目录 ls -a 显示包括隐藏文件 ls -l 长列表输出，班汉每个文件的相关信息 ls -i 查看一个文件的编号 ls -F -R 还可合并 ls -FR 显示当前目录下的所有文件以及他们的子文件 可以理解为遍历整个当前目录作为根节点的文件树 过滤ls -l 《想要的文件名称》 如果不确定可用模糊查询 ？一个字符 * 0或多个字符 [ai] 表示某个位置可以是a或i [a-i] 可以是a到i [!a] 不可以是a touch 创建文件touch 文件名 访问已经存在的文件时会改变修改时间 touch -a 文件名 仅改变访问时间 用 ls -l —time=atime 文件名 显示文件的访问时间 cp 复制文件或目录基本语法1$ cp [选项] source dest （功能描述：复制source文件到dest） 选项说明 选项 功能 -r 递归复制整个文件夹 参数说明 参数 功能 source 源文件 dest 目标文件 经验技巧​ 强制覆盖不提示的方法：\\cp 案例（1）复制文件 1$ cp xiyou/dssz/suwukong.txt xiyou/mingjie/ （2）递归复制整个文件夹 1$ cp -r xiyou/dssz/ ./ mv 移动文件与目录或重命名基本语法12$ mv oldNameFile newNameFile （功能描述：重命名 两个参数都不带 / 表示重命名）$ mv /temp/movefile /targetFolder （功能描述：移动文件） 案例（1）重命名 1$ mv xiyou/dssz/suwukong.txt xiyou/dssz/houge.txt （2）移动文件 1$ mv xiyou/dssz/houge.txt ./ （3）把aaa的所有内容连同aaa放入bbb（两个文件夹） 1$ mv aaa bbb rm 删除文件rm -i aaa 带有询问是否真的删除aaa文件,文件名可以模糊查询 -f, –force 忽略不存在的文件，从不给出提示。-i, –interactive 进行交互式删除-r, -R, –recursive 指示rm将参数中列出的全部目录和子目录均递归地删除。(不推荐，可用下面的删除目录)-v, –verbose 详细显示进行的步骤–help 显示此帮助信息并退出–version 输出版本信息并退出 案例（1）删除目录中的内容 1$ rm xiyou/mingjie/sunwukong.txt （2）递归删除目录中所有内容 1$ rm -rf dssz/ mkdir创建一个新的目录mkdir:Make directory 建立目录 基本语法1mkdir [选项] 要创建的目录 选项说明表1-10 选项说明 选项 功能 -p 创建多层目录 -m=mode 为目录指定访问权限，与chmod类似。 -v 为每个目录显示提示信息。 案例（1）创建一个目录 12$ mkdir xiyou$ mkdir xiyou/mingjie （2）创建一个多级目录 1$ mkdir -p xiyou/dssz/meihouwang rmdir 删除目录rmdir 只能删除空目录 ####file 查看文件类型 -b 列出文件辨识结果时，不显示文件名称。 -c 详细显示指令执行过程，便于排错或分析程序执行的情形 -f 列出文件中文件名的文件类型 -F 使用指定分隔符号替换输出文件名后的默认的”：”分隔符。 -i 输出mime类型的字符串 -L 查看对应软链接对应文件的文件类型 -z 尝试去解读压缩文件的内容 –help 显示命令在线帮助 -version 显示命令版本信息 cat 文件名 查看整个文件一般查看比较小的文件，一屏幕能显示全的。 基本语法1$ cat [选项] 要查看的文件 -n 或 –number 由 1 开始对所有输出的行数编号-b 或 –number-nonblank 和 -n 相似，只不过对于空白行不编号-s 或 –squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行-v 或 –show-nonprinting 范例：cat -n linuxfile1 &gt; linuxfile2 把 linuxfile1 的档案内容加上行号后输入 linuxfile2 这个档案里cat -b linuxfile1 linuxfile2 &gt;&gt; linuxfile3 把 linuxfile1 和 linuxfile2 的档案内容加上行号(空白行不加)之后将内容附加到linuxfile3 里。范例：把 linuxfile1 的档案内容加上行号后输入 linuxfile2 这个档案里cat -n linuxfile1 &gt; linuxfile2把 linuxfile1 和 linuxfile2 的档案内容加上行号(空白行不加)之后将内容附加到 linuxfile3 里。cat -b linuxfile1 linuxfile2 &gt;&gt; linuxfile3cat /dev/null &gt; /etc/test.txt 此为清空/etc/test.txt档案内容 moremore [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]参数： -num 一次显示的行数 -d 提示使用者，在画面下方显示 [Press space to continue, ‘q’ to quit.] ，如果使用者按错键，则会显示 [Press ‘h’ for instructions.] 而不是 ‘哔’ 声 -l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能 -f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上） -p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容 -c 跟 -p 相似，不同的是先显示内容再清除其他旧资料 -s 当遇到有连续两行以上的空白行，就代换为一行的空白行 -u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同） +/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示 +num 从第 num 行开始显示 fileNames 欲显示内容的文档，可为复数个数 操作说明 操作 功能说明 空白键 (space) 代表向下翻一页； Enter 代表向下翻『一行』； q 代表立刻离开 more ，不再显示该文件内容。 Ctrl+F 向下滚动一屏 Ctrl+B 返回上一屏 = 输出当前行的行号 :f 输出文件名和当前行的行号 less 分屏显示文件内容less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。 基本语法less [参数] 文件 参数说明： -b &lt;缓冲区大小&gt; 设置缓冲区的大小 -e 当文件显示结束后，自动离开 -f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件 -g 只标志最后搜索的关键词 -i 忽略搜索时的大小写 -m 显示类似more命令的百分比 -N 显示每行的行号 -o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来 -Q 不使用警告音 -s 显示连续空行为一行 -S 行过长时间将超出部分舍弃 -x &lt;数字&gt; 将”tab”键显示为规定的数字空格 /字符串：向下搜索”字符串”的功能 ?字符串：向上搜索”字符串”的功能 n：重复前一个搜索（与 / 或 ? 有关） N：反向重复前一个搜索（与 / 或 ? 有关） b 向后翻一页 d 向后翻半页 h 显示帮助界面 Q 退出less 命令 u 向前滚动半页 y 向前滚动一行 空格键 滚动一页 回车键 滚动一行 [pagedown]： 向下翻动一页 [pageup]： 向上翻动一页 操作说明 操作 功能说明 空白键 向下翻动一页； [pagedown] 向下翻动一页 [pageup] 向上翻动一页； /字串 向下搜寻『字串』的功能；n：向下查找；N：向上查找； ?字串 向上搜寻『字串』的功能；n：向上查找；N：向下查找； q 离开 less 这个程序； head 显示文件头部内容head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容。 基本语法12$ head 文件 （功能描述：查看文件头10行内容）$ head -n 5 文件 （功能描述：查看文件头5行内容，5可以是任意行数） 选项说明 选项 功能 -n &lt;行数&gt; 指定显示头部内容的行数 案例（1）查看文件的头2行 1$ head -n 2 smartd.conf tail 输出文件尾部内容tail用于输出文件中尾部的内容，默认情况下tail指令显示文件的后10行内容。 基本语法123$ tail 文件 （功能描述：查看文件后10行内容）$ tail -n 5 文件 （功能描述：查看文件后5行内容，5可以是任意行数）$ tail -f 文件 （功能描述：实时追踪该文档的所有更新） 选项说明 选项 功能 -n&lt;行数&gt; 输出文件尾部n行内容 -f 显示文件最新追加的内容，监视文件变化 案例（1）查看文件头1行内容 1$ tail -n 1 smartd.conf （2）实时追踪该档的所有更新 1$ tail -f houge.txt history 查看已经执行过历史命令基本语法1$ history （功能描述：查看已经执行过历史命令） 案例（1）查看已经执行过的历史命令 1$ history 关机重启命令在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。 正确的关机流程为：sync &gt; shutdown &gt; reboot &gt; halt 1. 基本语法（1）sync （功能描述：将数据由内存同步到硬盘中） （2）halt （功能描述：关闭系统，等同于shutdown -h now 和 poweroff） （3）reboot （功能描述：就是重启，等同于 shutdown -r now） （4）shutdown [选项] 时间 选项 功能 -h -h=halt关机 -r -r=reboot重启 参数 功能 now 立刻关机 时间 等待多久后关机（时间单位是分钟）。 2. 经验技巧​ Linux系统中为了提高磁盘的读写效率，对磁盘采取了 “预读迟写”操作方式。当用户保存文件时，Linux核心并不一定立即将保存数据写入物理磁盘中，而是将数据保存在缓冲区中，等缓冲区满时再写入磁盘，这种方式可以极大的提高磁盘写入数据的效率。但是，也带来了安全隐患，如果数据还未写入磁盘时，系统掉电或者其他严重问题出现，则将导致数据丢失。使用sync指令可以立即将缓冲区的数据写入磁盘。 3. 案例（1）将数据由内存同步到硬盘中 1$ sync （2）重启 1$ reboot （3）关机 1$ halt （4）计算机将在1分钟后关机，并且会显示在登录用户的当前屏幕中 1$ shutdown -h 1 ‘This server will shutdown after 1 mins’ （5）立马关机（等同于 halt） 1$ shutdown -h now （6）系统立马重启（等同于 reboot） 1$ shutdown -r now 时间日期命令date命令基本语法1$ date [OPTION]... [+FORMAT] 选项说明 选项 功能 -d&lt;时间字符串&gt; 显示指定的“时间字符串”表示的时间，而非当前时间 -s&lt;日期时间&gt; 设置系统日期时间 参数说明 参数 功能 &lt;+日期时间格式&gt; 指定显示时使用的日期时间格式 date 显示当前时间基本语法12345$ date （功能描述：显示当前时间）$ date +%Y （功能描述：显示当前年份）$ date +%m （功能描述：显示当前月份）$ date +%d （功能描述：显示当前是哪一天）$ date \"+%Y-%m-%d %H:%M:%S\" （功能描述：显示年月日时分秒） 案例（1）显示当前时间信息 1$ date （2）显示当前时间年月日 1$ date +%Y%m%d （3）显示当前时间年月日时分秒 1$ date \"+%Y-%m-%d %H:%M:%S\" date 显示非当前时间基本语法123$ date -d '1 days ago' （功能描述：显示前一天时间）$ date -d '-1 days ago' （功能描述：显示明天时间） 案例（1）显示前一天 1$ date -d '1 days ago' （2）显示明天时间 1$ date -d '-1 days ago' date 设置系统时间基本语法1$ date -s 字符串时间 案例（1）设置系统当前时间 1$ date -s \"2017-06-19 20:52:18\" cal 查看日历基本语法1$ cal [选项](功能描述：不加选项，显示本月日历） 选项说明 选项 功能 具体某一年 显示这一年的日历 案例（1）查看当前月的日历 1$ cal （2）查看2017年的日历 1$ cal 2017 用户管理命令useradd 添加新用户基本语法123$ useradd 用户名 （功能描述：添加新用户）$ useradd -g 组名 用户名 （功能描述：添加新用户到某个组） 参数 u: 指定UID d:指宿主目录或家目录， 缺省的家目录为/home/用户名 g:指定用户的基本组名 G:指定用户的附加组名 s:指定用户的登录shell 案例（1）添加一个用户 12$ useradd tangseng$ ll /home/ (2) 创建用户test2, 指定用户UID为888，基本组为root组，登录shell为/bin/csh，指定家目录 1useradd -u 888 -g root -s /bin/csh -d /opt/aaa test2 passwd 设置用户密码基本语法1$ passwd 用户名 （功能描述：设置用户密码） 参数 -l: 锁定密码 -u: 解锁密码 -S：查看用户的帐号的状态 案例 如果是重置自己的密码：passwd 如果是设置指定用户的密码（root操作）：passwd 用户名 id 查看用户是否存在基本语法1$ id 用户名 案例（1）查看用户是否存在 su 切换用户su 用户名 //切换用户身份，但是不更改当前工作目录su - 用户名 //切换用户身份，并且当前工作目录会更改为新用户的家目录 —当前登录用户是root， 切换到其它用户下，不需要输入密码su - 用户名 —当有登录用户是普通用户，切换到其它用户下，都需要输入密码su 用户名注意：如果是想切换到root身份下，也可以直接输入su, 回车输入密码即可。 userdel 删除用户userdel [-r] 用户名 -r: 删除用户时将用户的家目录一并删除 who /w 查看当前登录用户信息 案例（1）显示自身用户名称 1[root@hadoop101 opt]# whoami （2）显示登录用户的用户名 1[root@hadoop101 opt]# who am i sudo 设置普通用户具有root权限要想让普通用户具有root的权限，我们需要使用sudo命令，但前提是这个用户必须在sudoers名单中 1．添加neuedu用户，并对其设置密码。123[root@hadoop101 ~]#useradd neuedu[root@hadoop101 ~]#passwd neuedu 2．修改配置文件1[root@hadoop101 ~]#vi /etc/sudoers 修改 /etc/sudoers 文件，找到下面一行(91行)，在root下面添加一行，如下所示： 123## Allow root to run any commands anywhereroot ALL=(ALL) ALLneuedu ALL=(ALL) ALL 或者配置成采用sudo命令时，不需要输入密码 123\\## Allow root to run any commands anywhereroot ALL=(ALL) ALLneuedu ALL=(ALL) NOPASSWD:ALL 修改完毕，现在可以用neuedu帐号登录，然后用命令 sudo ，即可获得root权限进行操作。 3．案例（1）用普通用户在/opt目录下创建一个文件夹 12[neuedu@hadoop101 opt]$ sudo mkdir module[root@hadoop101 opt]# chown neuedu:neuedu module/ usermod 修改用户基本语法1$ usermod -g 用户组 用户名 选项说明 选项 功能 -g 修改用户的初始登录组，给定的组必须存在 -u 修改用户的uid -d 修改用户的家目录 -s 修改用户的登录shell 案例（1）将用户加入到用户组 1[root@hadoop101 opt]#usermod -g root zhubajie —-修改test3用户的登录shell为/bin/csh, 用户基本组为rootusermod -s /bin/csh -g root test3 用户组管理命令每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。 groupadd 新增组基本语法1$ groupadd 组名 案例（1）添加一个xitianqujing组 1[root@hadoop101 opt]#groupadd xitianqujing —创建一个组neu, 组id为666groupadd -g 666 neu groupdel 删除组基本语法1$ groupdel 组名 案例（1）删除xitianqujing组 1[root@hadoop101 opt]# groupdel xitianqujing groupmod 修改组基本语法1$ groupmod -n 新组名 老组名 选项说明 选项 功能描述 -n&lt;新组名&gt; 指定工作组的新组名 案例（1）修改neuedu组名称为neuedu1 12[root@hadoop101 ~]#groupadd xitianqujing[root@hadoop101 ~]# groupmod -n xitian xitianqujing cat /etc/group 查看创建了哪些组基本操作1[root@hadoop101 neuedu]# cat /etc/group cat /etc/group 查看创建了哪些组基本操作1[root@hadoop101 neuedu]# cat /etc/group 后台运行命令Unix/Linux下一般比如想让某个程序在后台运行，很多都是使用&amp; 在程序结尾来让程序自动运行。比如我们要运行mysql在后台：/usr/local/mysql/bin/mysqld_safe –user=mysql &amp;但是加入我们很多程序并不象mysqld一样做成守护进程，可能我们的程序只是普通程序而已，一般这种程序使用&amp; 结尾，但是如果终端关闭，那么程序也会被关闭。但是为了能够后台运行，那么我们就可以使用nohup这个命令，比如我们有个test.php需要在后台运行，并且希望在后台能够定期运行，那么就使用nohup。 nohupnohup命令+ &amp;命令，可以让你的程序在后台运行，这样如果你是用xshell来连接到服务器，即使xshell断开了，程序仍然可以运行。nohup可以不受关闭信号所影响， &amp;用于将程序后台运行。 具体执行命令为: nohup 你的命令 &amp;nohup /root/test.php &amp; 提示： [~]$ appending output to nohup.out 嗯，证明运行成功，同时把程序运行的输出信息放到当前目录的nohup.out 文件中去。 部署jar包$ nohup java -jar test.jar &gt;temp.txt &amp; 注意没成功可能是没有在文件路径下 这种方法会把日志文件输入到你指定的文件中，没有则会自动创建。进程会在后台运行。然后输入 cat temp.txt 查看结果 vim编辑器 基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode)和底线命令模式（Last line mode)。 这三种模式的作用分别是： 命令模式/一般模式：用户刚刚启动 vi/vim，便进入了命令模式。 此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。 在这个模式中， 你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容， 也可以使用『复制、贴上』来处理你的文件数据。 以下是常用的几个命令： i 切换到输入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。 G 移到最后一行 gg 移到第一行 num G 移到第num行 方向键或hjkl，在文本中移动光标 Page Up/Page Down或ctrl+F/B，上/下翻页 dd 删除光标所在行 dw 删除光标所在的单词 d$ 删除光标所在位置至行尾 J 删除当前行尾的换行符 u 撤销上一个命令 a 当前光标后追加数据 A 当前所在行行尾追加数据 r char char替换当前光标位置的单个字符 R text text覆盖当前光标所在位置的数据直到按下esc 其他命令 语法 功能描述 yy 复制光标当前一行 y数字y 复制一段（从第几行到第几行） p 箭头移动到目的行粘贴 u 撤销上一步 dd 删除光标当前行 d数字d 删除光标（含）后多少行 x 删除一个字母，相当于del，向后删 X 删除一个字母，相当于Backspace，向前删 yw 复制一个词 dw 删除一个词 h 或 向左箭头键(←) 光标向左移动一个字符 j 或 向下箭头键(↓) 光标向下移动一个字符 k 或 向上箭头键(↑) 光标向上移动一个字符 l 或 向右箭头键(→) 光标向右移动一个字符 [Ctrl] + [f] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用) [Ctrl] + [b] 屏幕『向下』移动半页 shift+^ 移动到行头 shift+$ 移动到行尾 gg或者1+G 移动到页头 G 移动到页尾 数字+G（先输入数字，在按G） 移动到目标行 ​ 块选择模式 V : 字符选择，会把光标经过的位置反白选择 v 行选择，会把光标经过的行反白选择 Ctrl + v: 块选择，可以使用长方形的方式反白选择内容 y 将反白的地方复制 d 将反白的地方删除 r 修改内容 命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。 输入模式在命令模式下按下以下对应键就以不同方式进入了输入模式。 注意了！通常在Linux中，按下这些按键时，在画面的左下方会出现『INSERT或 REPLACE』的字样，此时才可以进行编辑。而如果要回到一般模式时， 则必须要按下『Esc』这个按键即可退出编辑模式。 按键 功能 i 当前光标前 a 当前光标后 o 当前光标行的下一行 I 光标所在行最前 A 光标所在行最后 O 当前光标行的上一行 在输入模式中，可以使用以下按键： 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键或hjkl，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down或ctrl+F/B，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 底线命令模式/指令模式在命令模式下按下:（英文冒号）就进入了底线命令模式。 底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。 在底线命令模式中，基本的命令有（已经省略了冒号）： 命令 功能 :w 保存 :q 退出 :! 强制执行 / 要查找的词 n 查找下一个，N 往上查找 ? 要查找的词 n是查找上一个，N是往下查找 :nohlsearch 或:noh 取消查找高亮 n 搜索下一个匹配字符串 N 搜索上一个匹配 :n1,n2s/word1/word2/g n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：『:100,200s/vbird/VBIRD/g』。(常用) :1,$s/word1/word2/g 或 :%s/word1/word2/g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) :1,$s/word1/word2/gc 或 :%s/word1/word2/gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用) :w [filename] 将编辑的数据储存成另一个档案（类似另存新档） :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。 :set nu 显示行号 :set nonu 关闭行号 ZZ（shift+zz） 没有修改文件直接退出，如果修改了文件保存后退出 :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！ 按ESC键可随时退出底线命令模式。 举个栗子 强制保存退出 :wq! 将数列 12310.1.1.214 10.1.1.212 10.1.1.210 编辑成序列： 123ping -c 4 10.5.5.214 &gt;&gt; result0 ping -c 4 10.5.5.212 &gt;&gt; result0 ping -c 4 10.5.5.210 &gt;&gt; result0 这是一个将 IP 数列修改成可执行的 ping 命令序列的过程。 修改 将 IP 数列中第二段所有数字“1” 修改为“5”： 将游标定位第一个行 IP 地址第二段的“1” ctrl-v进入纵向编辑模式 G 移动游标到最后一行，可视块覆盖所要修改的列 r 进入修改模式 5 输入数字“5” ESC `退出纵向编辑模式，同时所有被选中的数字都被改成了“5”，并回到命令模式 结果如下: 12310.5.5.214 10.5.5.21210.5.5.210 前添加 在所有行之前添加“ping – c 4 ”： 将游标定位到第一行第一列 ctrl-v进入纵向编辑模式 G移动游标到最后一行第一列，可视块覆盖了第一列 I进入行首插入模式 ping -c 4输入所要求字符“ping – c 4 ” ESC按两下退出纵向编辑模式的同时所有选中的字符前都添加了“ping – c 4 ”，回到命令模式 结果如下： 123ping -c 4 10.5.5.214 ping -c 4 10.5.5.212 ping -c 4 10.5.5.210 后添加 在所有行之后添加“&gt;&gt; result0”： 将游标定位到第一行最后一列 ctrl-v 进入纵向编辑模式 G 移动游标到最后一行最后一列，VISUAL BLOCK 覆盖了最后一列 A 进入行尾插入模式 &gt;&gt; result 输入所要求字符“&gt;&gt; result0” ESC 按两下退出纵向编辑模式的同时所有选中的字符后都添加了“ &gt;&gt; result0”，回到命令模式 结果如下： 123ping -c 4 10.5.5.214 &gt;&gt; result0 ping -c 4 10.5.5.212 &gt;&gt; result0 ping -c 4 10.5.5.210 &gt;&gt; result0 以上三个步骤有一个共同特点，就是都纵向为编辑方向。以上由三行代码为例的方法同样也可以适用于更多的行。 shell脚本准备工作创建好脚本文件后，在bash’中输入绝对路径或添加path后就能运行， 如权限不够，可用chmod 777 filename 基本语法echo 控制字符 作用 \\ 输出\\本身 \\n 换行符 \\t 制表符，也就是Tab键 123echo helloecho \"I'am\"echo ‘I\"am' 若想其他内容和该语句在一行中输出，则要用引号把字符串框住，并最后多一个空格，以及-n命令 1echo -n \"hello: \" 变量 对于系统环境变量，可以用$NAME来调用，用set查看所有系统环境变量 1echo $HOME 若要真实显示$符号，在前面加一个\\即可 用户变量 直接 name=“sdsd”创立变量 使用时用$引用 赋值value1=10 value1=$value2 命令替换 用val=` date`或val=$(date)将某一命令的输出赋给变量 重定向输入输出其实这是UNIX系统的标准输入与标准输出功能，在shell中会说到，这里先知道基本用法 基本语法 输入重定向：&lt; 了解： 命令 &lt; 文件名 —将文件的内容输入给命令 wc &lt; hadoop.list 输出重定向：还有一个新的功能—创建新文件 标准输出重定向 标准输出：指的是命令正确运行的输出结果&gt; : 命令 &gt; 文件名 — 会前面命令的输出结果写入到文件中,如果文件不存在，会创建该文件后写入命令的输出内容，如果文件存在，会将文件中原来的信息清除掉之后将命令的输出写入&gt;&gt;：命令&gt;&gt; 文件名 —-与上面的命令一样，只是当文件存在时，会在文件原来内容的后面追加写入命令的输出。标准错误输出重定向 标准错误输出： 指的是命令没有正确运行的报错输出2&gt;: 与&gt;一样，会清除原内容再写入 2&gt;&gt;: 追加写入 标准输出和标准错误输出重定向 &amp;&gt;:会清除原内容再写入 &amp;&gt;&gt;:追加写入 1234567$ ll &gt;文件 （功能描述：列表的内容写入文件a.txt中（覆盖写））$ ll &gt;&gt;文件 （功能描述：列表的内容**追加**到文件aa.txt的末尾）$ cat 文件1 &gt; 文件2 （功能描述：将文件1的内容覆盖到文件2）$ echo “内容” &gt;&gt; 文件 案例（1）将ls查看信息写入到文件中 1$ ls -l&gt;houge.txt （2）将ls查看信息追加到文件中 1$ ls -l&gt;&gt;houge.txt （3）采用echo将hello单词追加到文件中 1$ echo hello&gt;&gt;houge.txt ln 软链接软链接也成为符号链接，类似于windows里的快捷方式，有自己的数据块，主要存放了链接其他文件的路径。 linux连接种类参考：https://www.runoob.com/linux/linux-comm-ln.html 基本语法1$ ln -s [原文件或目录] [软链接名] （功能描述：给原文件创建一个软链接） 经验技巧删除软链接： rm -rf 软链接名，而不是rm -rf 软链接名/ 查询：通过ll就可以查看，列表属性第1位是l，尾部会有位置指向。 案例（1）创建软连接 12345[root@hadoop101 ~]# mv houge.txt xiyou/dssz/[root@hadoop101 ~]# ln -s xiyou/dssz/houge.txt ./houzi[root@hadoop101 ~]# ll-------------------lrwxrwxrwx. 1 root root 20 6月 17 12:56 houzi -&gt; xiyou/dssz/houge.txt （2）删除软连接 1[root@hadoop101 ~]# rm -rf houzi （3）进入软连接实际物理路径 12[root@hadoop101 ~]# ln -s xiyou/dssz/ ./dssz[root@hadoop101 ~]# cd -P dssz/ #### 管道1rpm -qa | sort | more 数学运算 expr 1+5 不推荐 用$[ ]将算式框住， 1var1=$[$var2*$var3] 但都只能进行整数运算，如100/45=2 使用bc运算器 12345678910111213141516var1=100var2=45var3=$(echo \"scale=4; $var1/$var2\" | bc)------var1=10.34var2=12.5var3=34.52var4=56.4var5=$(bc&lt;&lt;eofscale=4a1=($var1*vsr2)b1=($var3*$var4)a1+b1eof) 退出脚本 退出时都有一个退出状态吗，用echo $? 可以查看 默认脚本以最后一个命令的状态吗退出 exit num用来指定自己退出的状态码 exit $num 用变量值退出，最大255，超出取模 结构化命令 if-then 1234if commandthen commandsfi 123if command; then commandsfi 仅当command运行退出状态吗为0时then中的命令才会被运行 if-then-else 123456if commandthen commandselse commandsfi 嵌套if 1234567if commandthen commandselif command2then more commandsfi 在elif中，紧跟其后的else语句属于elif代码块，他们并不属于之前的if-then代码块 使用test可以模拟出和一般语言中if一样的效果 1234if test commandthen ...fi 1234if [command]then ...fi 如 1234if [$value1 -gt 5]then ...fi gt表示大于，eq为等于","link":"/2020/05/16/Linux&Mac/linux&mac/"},{"title":"Vue 笔记","text":"之前学习很有问题，只看视频不记笔记，直接把他人的笔记复制来也不整理，痛定思痛，特整理如下。 Vue 是什么？ Vue (读音 /vjuː/，类似于 **view) 是一套用于构建用户界面的渐进式框架** Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果； 为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱； 企业中，使用框架，能够提高开发的效率； 提高开发效率的发展历程：原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】） 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑； 增强自己就业时候的竞争力 人无我有，人有我优 你平时不忙的时候，都在干嘛？ 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了MVC还要有MVVM Vue.js 基本代码 和 MVVM 之间的对应关系 使用Vue将helloworld 渲染到页面上 指令 本质就是自定义属性 Vue中指定都是以 v- 开头 v-cloak防止页面加载时出现闪烁问题 v-cloak指令的用法 提供样式 [v-cloak]{ display: none; } 在插值表达式所在的标签中添加v-cloak指令 背后的原理：先通过样式隐藏内容，然后在内存中进行值的替换，替换好之后再显示最终的结果 12345678910111213141516171819202122232425262728293031 &lt;style type=\"text/css\"&gt; /* 1、通过属性选择器 选择到 带有属性 v-cloak的标签 让他隐藏 */ [v-cloak]{ /* 元素隐藏 */ display: none; } &lt;/style&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 2、 让带有插值语法的添加 v-cloak 属性 在 数据渲染完场之后，v-cloak 属性会被自动去除， v-cloak一旦移除也就是没有这个属性了 属性选择器就选择不到该标签 也就是对应的标签会变为可见 --&gt; &lt;div v-cloak&gt;{{msg}}&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ // el指定元素 id 是 app 的元素 el: '#app', // data 里面存储的是数据 data: { msg: 'Hello Vue' } });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-text v-text指令用于将数据填充到标签中，作用于插值表达式类似，但是没有闪动问题 如果数据中有HTML标签会将html标签一并输出 注意：此处为单向绑定，数据对象上的值改变，插值会发生变化；但是当插值发生变化并不会影响数据对象的值。 12345678910111213141516171819202122&lt;div id=\"app\"&gt; &lt;!-- 注意:在指令中不要写插值语法 直接写对应的变量名称 在 v-text 中 赋值的时候不要在写 插值语法 一般属性中不加 {{}} 直接写 对应 的数据名 --&gt; &lt;p v-text=\"msg\"&gt;&lt;/p&gt; &lt;p&gt; &lt;!-- Vue 中只有在标签的 内容中 才用插值语法 --&gt; {{msg}} &lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { msg: 'Hello Vue.js' } });&lt;/script&gt; v-html 用法和v-text 相似 但是他可以将HTML片段填充到标签中 可能有安全问题, 一般只在可信任内容上使用 v-html，永不用在用户提交的内容上 它与v-text区别在于v-text输出的是纯文本，浏览器不会对其再进行html解析，但v-html会将其当html标签解析后输出。 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;p v-html=\"html\"&gt;&lt;/p&gt; &lt;!-- 输出：html标签在渲染的时候被解析 --&gt; &lt;p&gt;{{message}}&lt;/p&gt; &lt;!-- 输出：&lt;span&gt;通过双括号绑定&lt;/span&gt; --&gt; &lt;p v-text=\"text\"&gt;&lt;/p&gt; &lt;!-- 输出：&lt;span&gt;html标签在渲染的时候被源码输出&lt;/span&gt; --&gt;&lt;/div&gt;&lt;script&gt; let app = new Vue({ el: \"#app\", data: { message: \"&lt;span&gt;通过双括号绑定&lt;/span&gt;\", html: \"&lt;span&gt;html标签在渲染的时候被解析&lt;/span&gt;\", text: \"&lt;span&gt;html标签在渲染的时候被源码输出&lt;/span&gt;\", } });&lt;/script&gt; v-pre 显示原始信息跳过编译过程 跳过这个元素和它的子元素的编译过程。 一些静态的内容不需要编译加这个指令可以加快渲染 123456789101112 &lt;span v-pre&gt;{{ this will not be compiled }}&lt;/span&gt; &lt;!-- 显示的是{{ this will not be compiled }} --&gt; &lt;span v-pre&gt;{{msg}}&lt;/span&gt; &lt;!-- 即使data里面定义了msg这里仍然是显示的{{msg}} --&gt;&lt;script&gt; new Vue({ el: '#app', data: { msg: 'Hello Vue.js' } });&lt;/script&gt; text html pre比较 v-text指令用于将数据填充到标签中，作用于插值表达式类似，但是没有闪动问题v-html指令用于将HTML片段填充到标签中，但是可能有安全问题v-pre用于显示原始信息 v-once 执行一次性的插值【当数据改变时，插值处的内容不会继续更新】 12345678910 &lt;!-- 即使data里面定义了msg 后期我们修改了 仍然显示的是第一次data里面存储的数据即 Hello Vue.js --&gt; &lt;span v-once&gt;{{ msg}}&lt;/span&gt; &lt;script&gt; new Vue({ el: '#app', data: { msg: 'Hello Vue.js' } });&lt;/script&gt; 双向数据绑定 当数据发生变化的时候，视图也就发生变化 当视图发生变化的时候，数据也会跟着同步变化 v-model v-model是一个指令，限制在 &lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;、components中使用 1234567&lt;div id=\"app\"&gt; &lt;div&gt;{{msg}}&lt;/div&gt; &lt;div&gt; 当输入框中内容改变的时候， 页面上的msg 会自动更新 &lt;input type=\"text\" v-model='msg'&gt; &lt;/div&gt; &lt;/div&gt; v-on 用来绑定事件的 形式如：v-on:click 缩写为 @click; v-on事件函数中传入参数12345678910111213141516171819202122232425262728293031&lt;body&gt;&lt;div id=\"app\"&gt; &lt;div&gt;{{num}}&lt;/div&gt; &lt;div&gt; &lt;!-- 如果事件直接绑定函数名称，那么默认会传递事件对象作为事件函数的第一个参数 --&gt; &lt;button v-on:click='handle1'&gt;点击1&lt;/button&gt; &lt;!-- 2、如果事件绑定函数调用，那么事件对象必须作为最后一个参数显示传递， 并且事件对象的名称必须是$event --&gt; &lt;button v-on:click='handle2(123, 456, $event)'&gt;点击2&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el: '#app', data: { num: 0 }, methods: { handle1: function(event) { console.log(event.target.innerHTML) }, handle2: function(p, p1, event) { console.log(p, p1) console.log(event.target.innerHTML) this.num++; } } });&lt;/script&gt; v-bind v-bind 指令被用来响应地更新HTML属性 v-bind:href 可以缩写为 :href; 12345&lt;!-- 绑定一个属性 --&gt;&lt;img v-bind:src=\"imageSrc\"&gt;&lt;!-- 缩写 --&gt;&lt;img :src=\"imageSrc\"&gt; 绑定对象 我们可以给v-bind:class 一个对象，以动态地切换class。 注意：v-bind:class指令可以与普通的class特性共存 12345678910111213141516171819202122232425262728293031323334353637383940414243441、 v-bind 中支持绑定一个对象 如果绑定的是一个对象 则 键为 对应的类名 值 为对应data中的数据 &lt;!-- HTML最终渲染为 &lt;ul class=\"box textColor textSize\"&gt;&lt;/ul&gt; 注意： textColor，textSize 对应的渲染到页面上的CSS类名 isColor，isSize 对应vue data中的数据 如果为true 则对应的类名 渲染到页面上 当 isColor 和 isSize 变化时，class列表将相应的更新， 例如，将isSize改成false， class列表将变为 &lt;ul class=\"box textColor\"&gt;&lt;/ul&gt;--&gt;&lt;ul class=\"box\" v-bind:class=\"{textColor:isColor, textSize:isSize}\"&gt; &lt;li&gt;学习Vue&lt;/li&gt; &lt;li&gt;学习Node&lt;/li&gt; &lt;li&gt;学习React&lt;/li&gt;&lt;/ul&gt; &lt;div v-bind:style=\"{color:activeColor,fontSize:activeSize}\"&gt;对象语法&lt;/div&gt;&lt;sript&gt;var vm= new Vue({ el:'.box', data:{ isColor:true, isSize:true， activeColor:\"red\", activeSize:\"25px\", }})&lt;/sript&gt;&lt;style&gt; .box{ border:1px dashed #f0f; } .textColor{ color:#f00; background-color:#eef; } .textSize{ font-size:30px; font-weight:bold; }&lt;/style&gt; 绑定class123456789101112131415161718192021222324252627282930312、 v-bind 中支持绑定一个数组 数组中classA和 classB 对应为data中的数据这里的classA 对用data 中的 classA这里的classB 对用data 中的 classB&lt;ul class=\"box\" :class=\"[classA, classB]\"&gt; &lt;li&gt;学习Vue&lt;/li&gt; &lt;li&gt;学习Node&lt;/li&gt; &lt;li&gt;学习React&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var vm= new Vue({ el:'.box', data:{ classA:‘textColor‘, classB:‘textSize‘ }})&lt;/script&gt;&lt;style&gt; .box{ border:1px dashed #f0f; } .textColor{ color:#f00; background-color:#eef; } .textSize{ font-size:30px; font-weight:bold; }&lt;/style&gt; 绑定对象和绑定数组 的区别 绑定对象的时候 对象的属性 即要渲染的类名 对象的属性值对应的是 data 中的数据 绑定数组的时候数组里面存的是data 中的数据 绑定style12345678910111213141516171819202122232425262728 &lt;div v-bind:style=\"styleObject\"&gt;绑定样式对象&lt;/div&gt;' &lt;!-- CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) --&gt; &lt;div v-bind:style=\"{ color: activeColor, fontSize: fontSize,background:'red' }\"&gt;内联样式&lt;/div&gt;&lt;!--组语法可以将多个样式对象应用到同一个元素 --&gt;&lt;div v-bind:style=\"[styleObj1, styleObj2]\"&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { styleObject: { color: 'green', fontSize: '30px', background:'red' }， activeColor: 'green', fontSize: \"30px\" }, styleObj1: { color: 'red' }, styleObj2: { fontSize: '30px' }&lt;/script&gt; v-if判断v-if 使用场景 1- 多个元素 通过条件判断展示或者隐藏某个元素。或者多个元素 2- 进行两个视图之间的切换 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div id=\"app\"&gt; &lt;!-- 判断是否加载，如果为真，就加载，否则不加载--&gt; &lt;span v-if=\"flag\"&gt; 如果flag为true则显示,false不显示! &lt;/span&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el:\"#app\", data:{ flag:true } })&lt;/script&gt;---------------------------------------------------------- &lt;div v-if=\"type === 'A'\"&gt; A &lt;/div&gt; &lt;!-- v-else-if紧跟在v-if或v-else-if之后 表示v-if条件不成立时执行--&gt; &lt;div v-else-if=\"type === 'B'\"&gt; B &lt;/div&gt; &lt;div v-else-if=\"type === 'C'\"&gt; C &lt;/div&gt; &lt;!-- v-else紧跟在v-if或v-else-if之后--&gt; &lt;div v-else&gt; Not A/B/C &lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { type: 'C' } })&lt;/script&gt; v-show 和 v-if的区别 v-show本质就是标签display设置为none，控制隐藏 v-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，故v-show性能更好一点。 v-if是动态的向DOM树内添加或者删除DOM元素 v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件 v-for循环结构用于循环的数组里面的值可以是对象，也可以是普通元素 123456789101112131415161718192021&lt;ul id=\"example-1\"&gt; &lt;!-- 循环结构-遍历数组 item 是我们自己定义的一个名字 代表数组里面的每一项 items对应的是 data中的数组--&gt; &lt;li v-for=\"item in items\"&gt; {{ item.message }} &lt;/li&gt; &lt;/ul&gt;&lt;script&gt; new Vue({ el: '#example-1', data: { items: [ { message: 'Foo' }, { message: 'Bar' } ]， }})&lt;/script&gt; 不推荐同时使用 v-if 和 v-for 当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。 1234567891011121314151617181920212223 &lt;!-- 循环结构-遍历对象 v 代表 对象的value k 代表对象的 键 i 代表索引 ---&gt; &lt;div v-if='v==13' v-for='(v,k,i) in obj'&gt;{{v + '---' + k + '---' + i}}&lt;/div&gt;&lt;script&gt; new Vue({ el: '#example-1', data: { items: [ { message: 'Foo' }, { message: 'Bar' } ]， obj: { uname: 'zhangsan', age: 13, gender: 'female' } }})&lt;/script&gt; key 的作用 key来给每个节点做一个唯一标识 key的作用主要是为了高效的更新虚拟DOM 123&lt;ul&gt; &lt;li v-for=\"item in items\" :key=\"item.id\"&gt;...&lt;/li&gt;&lt;/ul&gt; 案例选项卡1、 HTML 结构123456789101112131415161718` &lt;div id=\"app\"&gt; &lt;div class=\"tab\"&gt; &lt;!-- tab栏 --&gt; &lt;ul&gt; &lt;li class=\"active\"&gt;apple&lt;/li&gt; &lt;li class=\"\"&gt;orange&lt;/li&gt; &lt;li class=\"\"&gt;lemon&lt;/li&gt; &lt;/ul&gt; &lt;!-- 对应显示的图片 --&gt; &lt;div class=\"current\"&gt;&lt;img src=\"img/apple.png\"&gt;&lt;/div&gt; &lt;div class=\"\"&gt;&lt;img src=\"img/orange.png\"&gt;&lt;/div&gt; &lt;div class=\"\"&gt;&lt;img src=\"img/lemon.png\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;` 2、 提供的数据12345678910111213list: [{ id: 1, title: 'apple', path: 'img/apple.png' }, { id: 2, title: 'orange', path: 'img/orange.png' }, { id: 3, title: 'lemon', path: 'img/lemon.png' }] 3、 把数据渲染到页面 把tab栏 中的数替换到页面上 把 data 中 title 利用 v-for 循环渲染到页面上 把 data 中 path利用 v-for 循环渲染到页面上 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;div id=\"app\"&gt; &lt;div class=\"tab\"&gt; &lt;ul&gt; &lt;!-- 1、绑定key的作用 提高Vue的性能 2、 key 需要是唯一的标识 所以需要使用id， 也可以使用index ， index 也是唯一的 3、 item 是 数组中对应的每一项 4、 index 是 每一项的 索引 --&gt; &lt;li :key='item.id' v-for='(item,index) in list'&gt;{{item.title}}&lt;/li&gt; &lt;/ul&gt; &lt;div :key='item.id' v-for='(item, index) in list'&gt; &lt;!-- : 是 v-bind 的简写 绑定属性使用 v-bind --&gt; &lt;img :src=\"item.path\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;script&gt; new Vue({ // 指定 操作元素 是 id 为app 的 el: '#app', data: { list: [{ id: 1, title: 'apple', path: 'img/apple.png' }, { id: 2, title: 'orange', path: 'img/orange.png' }, { id: 3, title: 'lemon', path: 'img/lemon.png' }] } })&lt;/script&gt; 4、 给每一个tab栏添加事件,并让选中的高亮 4.1 、让默认的第一项tab栏高亮 tab栏高亮 通过添加类名active 来实现 （CSS active 的样式已经提前写好） 在data 中定义一个 默认的 索引 currentIndex 为 0 给第一个li 添加 active 的类名 通过动态绑定class 来实现 第一个li 的索引为 0 和 currentIndex 的值刚好相等 currentIndex === index 如果相等 则添加类名 active 否则 添加 空类名 4.2 、让默认的第一项tab栏对应的div 显示 实现思路 和 第一个 tab 实现思路一样 只不过 这里控制第一个div 显示的类名是 current 123456789101112131415161718192021222324252627282930313233343536 &lt;ul&gt; &lt;!-- 动态绑定class 有 active 类名高亮 无 active 不高亮--&gt; &lt;li :class='currentIndex==index?\"active\":\"\"' :key='item.id' v-for='(item,index) in list' &gt;{{item.title}}&lt;/li&gt; &lt;/ul&gt; &lt;!-- 动态绑定class 有 current 类名显示 无 current 隐藏--&gt; &lt;div :class='currentIndex==index?\"current\":\"\"' :key='item.id' v-for='(item, index) in list'&gt; &lt;!-- : 是 v-bind 的简写 绑定属性使用 v-bind --&gt; &lt;img :src=\"item.path\"&gt; &lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { currentIndex: 0, // 选项卡当前的索引 默认为 0 list: [{ id: 1, title: 'apple', path: 'img/apple.png' }, { id: 2, title: 'orange', path: 'img/orange.png' }, { id: 3, title: 'lemon', path: 'img/lemon.png' }] } })&lt;/script&gt; 4.3 、点击每一个tab栏 当前的高亮 其他的取消高亮 给每一个li添加点击事件 让当前的索引 index 和 当前 currentIndex 的 值 进项比较 如果相等 则当前li 添加active 类名 当前的 li 高亮 当前对应索引的 div 添加 current 当前div 显示 其他隐藏 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 &lt;div id=\"app\"&gt; &lt;div class=\"tab\"&gt; &lt;ul&gt; &lt;!-- 通过v-on 添加点击事件 需要把当前li 的索引传过去 --&gt; &lt;li v-on:click='change(index)' :class='currentIndex==index?\"active\":\"\"' :key='item.id' v-for='(item,index) in list'&gt;{{item.title}}&lt;/li&gt; &lt;/ul&gt; &lt;div :class='currentIndex==index?\"current\":\"\"' :key='item.id' v-for='(item, index) in list'&gt; &lt;img :src=\"item.path\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { currentIndex: 0, // 选项卡当前的索引 默认为 0 list: [{ id: 1, title: 'apple', path: 'img/apple.png' }, { id: 2, title: 'orange', path: 'img/orange.png' }, { id: 3, title: 'lemon', path: 'img/lemon.png' }] }, methods: { change: function(index) { // 通过传入过来的索引来让当前的 currentIndex 和点击的index 值 相等 // 从而实现 控制类名 this.currentIndex = index; } } })&lt;/script&gt; Vue选项表单基本操作 获取单选框中的值 通过v-model 123456789101112131415161718192021 &lt;!-- 1、 两个单选框需要同时通过v-model 双向绑定 一个值 2、 每一个单选框必须要有value属性 且value 值不能一样 3、 当某一个单选框选中的时候 v-model 会将当前的 value值 改变 data 中的 数据 gender 的值就是选中的值，我们只需要实时监控他的值就可以了 --&gt; &lt;input type=\"radio\" id=\"male\" value=\"1\" v-model='gender'&gt; &lt;label for=\"male\"&gt;男&lt;/label&gt; &lt;input type=\"radio\" id=\"female\" value=\"2\" v-model='gender'&gt; &lt;label for=\"female\"&gt;女&lt;/label&gt;&lt;script&gt; new Vue({ data: { // 默认会让当前的 value 值为 2 的单选框选中 gender: 2, }, })&lt;/script&gt; 获取复选框中的值 通过v-model 和获取单选框中的值一样 复选框 checkbox 这种的组合时 data 中的 hobby 我们要定义成数组 否则无法实现多选 12345678910111213141516171819202122232425 &lt;!-- 1、 复选框需要同时通过v-model 双向绑定 一个值 2、 每一个复选框必须要有value属性 且value 值不能一样 3、 当某一个单选框选中的时候 v-model 会将当前的 value值 改变 data 中的 数据 hobby 的值就是选中的值，我们只需要实时监控他的值就可以了 --&gt;&lt;div&gt; &lt;span&gt;爱好：&lt;/span&gt; &lt;input type=\"checkbox\" id=\"ball\" value=\"1\" v-model='hobby'&gt; &lt;label for=\"ball\"&gt;篮球&lt;/label&gt; &lt;input type=\"checkbox\" id=\"sing\" value=\"2\" v-model='hobby'&gt; &lt;label for=\"sing\"&gt;唱歌&lt;/label&gt; &lt;input type=\"checkbox\" id=\"code\" value=\"3\" v-model='hobby'&gt; &lt;label for=\"code\"&gt;写代码&lt;/label&gt; &lt;/div&gt;&lt;script&gt; new Vue({ data: { // 默认会让当前的 value 值为 2 和 3 的复选框选中 hobby: ['2', '3'], }, })&lt;/script&gt; 获取下拉框和文本框中的值 通过v-model 123456789101112131415161718192021222324252627 &lt;div&gt; &lt;span&gt;职业：&lt;/span&gt; &lt;!-- 1、 需要给select 通过v-model 双向绑定 一个值 2、 每一个option 必须要有value属性 且value 值不能一样 3、 当某一个option选中的时候 v-model 会将当前的 value值 改变 data 中的 数据 occupation 的值就是选中的值，我们只需要实时监控他的值就可以了 --&gt; &lt;!-- multiple 多选 --&gt; &lt;select v-model='occupation' multiple&gt; &lt;option value=\"0\"&gt;请选择职业...&lt;/option&gt; &lt;option value=\"1\"&gt;教师&lt;/option&gt; &lt;option value=\"2\"&gt;软件工程师&lt;/option&gt; &lt;option value=\"3\"&gt;律师&lt;/option&gt; &lt;/select&gt; &lt;!-- textarea 是 一个双标签 不需要绑定value 属性的 --&gt; &lt;textarea v-model='desc'&gt;&lt;/textarea&gt; &lt;/div&gt;&lt;script&gt; new Vue({ data: { // 默认会让当前的 value 值为 2 和 3 的下拉框选中 occupation: ['2', '3'], desc: 'nihao' }, })&lt;/script&gt; 表单修饰符 .number 转换为数值 如果你先输入数字，那它就会限制你输入的只能是数字。 如果你先输入字符串，那它就相当于没有加.number .trim 自动过滤用户输入的首尾空白字符 只能去掉首尾的 不能去除中间的空格 .lazy 将input事件切换成change事件 .lazy 修饰符延迟了同步更新属性值的时机。即将原本绑定在 input 事件的同步逻辑转变为绑定在 change 事件上,在失去焦点 或者 按下回车键时才更新。 12345678&lt;!-- 自动将用户的输入值转为数值类型 --&gt;&lt;input v-model.number=\"age\" type=\"number\"&gt;&lt;!--自动过滤用户输入的首尾空白字符 --&gt;&lt;input v-model.trim=\"msg\"&gt;&lt;!-- 在“change”时而非“input”时更新 --&gt;&lt;input v-model.lazy=\"msg\" &gt; v-bind修饰符 .sync(2.3.0+ 新增) 在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。我们通常的做法是 12345678910//父亲组件&lt;comp :myMessage=\"bar\" @update:myMessage=\"func\"&gt;&lt;/comp&gt;//jsfunc(e){ this.bar = e;}//子组件jsfunc2(){ this.$emit('update:myMessage',params);} 现在这个.sync修饰符就是简化了上面的步骤 1234//父组件&lt;comp :myMessage.sync=\"bar\"&gt;&lt;/comp&gt; //子组件this.$emit('update:myMessage',params); 这样确实会方便很多，但是也有很多需要注意的点 使用sync的时候，子组件传递的事件名必须为update:value，其中value必须与子组件中props中声明的名称完全一致(如上例中的myMessage，不能使用my-message) 注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync=”doc.title + ‘!’” 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 v-model。 将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync=”{ title: doc.title }”，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。 .prop 要学习这个修饰符，我们首先要搞懂两个东西的区别。 1234Property：节点对象在内存中存储的属性，可以访问和设置。Attribute：节点对象的其中一个属性( property )，值是一个对象。可以通过点访问法 document.getElementById('xx').attributes 或者 document.getElementById('xx').getAttributes('xx') 读取，通过 document.getElementById('xx').setAttribute('xx',value) 新增和修改。在标签里定义的所有属性包括 HTML 属性和自定义属性都会在 attributes 对象里以键值对的方式存在。 其实attribute和property两个单词，翻译出来都是属性，但是《javascript高级程序设计》将它们翻译为特性和属性，以示区分 123456//这里的id,value,style都属于property//index属于attribute//id、title等既是属性，也是特性。修改属性，其对应的特性会发生改变；修改特性，属性也会改变&lt;input id=\"uid\" title=\"title1\" value=\"1\" :index=\"index\"&gt;//input.index === undefined//input.attributes.index === this.index 从上面我们可以看到如果直接使用v-bind绑定，则默认会绑定到dom节点的attribute。为了 通过自定义属性存储变量，避免暴露数据 防止污染 HTML 结构 我们可以使用这个修饰符，如下 123&lt;input id=\"uid\" title=\"title1\" value=\"1\" :index.prop=\"index\"&gt;//input.index === this.index//input.attributes.index === undefined .camel 由于HTML 特性是不区分大小写的。 1&lt;svg :viewBox=\"viewBox\"&gt;&lt;/svg&gt; 实际上会渲染为 1&lt;svg viewbox=\"viewBox\"&gt;&lt;/svg&gt; 这将导致渲染失败，因为 SVG 标签只认 viewBox，却不知道 viewbox 是什么。如果我们使用.camel修饰符，那它就会被渲染为驼峰名。另，如果你使用字符串模版，则没有这些限制。 123new Vue({ template: '&lt;svg :viewBox=\"viewBox\"&gt;&lt;/svg&gt;'}) 事件修饰符/v-on在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。 Vue 不推荐我们操作DOM，为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符 修饰符是由点开头的指令后缀来表示的 .stop 阻止冒泡 一键阻止事件冒泡，简直方便得不行。相当于调用了event.stopPropagation()方法。 .prevent 用于阻止事件的默认行为，例如，当点击提交按钮时阻止对表单的提交。相当于调用了event.preventDefault()方法。 .capture 从上面我们知道了事件的冒泡，其实完整的事件机制是：捕获阶段–目标阶段–冒泡阶段。默认的呢，是事件触发是从目标开始往上冒泡。当我们加了这个.capture以后呢，我们就反过来了，事件触发从包含这个元素的顶层开始往下触发。 12345678910111213&lt;div @click.capture=\"shout(1)\"&gt; obj1 &lt;div @click.capture=\"shout(2)\"&gt; obj2 &lt;div @click=\"shout(3)\"&gt; obj3 &lt;div @click=\"shout(4)\"&gt; obj4 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; // 1 2 4 3 从上面这个例子我们点击obj4的时候，就可以清楚地看出区别，obj1，obj2在捕获阶段就触发了事件，因此是先1后2，后面的obj3，obj4是默认的冒泡阶段触发，因此是先4然后冒泡到3~ .self 只当事件是从事件绑定的元素本身触发时才触发回调。像下面所示，刚刚我们从.stop时候知道子元素会冒泡到父元素导致触发父元素的点击事件，当我们加了这个.self以后，我们点击button不会触发父元素的点击事件shout，只有当点击到父元素的时候（蓝色背景）才会shout~从这个self的英文翻译过来就是‘自己，本身’可以看出这个修饰符的用法 .once 事件只触发一次 .passive 当我们在监听元素滚动事件的时候，会一直触发onscroll事件，在pc端是没啥问题的，但是在移动端，会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给onscroll事件整了一个.lazy修饰符 1234&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;&lt;!-- 而不会等待 `onScroll` 完成 --&gt;&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;&lt;div v-on:scroll.passive=\"onScroll\"&gt;...&lt;/div&gt; .native 我们经常会写很多的小组件，有些小组件可能会绑定一些事件，但是，像下面这样绑定事件是不会触发的 1&lt;My-component @click=\"shout(3)\"&gt;&lt;/My-component&gt; 必须使用.native来修饰这个click事件（即&lt;My-component @click.native=”shout(3)”&gt;&lt;/My-component&gt;），可以理解为该修饰符的作用就是把一个vue组件转化为一个普通的HTML标签，注意：使用.native修饰符来操作普通HTML标签是会令事件失效的 注意：修饰符可以同时使用多个,但是可能会因为顺序而有所不同。用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。也就是从左往右判断~ 123456789101112&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联，即阻止冒泡也阻止默认事件 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt; 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。 鼠标按钮修饰符刚刚我们讲到这个click事件，我们一般是会用左键触发，有时候我们需要更改右键菜单啥的，就需要用到右键点击或者中间键点击，这个时候就要用到鼠标按钮修饰符 .left 左键点击 .right 右键点击 .middle 中键点击 1&lt;button @click.right=\"shout(1)\"&gt;ok&lt;/button&gt; 按键修饰符在做项目中有时会用到键盘事件，在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;&lt;input v-on:keyup.13=\"submit\"&gt;&lt;!-- -当点击enter 时调用 `vm.submit()` --&gt;&lt;input v-on:keyup.enter=\"submit\"&gt;&lt;!--当点击enter或者space时 时调用 `vm.alertMe()` --&gt;&lt;input type=\"text\" v-on:keyup.enter.space=\"alertMe\" &gt;&lt;!--常用的按键修饰符.enter =&gt; enter键.tab =&gt; tab键.delete (捕获“删除”和“退格”按键) =&gt; 删除键.esc =&gt; 取消键.space =&gt; 空格键.up =&gt; 上.down =&gt; 下.left =&gt; 左.right =&gt; 右//系统修饰键.ctrl.alt.meta.shift--&gt;&lt;script&gt; var vm = new Vue({ el:\"#app\", methods: { submit:function(){}, alertMe:function(){}, } })&lt;/script&gt;// 可以通过全局 config.keyCodes 对象自定义按键修饰符别名：// 可以使用 `v-on:keyup.f1`Vue.config.keyCodes.f1 = 112 我们从上面看到，键分成了普通常用的键和系统修饰键，区别是什么呢？当我们写如下代码的时候,我们会发现如果仅仅使用系统修饰键是无法触发keyup事件的。 1&lt;input type=\"text\" @keyup.ctrl=\"shout(4)\"&gt; 那该如何呢？我们需要将系统修饰键和其他键码链接起来使用，比如 1&lt;input type=\"text\" @keyup.ctrl.67=\"shout(4)\"&gt; 这样当我们同时按下ctrl+c时，就会触发keyup事件。另，如果是鼠标事件，那就可以单独使用系统修饰符。 123&lt;button @mouseover.ctrl=\"shout(1)\"&gt;ok&lt;/button&gt;&lt;button @mousedown.ctrl=\"shout(1)\"&gt;ok&lt;/button&gt;&lt;button @click.ctrl.67=\"shout(1)\"&gt;ok&lt;/button&gt; 大概是什么意思呢，就是你不能单手指使用系统修饰键的修饰符（最少两个手指，可以多个）。你可以一个手指按住系统修饰键一个手指按住另外一个键来实现键盘事件。也可以用一个手指按住系统修饰键，另一只手按住鼠标来实现鼠标事件。 .exact (2.5新增) 我们上面说了这个系统修饰键，当我们像这样&lt;button type=”text” @click.ctrl=”shout(4)”&gt;绑定了click键按下的事件，惊奇的是，我们同时按下几个系统修饰键，比如ctrl shift点击，也能触发，可能有些场景我们只需要或者只能按一个系统修饰键来触发（像制作一些快捷键的时候），而当我们按下ctrl和其他键的时候则无法触发。那就这样写。注意：这个只是限制系统修饰键的，像下面这样书写以后你还是可以按下ctrl + c，ctrl+v或者ctrl+普通键 来触发，但是不能按下ctrl + shift +普通键来触发。 1&lt;button type=\"text\" @click.ctrl.exact=\"shout(4)\"&gt;ok&lt;/button&gt; 然后下面这个你可以同时按下enter+普通键来触发，但是不能按下系统修饰键+enter来触发。相信你已经能听懂了8~ 1&lt;input type=\"text\" @keydown.enter.exact=\"shout('我被触发了')\"&gt; 自定义按键修饰符别名在Vue中可以通过config.keyCodes自定义按键修饰符别名 123456789101112131415&lt;div id=\"app\"&gt; &lt;!-- 预先定义了keycode 116（即F5）的别名为f5，因此在文字输入框中按下F5，会触发prompt方法 --&gt; &lt;input type=\"text\" v-on:keydown.f5=\"prompt()\"&gt;&lt;/div&gt;&lt;script&gt; Vue.config.keyCodes.f5 = 116; let app = new Vue({ el: '#app', methods: { prompt: function() { alert('我是 F5！'); } } });&lt;/script&gt; 自定义指令 内置指令不能满足我们特殊的需求 Vue允许我们自定义指令 Vue.directive 注册全局指令使用自定义的指令，只需在对用的元素中，加上’v-‘的前缀形成类似于内部指令’v-if’，’v-text’的形式。 123456789101112131415161718&lt;input type=\"text\" v-focus&gt;&lt;script&gt;// 注意点： // 1、 在自定义指令中 如果以驼峰命名的方式定义 如 Vue.directive('focusA',function(){}) // 2、 在HTML中使用的时候 只能通过 v-focus-a 来使用 // 注册一个全局自定义指令 v-focusVue.directive('focus', { // 当绑定元素插入到 DOM 中。 其中 el为dom元素 inserted: function (el) { // 聚焦元素 el.focus(); }});new Vue({ el:'#app'});&lt;/script&gt; Vue.directive 注册全局指令 带参数12345678910111213141516171819202122232425 &lt;input type=\"text\" v-color='msg'&gt;&lt;script type=\"text/javascript\"&gt; /* 自定义指令-带参数 bind - 只调用一次，在指令第一次绑定到元素上时候调用 */ Vue.directive('color', { // bind声明周期, 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置 // el 为当前自定义指令的DOM元素 // binding 为自定义的函数形参 通过自定义属性传递过来的值 存在 binding.value 里面 bind: function(el, binding){ // 根据指令的参数设置背景色 // console.log(binding.value.color) el.style.backgroundColor = binding.value.color; } }); var vm = new Vue({ el: '#app', data: { msg: { color: 'blue' } } }); &lt;/script&gt; 自定义指令局部指令 局部指令，需要定义在directives 的选项 用法和全局用法一样 局部指令只能在当前组件里面使用 当全局指令和局部指令同名时以局部指令为准 12345678910111213141516171819202122232425262728&lt;input type=\"text\" v-color='msg'&gt; &lt;input type=\"text\" v-focus&gt; &lt;script type=\"text/javascript\"&gt; /* 自定义指令-局部指令 */ var vm = new Vue({ el: '#app', data: { msg: { color: 'red' } }, //局部指令，需要定义在 directives 的选项 directives: { color: { bind: function(el, binding){ el.style.backgroundColor = binding.value.color; } }, focus: { inserted: function(el) { el.focus(); } } } }); &lt;/script&gt; 计算属性 computed 模板中放入太多的逻辑会让模板过重且难以维护 使用计算属性可以让模板更加的简洁 计算属性是基于它们的响应式依赖进行缓存的 computed比较适合对多个变量或者对象进行处理后返回一个结果值，也就是数多个变量中的某一个值发生了变化则我们监控的这个值也就会发生变化 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;div id=\"app\"&gt; &lt;!-- 当多次调用 reverseString 的时候 只要里面的 num 值不改变 他会把第一次计算的结果直接返回 直到data 中的num值改变 计算属性才会重新发生计算 --&gt; &lt;div&gt;{{reverseString}}&lt;/div&gt; &lt;div&gt;{{reverseString}}&lt;/div&gt; &lt;!-- 调用methods中的方法的时候 他每次会重新调用 --&gt; &lt;div&gt;{{reverseMessage()}}&lt;/div&gt; &lt;div&gt;{{reverseMessage()}}&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; /* 计算属性与方法的区别:计算属性是基于依赖进行缓存的，而方法不缓存 */ var vm = new Vue({ el: '#app', data: { msg: 'Nihao', num: 100 }, methods: { reverseMessage: function(){ console.log('methods') return this.msg.split('').reverse().join(''); } }, //computed 属性 定义 和 data 已经 methods 平级 computed: { // reverseString 这个是我们自己定义的名字 reverseString: function(){ console.log('computed') var total = 0; // 当data 中的 num 的值改变的时候 reverseString 会自动发生计算 for(var i=0;i&lt;=this.num;i++){ total += i; } // 这里一定要有return 否则 调用 reverseString 的 时候无法拿到结果 return total; } } }); &lt;/script&gt; 你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果： 1234567&lt;p&gt;Reversed message: \"{{ reversedMessage() }}\"&lt;/p&gt;// 在组件中methods: { reversedMessage: function () { return this.message.split('').reverse().join('') }} 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 侦听器 watch 使用watch来响应数据的变化 一般用于异步或者开销较大的操作 watch 中的属性 一定是data 中 已经存在的数据 当需要监听一个对象的改变时，普通的watch方法无法监听到对象内部属性的改变，只有data中的数据才能够监听到变化，此时就需要deep属性对对象进行深度监听 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div id=\"app\"&gt; &lt;div&gt; &lt;span&gt;名：&lt;/span&gt; &lt;span&gt; &lt;input type=\"text\" v-model='firstName'&gt; &lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;姓：&lt;/span&gt; &lt;span&gt; &lt;input type=\"text\" v-model='lastName'&gt; &lt;/span&gt; &lt;/div&gt; &lt;div&gt;{{fullName}}&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; /* 侦听器 */ var vm = new Vue({ el: '#app', data: { firstName: 'Jim', lastName: 'Green', // fullName: 'Jim Green' }, //watch 属性 定义 和 data 已经 methods 平级 watch: { // 注意： 这里firstName 对应着data 中的 firstName // 当 firstName 值 改变的时候 会自动触发 watch firstName: function(val) { this.fullName = val + ' ' + this.lastName; }, // 注意： 这里 lastName 对应着data 中的 lastName lastName: function(val) { this.fullName = this.firstName + ' ' + val; } } }); &lt;/script&gt; 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 例如： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;div id=\"watch-example\"&gt; &lt;p&gt; Ask a yes/no question: &lt;input v-model=\"question\"&gt; &lt;/p&gt; &lt;p&gt;{{ answer }}&lt;/p&gt;&lt;/div&gt;&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js\"&gt;&lt;/script&gt;&lt;script&gt;var watchExampleVM = new Vue({ el: '#watch-example', data: { question: '', answer: 'I cannot give you an answer until you ask a question!' }, watch: { // 如果 `question` 发生改变，这个函数就会运行 question: function (newQuestion, oldQuestion) { this.answer = 'Waiting for you to stop typing...' this.debouncedGetAnswer() } }, created: function () { // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。 // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率 // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于 // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识， // 请参考：https://lodash.com/docs#debounce this.debouncedGetAnswer = _.debounce(this.getAnswer, 500) }, methods: { getAnswer: function () { if (this.question.indexOf('?') === -1) { this.answer = 'Questions usually contain a question mark. ;-)' return } this.answer = 'Thinking...' var vm = this axios.get('https://yesno.wtf/api') .then(function (response) { vm.answer = _.capitalize(response.data.answer) }) .catch(function (error) { vm.answer = 'Error! Could not reach the API. ' + error }) } }})&lt;/script&gt; 结果： Ask a yes/no question: I cannot give you an answer until you ask a question! 在这个示例中，使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 除了 watch 选项之外，您还可以使用命令式的 vm.$watch API。 计算属性 vs 侦听属性Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。细想一下这个例子： 1234567891011121314151617&lt;div id=\"demo\"&gt;{{ fullName }}&lt;/div&gt;var vm = new Vue({ el: '#demo', data: { firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' }, watch: { firstName: function (val) { this.fullName = val + ' ' + this.lastName }, lastName: function (val) { this.fullName = this.firstName + ' ' + val } }}) 上面代码是命令式且重复的。将它与计算属性的版本进行比较： 123456789101112var vm = new Vue({ el: '#demo', data: { firstName: 'Foo', lastName: 'Bar' }, computed: { fullName: function () { return this.firstName + ' ' + this.lastName } }}) 好得多了，不是吗？ 过滤器 Vue.js允许自定义过滤器，可被用于一些常见的文本格式化。 过滤器可以用在两个地方：双花括号插值和v-bind表达式。 过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示 支持级联操作 过滤器不改变真正的data，而只是改变渲染的结果，并返回过滤后的版本 全局注册时是filter，没有s的。而局部过滤器是filters，是有s的 1234567891011121314151617181920212223242526272829303132333435 &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model='msg'&gt; &lt;!-- upper 被定义为接收单个参数的过滤器函数，表达式 msg 的值将作为参数传入到函数中 --&gt; &lt;div&gt;{{msg | upper}}&lt;/div&gt; &lt;!-- 支持级联操作 upper 被定义为接收单个参数的过滤器函数，表达式msg 的值将作为参数传入到函数中。 然后继续调用同样被定义为接收单个参数的过滤器 lower ，将upper 的结果传递到lower中 --&gt; &lt;div&gt;{{msg | upper | lower}}&lt;/div&gt; &lt;div :abc='msg | upper'&gt;测试数据&lt;/div&gt; &lt;/div&gt;&lt;script type=\"text/javascript\"&gt; // lower 为全局过滤器 Vue.filter('lower', function(val) { return val.charAt(0).toLowerCase() + val.slice(1); }); var vm = new Vue({ el: '#app', data: { msg: '' }, //filters 属性 定义 和 data 已经 methods 平级 // 定义filters 中的过滤器为局部过滤器 filters: { // upper 自定义的过滤器名字 // upper 被定义为接收单个参数的过滤器函数，表达式 msg 的值将作为参数传入到函数中 upper: function(val) { // 过滤器中一定要有返回值 这样外界使用过滤器的时候才能拿到结果 return val.charAt(0).toUpperCase() + val.slice(1); } } }); &lt;/script&gt; 过滤器中传递参数123456789101112131415161718192021222324252627 &lt;div id=\"box\"&gt; &lt;!-- filterA 被定义为接收三个参数的过滤器函数。 其中 message 的值作为第一个参数， 普通字符串 'arg1' 作为第二个参数，表达式 arg2 的值作为第三个参数。--&gt; {{ message | filterA('arg1', 'arg2') }} &lt;/div&gt; &lt;script&gt; // 在过滤器中 第一个参数 对应的是 管道符前面的数据 n 此时对应 message // 第2个参数 a 对应 实参 arg1 字符串 // 第3个参数 b 对应 实参 arg2 字符串 Vue.filter('filterA',function(n,a,b){ if(n&lt;10){ return n+a; }else{ return n+b; } }); new Vue({ el:\"#box\", data:{ message: \"哈哈哈\" } }) &lt;/script&gt; 生命周期 事物从出生到死亡的过程 Vue实例从创建 到销毁的过程 ，这些过程中会伴随着一些函数的自调用。我们称这些函数为钩子函数 不要在选项属性或回调上使用箭头函数，比如 created: () =&gt; console.log(this.a) 或 vm.$watch('a', newValue =&gt; this.myMethod())。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。 ####常用的 钩子函数 beforeCreate 在实例初始化之后，数据观测和事件配置之前被调用 此时data 和 methods 以及页面的DOM结构都没有初始化 什么都做不了 created 在实例创建完成后被立即调用此时data 和 methods已经可以使用 但是页面还没有渲染出来 beforeMount 在挂载开始之前被调用 此时页面上还看不到真实数据 只是一个模板页面而已 mounted el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。 数据已经真实渲染到页面上 在这个钩子函数里面我们可以使用一些第三方的插件 beforeUpdate 数据更新时调用，发生在虚拟DOM打补丁之前。 页面上数据还是旧的 updated 由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。 页面上数据已经替换成最新的 beforeDestroy 实例销毁之前调用 destroyed 实例销毁后调用 数组变异方法 在 Vue 中，直接修改对象属性的值无法触发响应式。当你直接修改了对象属性的值，你会发现，只有数据改了，但是页面内容并没有改变 变异数组方法即保持数组方法原有功能不变的前提下对其进行功能拓展 push() 往数组最后面添加一个元素，成功返回当前数组的长度 pop() 删除数组的最后一个元素，成功返回删除元素的值 shift() 删除数组的第一个元素，成功返回删除元素的值 unshift() 往数组最前面添加一个元素，成功返回当前数组的长度 splice() 有三个参数，第一个是想要删除的元素的下标（必选），第二个是想要删除的个数（必选），第三个是删除 后想要在原位置替换的值 sort() sort() 使数组按照字符编码默认从小到大排序,成功返回排序后的数组 reverse() reverse() 将数组倒序，成功返回倒序后的数组 替换数组不会改变原始数组，但总是返回一个新数组 filter filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 concat concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组 slice slice() 方法可从已有的数组中返回选定的元素。该方法并不会修改数组，而是返回一个子数组 动态数组响应式数据 Vue.set(a,b,c) 让 触发视图重新更新一遍，数据动态起来 a是要更改的数据 、 b是数据的第几项、 c是更改后的数据 图书列表案例 静态列表效果 基于数据实现模板效果 处理每行的操作按钮 1、 提供的静态数据 数据存放在vue 中 data 属性中 12345678910111213141516171819202122232425262728293031323334353637383940414243var vm = new Vue({ el: '#app', data: { books: [{ id: 1, name: '三国演义', date: '' },{ id: 2, name: '水浒传', date: '' },{ id: 3, name: '红楼梦', date: '' },{ id: 4, name: '西游记', date: '' }] } }); var vm = new Vue({ el: '#app', data: { books: [{ id: 1, name: '三国演义', date: '' },{ id: 2, name: '水浒传', date: '' },{ id: 3, name: '红楼梦', date: '' },{ id: 4, name: '西游记', date: '' }] } }); 2、 把提供好的数据渲染到页面上 利用 v-for循环 遍历 books 将每一项数据渲染到对应的数据中 123456789101112131415 &lt;tbody&gt; &lt;tr :key='item.id' v-for='item in books'&gt; &lt;!-- 对应的id 渲染到页面上 --&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;!-- 对应的name 渲染到页面上 --&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.date}}&lt;/td&gt; &lt;td&gt; &lt;!-- 阻止 a 标签的默认跳转 --&gt; &lt;a href=\"\" @click.prevent&gt;修改&lt;/a&gt; &lt;span&gt;|&lt;/span&gt; &lt;a href=\"\" @click.prevent&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/tbody&gt; 3、 添加图书 通过双向绑定获取到输入框中的输入内容 给按钮添加点击事件 把输入框中的数据存储到 data 中的 books 里面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div&gt; &lt;h1&gt;图书管理&lt;/h1&gt; &lt;div class=\"book\"&gt; &lt;div&gt; &lt;label for=\"id\"&gt; 编号： &lt;/label&gt; &lt;!-- 3.1、通过双向绑定获取到输入框中的输入的 id --&gt; &lt;input type=\"text\" id=\"id\" v-model='id'&gt; &lt;label for=\"name\"&gt; 名称： &lt;/label&gt; &lt;!-- 3.2、通过双向绑定获取到输入框中的输入的 name --&gt; &lt;input type=\"text\" id=\"name\" v-model='name'&gt; &lt;!-- 3.3、给按钮添加点击事件 --&gt; &lt;button @click='handle'&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; /* 图书管理-添加图书 */ var vm = new Vue({ el: '#app', data: { id: '', name: '', books: [{ id: 1, name: '三国演义', date: '' },{ id: 2, name: '水浒传', date: '' },{ id: 3, name: '红楼梦', date: '' },{ id: 4, name: '西游记', date: '' }] }, methods: { handle: function(){ // 3.4 定义一个新的对象book 存储 获取到输入框中 书 的id和名字 var book = {}; book.id = this.id; book.name = this.name; book.date = ''; // 3.5 把book 通过数组的变异方法 push 放到 books 里面 this.books.push(book); //3.6 清空输入框 this.id = ''; this.name = ''; } } }); &lt;/script&gt; 4 修改图书-上 点击修改按钮的时候 获取到要修改的书籍名单 4.1 给修改按钮添加点击事件， 需要把当前的图书的id 传递过去 这样才知道需要修改的是哪一本书籍 把需要修改的书籍名单填充到表单里面 4.2 根据传递过来的id 查出books 中 对应书籍的详细信息 4.3 把获取到的信息填充到表单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;div id=\"app\"&gt; &lt;div class=\"grid\"&gt; &lt;div&gt; &lt;h1&gt;图书管理&lt;/h1&gt; &lt;div class=\"book\"&gt; &lt;div&gt; &lt;label for=\"id\"&gt; 编号： &lt;/label&gt; &lt;input type=\"text\" id=\"id\" v-model='id' :disabled=\"flag\"&gt; &lt;label for=\"name\"&gt; 名称： &lt;/label&gt; &lt;input type=\"text\" id=\"name\" v-model='name'&gt; &lt;button @click='handle'&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;时间&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr :key='item.id' v-for='item in books'&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.date}}&lt;/td&gt; &lt;td&gt; &lt;!--- 4.1 给修改按钮添加点击事件， 需要把当前的图书的id 传递过去 这样才知道需要修改的是哪一本书籍 ---&gt; &lt;a href=\"\" @click.prevent='toEdit(item.id)'&gt;修改&lt;/a&gt; &lt;span&gt;|&lt;/span&gt; &lt;a href=\"\" @click.prevent&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;script type=\"text/javascript\"&gt; /* 图书管理-添加图书 */ var vm = new Vue({ el: '#app', data: { flag: false, id: '', name: '', books: [{ id: 1, name: '三国演义', date: '' },{ id: 2, name: '水浒传', date: '' },{ id: 3, name: '红楼梦', date: '' },{ id: 4, name: '西游记', date: '' }] }, methods: { handle: function(){ // 3.4 定义一个新的对象book 存储 获取到输入框中 书 的id和名字 var book = {}; book.id = this.id; book.name = this.name; book.date = ''; // 3.5 把book 通过数组的变异方法 push 放到 books 里面 this.books.push(book); //3.6 清空输入框 this.id = ''; this.name = ''; }, toEdit: function(id){ console.log(id) //4.2 根据传递过来的id 查出books 中 对应书籍的详细信息 var book = this.books.filter(function(item){ return item.id == id; }); console.log(book) //4.3 把获取到的信息填充到表单 // this.id 和 this.name 通过双向绑定 绑定到了表单中 一旦数据改变视图自动更新 this.id = book[0].id; this.name = book[0].name; } } }); &lt;/script&gt; 5 修改图书-下 5.1 定义一个标识符， 主要是控制 编辑状态下当前编辑书籍的id 不能被修改 即 处于编辑状态下 当前控制书籍编号的输入框禁用 5.2 通过属性绑定给书籍编号的 绑定 disabled 的属性 flag 为 true 即为禁用 5.3 flag 默认值为false 处于编辑状态 要把 flag 改为true 即当前表单为禁用 5.4 复用添加方法 用户点击提交的时候依然执行 handle 中的逻辑如果 flag为true 即 表单处于不可输入状态 此时执行的用户编辑数据数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;div id=\"app\"&gt; &lt;div class=\"grid\"&gt; &lt;div&gt; &lt;h1&gt;图书管理&lt;/h1&gt; &lt;div class=\"book\"&gt; &lt;div&gt; &lt;label for=\"id\"&gt; 编号： &lt;/label&gt; &lt;!-- 5.2 通过属性绑定 绑定 disabled 的属性 flag 为 true 即为禁用 --&gt; &lt;input type=\"text\" id=\"id\" v-model='id' :disabled=\"flag\"&gt; &lt;label for=\"name\"&gt; 名称： &lt;/label&gt; &lt;input type=\"text\" id=\"name\" v-model='name'&gt; &lt;button @click='handle'&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;时间&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr :key='item.id' v-for='item in books'&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.date}}&lt;/td&gt; &lt;td&gt; &lt;a href=\"\" @click.prevent='toEdit(item.id)'&gt;修改&lt;/a&gt; &lt;span&gt;|&lt;/span&gt; &lt;a href=\"\" @click.prevent&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; /*图书管理-添加图书*/ var vm = new Vue({ el: '#app', data: { // 5.1 定义一个标识符， 主要是控制 编辑状态下当前编辑书籍的id 不能被修改 // 即 处于编辑状态下 当前控制书籍编号的输入框禁用 flag: false, id: '', name: '', }, methods: { handle: function() { /* 5.4 复用添加方法 用户点击提交的时候依然执行 handle 中的逻辑 如果 flag为true 即 表单处于不可输入状态 此时执行的用户编辑数据数据 */ if (this.flag) { // 编辑图书 // 5.5 根据当前的ID去更新数组中对应的数据 this.books.some((item) =&gt; { if (item.id == this.id) { // 箭头函数中 this 指向父级作用域的this item.name = this.name; // 完成更新操作之后，需要终止循环 return true; } }); // 5.6 编辑完数据后表单要处以可以输入的状态 this.flag = false; // 5.7 如果 flag为false 表单处于输入状态 此时执行的用户添加数据 } else { var book = {}; book.id = this.id; book.name = this.name; book.date = ''; this.books.push(book); // 清空表单 this.id = ''; this.name = ''; } // 清空表单 this.id = ''; this.name = ''; }, toEdit: function(id) { /* 5.3 flag 默认值为false 处于编辑状态 要把 flag 改为true 即当前表单为禁 用 */ this.flag = true; console.log(id) var book = this.books.filter(function(item) { return item.id == id; }); console.log(book) this.id = book[0].id; this.name = book[0].name; } } }); &lt;/script&gt; 6 删除图书 6.1 给删除按钮添加事件 把当前需要删除的书籍id 传递过来 6.2 根据id从数组中查找元素的索引 6.3 根据索引删除数组元素 123456789101112131415161718192021222324252627282930313233343536373839 &lt;tbody&gt; &lt;tr :key='item.id' v-for='item in books'&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.date}}&lt;/td&gt; &lt;td&gt; &lt;a href=\"\" @click.prevent='toEdit(item.id)'&gt;修改&lt;/a&gt; &lt;span&gt;|&lt;/span&gt; &lt;!-- 6.1 给删除按钮添加事件 把当前需要删除的书籍id 传递过来 --&gt; &lt;a href=\"\" @click.prevent='deleteBook(item.id)'&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/tbody&gt; &lt;script type=\"text/javascript\"&gt; /* 图书管理-添加图书 */ var vm = new Vue({ methods: { deleteBook: function(id){ // 删除图书 #// 6.2 根据id从数组中查找元素的索引 // var index = this.books.findIndex(function(item){ // return item.id == id; // }); #// 6.3 根据索引删除数组元素 // this.books.splice(index, 1); // ------------------------- #// 方法二：通过filter方法进行删除 # 6.4 根据filter 方法 过滤出来id 不是要删除书籍的id # 因为 filter 是替换数组不会修改原始数据 所以需要 把 不是要删除书籍的id 赋值给 books this.books = this.books.filter(function(item){ return item.id != id; }); } } }); &lt;/script&gt; 常用特性应用场景1 过滤器 Vue.filter 定义一个全局过滤器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 &lt;tr :key='item.id' v-for='item in books'&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;!-- 1.3 调用过滤器 --&gt; &lt;td&gt;{{item.date | format('yyyy-MM-dd hh:mm:ss')}}&lt;/td&gt; &lt;td&gt; &lt;a href=\"\" @click.prevent='toEdit(item.id)'&gt;修改&lt;/a&gt; &lt;span&gt;|&lt;/span&gt; &lt;a href=\"\" @click.prevent='deleteBook(item.id)'&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; #1.1 Vue.filter 定义一个全局过滤器 Vue.filter('format', function(value, arg) { function dateFormat(date, format) { if (typeof date === \"string\") { var mts = date.match(/(\\/Date\\((\\d+)\\)\\/)/); if (mts &amp;&amp; mts.length &gt;= 3) { date = parseInt(mts[2]); } } date = new Date(date); if (!date || date.toUTCString() == \"Invalid Date\") { return \"\"; } var map = { \"M\": date.getMonth() + 1, //月份 \"d\": date.getDate(), //日 \"h\": date.getHours(), //小时 \"m\": date.getMinutes(), //分 \"s\": date.getSeconds(), //秒 \"q\": Math.floor((date.getMonth() + 3) / 3), //季度 \"S\": date.getMilliseconds() //毫秒 }; format = format.replace(/([yMdhmsqS])+/g, function(all, t) { var v = map[t]; if (v !== undefined) { if (all.length &gt; 1) { v = '0' + v; v = v.substr(v.length - 2); } return v; } else if (t === 'y') { return (date.getFullYear() + '').substr(4 - all.length); } return all; }); return format; } return dateFormat(value, arg); })#1.2 提供的数据 包含一个时间戳 为毫秒数 [{ id: 1, name: '三国演义', date: 2525609975000 },{ id: 2, name: '水浒传', date: 2525609975000 },{ id: 3, name: '红楼梦', date: 2525609975000 },{ id: 4, name: '西游记', date: 2525609975000 }];&lt;/script&gt; 2 自定义指令 让表单自动获取焦点 通过Vue.directive 自定义指定 123456789101112&lt;!-- 2.2 通过v-自定义属性名 调用自定义指令 --&gt;&lt;input type=\"text\" id=\"id\" v-model='id' :disabled=\"flag\" v-focus&gt;&lt;script&gt; # 2.1 通过Vue.directive 自定义指定 Vue.directive('focus', { inserted: function (el) { el.focus(); } });&lt;/script&gt; 3 计算属性 通过计算属性计算图书的总数 图书的总数就是计算数组的长度 1234567891011121314151617181920212223242526 &lt;div class=\"total\"&gt; &lt;span&gt;图书总数：&lt;/span&gt; &lt;!-- 3.2 在页面上 展示出来 --&gt; &lt;span&gt;{{total}}&lt;/span&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; /* 计算属性与方法的区别:计算属性是基于依赖进行缓存的，而方法不缓存 */ var vm = new Vue({ data: { flag: false, submitFlag: false, id: '', name: '', books: [] }, computed: { total: function(){ // 3.1 计算图书的总数 return this.books.length; } }, }); &lt;/script&gt; 组件 组件 (Component) 是 Vue.js 最强大的功能之一 组件可以扩展 HTML 元素，封装可重用的代 组件注册全局注册 Vue.component('组件名称', { }) 第1个参数是标签名称，第2个参数是一个选项对象 全局组件注册后，任何vue实例都可以用 组件基础用12345678910111213141516&lt;div id=\"example\"&gt; &lt;!-- 2、 组件使用 组件名称 是以HTML标签的形式使用 --&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; // 注册组件 // 1、 my-component 就是组件中自定义的标签名 Vue.component('my-component', { template: '&lt;div&gt;A custom component!&lt;/div&gt;' }) // 创建根实例 new Vue({ el: '#example' })&lt;/script&gt; 组件注意事项 组件参数的data值必须是函数同时这个函数要求返回一个对象 组件模板必须是单个根元素 组件模板的内容可以是模板字符串 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 &lt;div id=\"app\"&gt; &lt;!-- 4、 组件可以重复使用多次 因为data中返回的是一个对象所以每个组件中的数据是私有的 即每个实例可以维护一份被返回对象的独立的拷贝 --&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;!-- 8、必须使用短横线的方式使用组件 --&gt; &lt;hello-world&gt;&lt;/hello-world&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; //5 如果使用驼峰式命名组件，那么在使用组件的时候，只能在字符串模板中用驼峰的方式使用组件， // 7、但是在普通的标签模板中，必须使用短横线的方式使用组件 Vue.component('HelloWorld', { data: function(){ return { msg: 'HelloWorld' } }, template: '&lt;div&gt;{{msg}}&lt;/div&gt;' }); Vue.component('button-counter', { // 1、组件参数的data值必须是函数 // 同时这个函数要求返回一个对象 data: function(){ return { count: 0 } }, // 2、组件模板必须是单个根元素 // 3、组件模板的内容可以是模板字符串 template: ` &lt;div&gt; &lt;button @click=\"handle\"&gt;点击了{{count}}次&lt;/button&gt; &lt;button&gt;测试123&lt;/button&gt; # 6 在字符串模板中可以使用驼峰的方式使用组件 &lt;HelloWorld&gt;&lt;/HelloWorld&gt; &lt;/div&gt; `, methods: { handle: function(){ this.count += 2; } } }) var vm = new Vue({ el: '#app', data: { } }); &lt;/script&gt; 局部注册 只能在当前注册它的vue实例中使用 1234567891011121314151617181920212223&lt;div id=\"app\"&gt; &lt;hello-jerry&gt;&lt;/hello-jerry&gt;&lt;/div&gt;&lt;script&gt; // 定义组件的模板 var HelloJerry = { data: function(){ return { msg: 'HelloJerry' } }, template: '&lt;div&gt;{{msg}}&lt;/div&gt;' }; var vm = new Vue({ el: '#app', data: { }, components: { 'hello-jerry': HelloJerry } }); &lt;/script&gt; Vue组件之间传值父组件向子组件传值 父组件发送的形式是以属性的形式绑定值到子组件身上。 然后子组件用属性props接收 在props中使用驼峰形式，模板中需要使用短横线的形式字符串形式的模板中没有这个限制 123456789101112131415161718192021222324252627282930 &lt;div id=\"app\"&gt; &lt;div&gt;{{pmsg}}&lt;/div&gt; &lt;!--1、menu-item 在 APP中嵌套着 故 menu-item 为 子组件 --&gt; &lt;!-- 给子组件传入一个静态的值 --&gt; &lt;menu-item title='来自父组件的值'&gt;&lt;/menu-item&gt; &lt;!-- 2、 需要动态的数据的时候 需要属性绑定的形式设置 此时 ptitle 来自父组件data 中的数据 . 传的值可以是数字、对象、数组等等--&gt; &lt;menu-item :title='ptitle' content='hello'&gt;&lt;/menu-item&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.component('menu-item', { // 3、 子组件用属性props接收父组件传递过来的数据 props: ['title', 'content'], data: function() { return { msg: '子组件本身的数据' } }, template: '&lt;div&gt;{{msg + \"----\" + title + \"-----\" + content}}&lt;/div&gt;' }); var vm = new Vue({ el: '#app', data: { pmsg: '父组件中内容', ptitle: '动态绑定属性' } }); &lt;/script&gt; 子组件向父组件传值 子组件用$emit()触发事件 $emit() 第一个参数为 自定义的事件,第二个参数为需要传递的数据 父组件用v-on 监听子组件的事件 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id=\"app\"&gt; &lt;div :style='{fontSize: fontSize + \"px\"}'&gt;{{pmsg}}&lt;/div&gt; &lt;!-- 2 父组件用v-on 监听子组件的事件 这里 enlarge-text 是从 $emit 中的第一个参数对应 handle 为对应的事件处理函数 --&gt; &lt;menu-item :parr='parr' @enlarge-text='handle($event)'&gt;&lt;/menu-item&gt; &lt;!-- 注意handle($event)显式指定event，要么是handle不加括号 --&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; /* 子组件向父组件传值-携带参数 */ Vue.component('menu-item', { props: ['parr'], template: ` &lt;div&gt; &lt;ul&gt; &lt;li :key='index' v-for='(item,index) in parr'&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; ### 1、子组件用$emit()触发事件 ### 第一个参数为 自定义的事件名称 第二个参数为需要传递的数据 &lt;button @click='$emit(\"enlarge-text\", 5)'&gt;扩大父组件中字体大小&lt;/button&gt; &lt;button @click='$emit(\"enlarge-text\", 10)'&gt;扩大父组件中字体大小&lt;/button&gt; &lt;/div&gt; ` }); var vm = new Vue({ el: '#app', data: { pmsg: '父组件中内容', parr: ['apple','orange','banana'], fontSize: 10 }, methods: { handle: function(val){ // 扩大字体大小 this.fontSize += val; } } }); &lt;/script&gt; 兄弟之间的传递 兄弟之间传递数据需要借助于事件中心，通过事件中心传递数据 提供事件中心 var hub = new Vue() 传递数据方，通过一个事件触发hub.$emit(方法名，传递的数据) 接收数据方，通过mounted(){} 钩子中 触发hub.$on()方法名 销毁事件 通过hub.$off()方法名销毁之后无法进行传递数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;div id=\"app\"&gt; &lt;div&gt;父组件&lt;/div&gt; &lt;div&gt; &lt;button @click='handle'&gt;销毁事件&lt;/button&gt; &lt;/div&gt; &lt;test-tom&gt;&lt;/test-tom&gt; &lt;test-jerry&gt;&lt;/test-jerry&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; /* 兄弟组件之间数据传递 */ //1、 提供事件中心 var hub = new Vue(); Vue.component('test-tom', { data: function(){ return { num: 0 } }, template: ` &lt;div&gt; &lt;div&gt;TOM:{{num}}&lt;/div&gt; &lt;div&gt; &lt;button @click='handle'&gt;点击&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; `, methods: { handle: function(){ //2、传递数据方，通过一个事件触发hub.$emit(方法名，传递的数据) 触发兄弟组件的事件 hub.$emit('jerry-event', 2); } }, mounted: function() { // 3、接收数据方，通过mounted(){} 钩子中 触发hub.$on(方法名 hub.$on('tom-event', (val) =&gt; { this.num += val; }); } }); Vue.component('test-jerry', { data: function(){ return { num: 0 } }, template: ` &lt;div&gt; &lt;div&gt;JERRY:{{num}}&lt;/div&gt; &lt;div&gt; &lt;button @click='handle'&gt;点击&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; `, methods: { handle: function(){ //2、传递数据方，通过一个事件触发hub.$emit(方法名，传递的数据) 触发兄弟组件的事件 hub.$emit('tom-event', 1); } }, mounted: function() { // 3、接收数据方，通过mounted(){} 钩子中 触发hub.$on()方法名 hub.$on('jerry-event', (val) =&gt; { this.num += val; }); } }); var vm = new Vue({ el: '#app', data: { }, methods: { handle: function(){ //4、销毁事件 通过hub.$off()方法名销毁之后无法进行传递数据 hub.$off('tom-event'); hub.$off('jerry-event'); } } }); &lt;/script&gt; 组件插槽组件的最大特性就是复用性，而用好插槽能大大提高组件的可复用能力。 匿名插槽123456789101112131415161718192021222324252627282930 &lt;div id=\"app\"&gt; &lt;!-- 这里的所有组件标签中嵌套的内容会替换掉slot 如果不传值则使用 slot 中的默认值 --&gt; &lt;alert-box&gt;有bug发生&lt;/alert-box&gt; &lt;alert-box&gt;有一个警告&lt;/alert-box&gt; &lt;alert-box&gt;&lt;/alert-box&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; /* 组件插槽：父组件向子组件传递内容 */ Vue.component('alert-box', { template: ` &lt;div&gt; &lt;strong&gt;ERROR:&lt;/strong&gt; # 当组件渲染的时候，这个 &lt;slot&gt; 元素将会被替换为“组件标签中嵌套的内容”。 # 插槽内可以包含任何模板代码，包括 HTML &lt;slot&gt;默认内容&lt;/slot&gt; &lt;/div&gt; ` }); var vm = new Vue({ el: '#app', data: { } }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 具名插槽 具有名字的插槽 使用 中的 “name” 属性绑定元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 &lt;div id=\"app\"&gt; &lt;base-layout&gt; &lt;!-- 2、 通过slot属性来指定, 这个slot的值必须和下面slot组件得name值对应上 如果没有匹配到 则放到匿名的插槽中 --&gt; &lt;p slot='header'&gt;标题信息&lt;/p&gt; &lt;p&gt;主要内容1&lt;/p&gt; &lt;p&gt;主要内容2&lt;/p&gt; &lt;p slot='footer'&gt;底部信息信息&lt;/p&gt; &lt;/base-layout&gt; &lt;base-layout&gt; &lt;!-- 注意点：template临时的包裹标签最终不会渲染到页面上 --&gt; &lt;template slot='header'&gt; &lt;p&gt;标题信息1&lt;/p&gt; &lt;p&gt;标题信息2&lt;/p&gt; &lt;/template&gt; &lt;p&gt;主要内容1&lt;/p&gt; &lt;p&gt;主要内容2&lt;/p&gt; &lt;template slot='footer'&gt; &lt;p&gt;底部信息信息1&lt;/p&gt; &lt;p&gt;底部信息信息2&lt;/p&gt; &lt;/template&gt; &lt;/base-layout&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; /* 具名插槽 */ Vue.component('base-layout', { template: ` &lt;div&gt; &lt;header&gt; ### 1、 使用 &lt;slot&gt; 中的 \"name\" 属性绑定元素 指定当前插槽的名字 &lt;slot name='header'&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; ### 注意点： ### 具名插槽的渲染顺序，完全取决于模板，而不是取决于父组件中元素的顺序 &lt;slot name='footer'&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt; ` }); var vm = new Vue({ el: '#app', data: { } }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 关于上面的template，最终渲染少一个根标签。 作用域插槽 父组件对子组件加工处理 既可以复用子组件的slot，又可以使slot内容不一致 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 &lt;div id=\"app\"&gt; &lt;!-- 1、当我们希望li 的样式由外部使用组件的地方定义，因为可能有多种地方要使用该组件， 但样式希望不一样 这个时候我们需要使用作用域插槽 --&gt; &lt;fruit-list :list='list'&gt; &lt;!-- 2、 父组件中使用了&lt;template&gt;元素,而且包含scope=\"slotProps\", slotProps在这里只是临时变量 ---&gt; &lt;template slot-scope='slotProps'&gt; &lt;strong v-if='slotProps.info.id==3' class=\"current\"&gt; {{slotProps.info.name}} &lt;/strong&gt; &lt;span v-else&gt;{{slotProps.info.name}}&lt;/span&gt; &lt;/template&gt; &lt;/fruit-list&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; /* 作用域插槽 */ Vue.component('fruit-list', { props: ['list'], template: ` &lt;div&gt; &lt;li :key='item.id' v-for='item in list'&gt; ### 3、 在子组件模板中,&lt;slot&gt;元素上有一个类似props传递数据给组件的写法msg=\"xxx\", ### 插槽可以提供一个默认内容，如果如果父组件没有为这个插槽提供了内容，会显示默认的内容。 如果父组件为这个插槽提供了内容，则默认的内容会被替换掉 &lt;slot :info='item'&gt;{{item.name}}&lt;/slot&gt; &lt;/li&gt; &lt;/div&gt; ` }); var vm = new Vue({ el: '#app', data: { list: [{ id: 1, name: 'apple' },{ id: 2, name: 'orange' },{ id: 3, name: 'banana' }] } }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 购物车案例1.实现组件化布局 把静态页面转换成组件化模式 把组件渲染到页面上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106 &lt;div id=\"app\"&gt; &lt;div class=\"container\"&gt; &lt;!-- 2、把组件渲染到页面上 --&gt; &lt;my-cart&gt;&lt;/my-cart&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; # 1、 把静态页面转换成组件化模式 # 1.1 标题组件 var CartTitle = { template: ` &lt;div class=\"title\"&gt;我的商品&lt;/div&gt; ` } # 1.2 商品列表组件 var CartList = { # 注意点 ： 组件模板必须是单个根元素 template: ` &lt;div&gt; &lt;div class=\"item\"&gt; &lt;img src=\"img/a.jpg\"/&gt; &lt;div class=\"name\"&gt;&lt;/div&gt; &lt;div class=\"change\"&gt; &lt;a href=\"\"&gt;－&lt;/a&gt; &lt;input type=\"text\" class=\"num\" /&gt; &lt;a href=\"\"&gt;＋&lt;/a&gt; &lt;/div&gt; &lt;div class=\"del\"&gt;×&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img src=\"img/b.jpg\"/&gt; &lt;div class=\"name\"&gt;&lt;/div&gt; &lt;div class=\"change\"&gt; &lt;a href=\"\"&gt;－&lt;/a&gt; &lt;input type=\"text\" class=\"num\" /&gt; &lt;a href=\"\"&gt;＋&lt;/a&gt; &lt;/div&gt; &lt;div class=\"del\"&gt;×&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img src=\"img/c.jpg\"/&gt; &lt;div class=\"name\"&gt;&lt;/div&gt; &lt;div class=\"change\"&gt; &lt;a href=\"\"&gt;－&lt;/a&gt; &lt;input type=\"text\" class=\"num\" /&gt; &lt;a href=\"\"&gt;＋&lt;/a&gt; &lt;/div&gt; &lt;div class=\"del\"&gt;×&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img src=\"img/d.jpg\"/&gt; &lt;div class=\"name\"&gt;&lt;/div&gt; &lt;div class=\"change\"&gt; &lt;a href=\"\"&gt;－&lt;/a&gt; &lt;input type=\"text\" class=\"num\" /&gt; &lt;a href=\"\"&gt;＋&lt;/a&gt; &lt;/div&gt; &lt;div class=\"del\"&gt;×&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img src=\"img/e.jpg\"/&gt; &lt;div class=\"name\"&gt;&lt;/div&gt; &lt;div class=\"change\"&gt; &lt;a href=\"\"&gt;－&lt;/a&gt; &lt;input type=\"text\" class=\"num\" /&gt; &lt;a href=\"\"&gt;＋&lt;/a&gt; &lt;/div&gt; &lt;div class=\"del\"&gt;×&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ` } # 1.3 商品结算组件 var CartTotal = { template: ` &lt;div class=\"total\"&gt; &lt;span&gt;总价：123&lt;/span&gt; &lt;button&gt;结算&lt;/button&gt; &lt;/div&gt; ` } ## 1.4 定义一个全局组件 my-cart Vue.component('my-cart',{ ## 1.6 引入子组件 template: ` &lt;div class='cart'&gt; &lt;cart-title&gt;&lt;/cart-title&gt; &lt;cart-list&gt;&lt;/cart-list&gt; &lt;cart-total&gt;&lt;/cart-total&gt; &lt;/div&gt; `, # 1.5 注册子组件 components: { 'cart-title': CartTitle, 'cart-list': CartList, 'cart-total': CartTotal } }); var vm = new Vue({ el: '#app', data: { } });&lt;/script&gt; 2、实现 标题和结算功能组件 标题组件实现动态渲染 从父组件把标题数据传递过来 即 父向子组件传值 把传递过来的数据渲染到页面上 结算功能组件 从父组件把商品列表list 数据传递过来 即 父向子组件传值 把传递过来的数据计算最终价格渲染到页面上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293 &lt;div id=\"app\"&gt; &lt;div class=\"container\"&gt; &lt;my-cart&gt;&lt;/my-cart&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; # 2.2 标题组件 子组件通过props形式接收父组件传递过来的uname数据 var CartTitle = { props: ['uname'], template: ` &lt;div class=\"title\"&gt;{{uname}}的商品&lt;/div&gt; ` } # 2.3 商品结算组件 子组件通过props形式接收父组件传递过来的list数据 var CartTotal = { props: ['list'], template: ` &lt;div class=\"total\"&gt; &lt;span&gt;总价：{{total}}&lt;/span&gt; &lt;button&gt;结算&lt;/button&gt; &lt;/div&gt; `, computed: { # 2.4 计算商品的总价 并渲染到页面上 total: function() { var t = 0; this.list.forEach(item =&gt; { t += item.price * item.num; }); return t; } } } Vue.component('my-cart',{ data: function() { return { uname: '张三', list: [{ id: 1, name: 'TCL彩电', price: 1000, num: 1, img: 'img/a.jpg' },{ id: 2, name: '机顶盒', price: 1000, num: 1, img: 'img/b.jpg' },{ id: 3, name: '海尔冰箱', price: 1000, num: 1, img: 'img/c.jpg' },{ id: 4, name: '小米手机', price: 1000, num: 1, img: 'img/d.jpg' },{ id: 5, name: 'PPTV电视', price: 1000, num: 2, img: 'img/e.jpg' }] } }, # 2.1 父组件向子组件以属性传递的形式 传递数据 # 向 标题组件传递 uname 属性 向 商品结算组件传递 list 属性 template: ` &lt;div class='cart'&gt; &lt;cart-title :uname='uname'&gt;&lt;/cart-title&gt; &lt;cart-list&gt;&lt;/cart-list&gt; &lt;cart-total :list='list'&gt;&lt;/cart-total&gt; &lt;/div&gt; `, components: { 'cart-title': CartTitle, 'cart-list': CartList, 'cart-total': CartTotal } }); var vm = new Vue({ el: '#app', data: { } });&lt;/script&gt; 3.实现列表组件删除功能 从父组件把商品列表list 数据传递过来 即 父向子组件传值 把传递过来的数据渲染到页面上 点击删除按钮的时候删除对应的数据 给按钮添加点击事件把需要删除的id传递过来 子组件中不推荐操作父组件的数据有可能多个子组件使用父组件的数据 我们需要把数据传递给父组件让父组件操作数据 父组件删除对应的数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132 &lt;div id=\"app\"&gt; &lt;div class=\"container\"&gt; &lt;my-cart&gt;&lt;/my-cart&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var CartTitle = { props: ['uname'], template: ` &lt;div class=\"title\"&gt;{{uname}}的商品&lt;/div&gt; ` } # 3.2 把列表数据动态渲染到页面上 var CartList = { props: ['list'], template: ` &lt;div&gt; &lt;div :key='item.id' v-for='item in list' class=\"item\"&gt; &lt;img :src=\"item.img\"/&gt; &lt;div class=\"name\"&gt;{{item.name}}&lt;/div&gt; &lt;div class=\"change\"&gt; &lt;a href=\"\"&gt;－&lt;/a&gt; &lt;input type=\"text\" class=\"num\" /&gt; &lt;a href=\"\"&gt;＋&lt;/a&gt; &lt;/div&gt; # 3.3 给按钮添加点击事件把需要删除的id传递过来 &lt;div class=\"del\" @click='del(item.id)'&gt;×&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; `, methods: { del: function(id){ # 3.4 子组件中不推荐操作父组件的数据有可能多个子组件使用父组件的数据 # 我们需要把数据传递给父组件 让父组件操作数据 this.$emit('cart-del', id); } } } var CartTotal = { props: ['list'], template: ` &lt;div class=\"total\"&gt; &lt;span&gt;总价：{{total}}&lt;/span&gt; &lt;button&gt;结算&lt;/button&gt; &lt;/div&gt; `, computed: { total: function() { // 计算商品的总价 var t = 0; this.list.forEach(item =&gt; { t += item.price * item.num; }); return t; } } } Vue.component('my-cart',{ data: function() { return { uname: '张三', list: [{ id: 1, name: 'TCL彩电', price: 1000, num: 1, img: 'img/a.jpg' },{ id: 2, name: '机顶盒', price: 1000, num: 1, img: 'img/b.jpg' },{ id: 3, name: '海尔冰箱', price: 1000, num: 1, img: 'img/c.jpg' },{ id: 4, name: '小米手机', price: 1000, num: 1, img: 'img/d.jpg' },{ id: 5, name: 'PPTV电视', price: 1000, num: 2, img: 'img/e.jpg' }] } }, # 3.1 从父组件把商品列表list 数据传递过来 即 父向子组件传值 template: ` &lt;div class='cart'&gt; &lt;cart-title :uname='uname'&gt;&lt;/cart-title&gt; # 3.5 父组件通过事件绑定 接收子组件传递过来的数据 &lt;cart-list :list='list' @cart-del='delCart($event)'&gt;&lt;/cart-list&gt; &lt;cart-total :list='list'&gt;&lt;/cart-total&gt; &lt;/div&gt; `, components: { 'cart-title': CartTitle, 'cart-list': CartList, 'cart-total': CartTotal }, methods: { # 3.6 根据id删除list中对应的数据 delCart: function(id) { // 1、找到id所对应数据的索引 var index = this.list.findIndex(item=&gt;{ return item.id == id; }); // 2、根据索引删除对应数据 this.list.splice(index, 1); } } }); var vm = new Vue({ el: '#app', data: { } }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.实现组件更新数据功能 上 将输入框中的默认数据动态渲染出来 输入框失去焦点的时候 更改商品的数量 子组件中不推荐操作数据 把这些数据传递给父组件 让父组件处理这些数据 父组件中接收子组件传递过来的数据并处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120 &lt;div id=\"app\"&gt; &lt;div class=\"container\"&gt; &lt;my-cart&gt;&lt;/my-cart&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var CartTitle = { props: ['uname'], template: ` &lt;div class=\"title\"&gt;{{uname}}的商品&lt;/div&gt; ` } var CartList = { props: ['list'], template: ` &lt;div&gt; &lt;div :key='item.id' v-for='item in list' class=\"item\"&gt; &lt;img :src=\"item.img\"/&gt; &lt;div class=\"name\"&gt;{{item.name}}&lt;/div&gt; &lt;div class=\"change\"&gt; &lt;a href=\"\"&gt;－&lt;/a&gt; # 1. 将输入框中的默认数据动态渲染出来 # 2. 输入框失去焦点的时候 更改商品的数量 需要将当前商品的id 传递过来 &lt;input type=\"text\" class=\"num\" :value='item.num' @blur='changeNum(item.id, $event)'/&gt; &lt;a href=\"\"&gt;＋&lt;/a&gt; &lt;/div&gt; &lt;div class=\"del\" @click='del(item.id)'&gt;×&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; `, methods: { changeNum: function(id, event){ # 3 子组件中不推荐操作数据 因为别的组件可能也引用了这些数据 # 把这些数据传递给父组件 让父组件处理这些数据 this.$emit('change-num', { id: id, num: event.target.value }); }, del: function(id){ // 把id传递给父组件 this.$emit('cart-del', id); } } } var CartTotal = { props: ['list'], template: ` &lt;div class=\"total\"&gt; &lt;span&gt;总价：{{total}}&lt;/span&gt; &lt;button&gt;结算&lt;/button&gt; &lt;/div&gt; `, computed: { total: function() { // 计算商品的总价 var t = 0; this.list.forEach(item =&gt; { t += item.price * item.num; }); return t; } } } Vue.component('my-cart',{ data: function() { return { uname: '张三', list: [{ id: 1, name: 'TCL彩电', price: 1000, num: 1, img: 'img/a.jpg' }] }, template: ` &lt;div class='cart'&gt; &lt;cart-title :uname='uname'&gt;&lt;/cart-title&gt; # 4 父组件中接收子组件传递过来的数据 &lt;cart-list :list='list' @change-num='changeNum($event)' @cart-del='delCart($event)'&gt;&lt;/cart-list&gt; &lt;cart-total :list='list'&gt;&lt;/cart-total&gt; &lt;/div&gt; `, components: { 'cart-title': CartTitle, 'cart-list': CartList, 'cart-total': CartTotal }, methods: { changeNum: function(val) { //4.1 根据子组件传递过来的数据，跟新list中对应的数据 this.list.some(item=&gt;{ if(item.id == val.id) { item.num = val.num; // 终止遍历 return true; } }); }, delCart: function(id) { // 根据id删除list中对应的数据 // 1、找到id所对应数据的索引 var index = this.list.findIndex(item=&gt;{ return item.id == id; }); // 2、根据索引删除对应数据 this.list.splice(index, 1); } } }); var vm = new Vue({ el: '#app', data: { } });&lt;/script&gt; 5.实现组件更新数据功能 下 子组件通过一个标识符来标记对用的用户点击 + - 或者输入框输入的内容 父组件拿到标识符更新对应的组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; .container { } .container .cart { width: 300px; margin: auto; } .container .title { background-color: lightblue; height: 40px; line-height: 40px; text-align: center; /*color: #fff;*/ } .container .total { background-color: #FFCE46; height: 50px; line-height: 50px; text-align: right; } .container .total button { margin: 0 10px; background-color: #DC4C40; height: 35px; width: 80px; border: 0; } .container .total span { color: red; font-weight: bold; } .container .item { height: 55px; line-height: 55px; position: relative; border-top: 1px solid #ADD8E6; } .container .item img { width: 45px; height: 45px; margin: 5px; } .container .item .name { position: absolute; width: 90px; top: 0;left: 55px; font-size: 16px; } .container .item .change { width: 100px; position: absolute; top: 0; right: 50px; } .container .item .change a { font-size: 20px; width: 30px; text-decoration:none; background-color: lightgray; vertical-align: middle; } .container .item .change .num { width: 40px; height: 25px; } .container .item .del { position: absolute; top: 0; right: 0px; width: 40px; text-align: center; font-size: 40px; cursor: pointer; color: red; } .container .item .del:hover { background-color: orange; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div class=\"container\"&gt; &lt;my-cart&gt;&lt;/my-cart&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var CartTitle = { props: ['uname'], template: ` &lt;div class=\"title\"&gt;{{uname}}的商品&lt;/div&gt; ` } var CartList = { props: ['list'], template: ` &lt;div&gt; &lt;div :key='item.id' v-for='item in list' class=\"item\"&gt; &lt;img :src=\"item.img\"/&gt; &lt;div class=\"name\"&gt;{{item.name}}&lt;/div&gt; &lt;div class=\"change\"&gt; # 1. + - 按钮绑定事件 &lt;a href=\"\" @click.prevent='sub(item.id)'&gt;－&lt;/a&gt; &lt;input type=\"text\" class=\"num\" :value='item.num' @blur='changeNum(item.id, $event)'/&gt; &lt;a href=\"\" @click.prevent='add(item.id)'&gt;＋&lt;/a&gt; &lt;/div&gt; &lt;div class=\"del\" @click='del(item.id)'&gt;×&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; `, methods: { changeNum: function(id, event){ this.$emit('change-num', { id: id, type: 'change', num: event.target.value }); }, sub: function(id){ # 2 数量的增加和减少通过父组件来计算 每次都是加1 和 减1 不需要传递数量 父组件需要一个类型来判断 是 加一 还是减1 以及是输入框输入的数据 我们通过type 标识符来标记 不同的操作 this.$emit('change-num', { id: id, type: 'sub' }); }, add: function(id){ # 2 数量的增加和减少通过父组件来计算 每次都是加1 和 减1 不需要传递数量 父组件需要一个类型来判断 是 加一 还是减1 以及是输入框输入的数据 我们通过type 标识符来标记 不同的操作 this.$emit('change-num', { id: id, type: 'add' }); }, del: function(id){ // 把id传递给父组件 this.$emit('cart-del', id); } } } var CartTotal = { props: ['list'], template: ` &lt;div class=\"total\"&gt; &lt;span&gt;总价：{{total}}&lt;/span&gt; &lt;button&gt;结算&lt;/button&gt; &lt;/div&gt; `, computed: { total: function() { // 计算商品的总价 var t = 0; this.list.forEach(item =&gt; { t += item.price * item.num; }); return t; } } } Vue.component('my-cart',{ data: function() { return { uname: '张三', list: [{ id: 1, name: 'TCL彩电', price: 1000, num: 1, img: 'img/a.jpg' },{ id: 2, name: '机顶盒', price: 1000, num: 1, img: 'img/b.jpg' },{ id: 3, name: '海尔冰箱', price: 1000, num: 1, img: 'img/c.jpg' },{ id: 4, name: '小米手机', price: 1000, num: 1, img: 'img/d.jpg' },{ id: 5, name: 'PPTV电视', price: 1000, num: 2, img: 'img/e.jpg' }] } }, template: ` &lt;div class='cart'&gt; &lt;cart-title :uname='uname'&gt;&lt;/cart-title&gt; # 3 父组件通过事件监听 接收子组件的数据 &lt;cart-list :list='list' @change-num='changeNum($event)' @cart-del='delCart($event)'&gt;&lt;/cart-list&gt; &lt;cart-total :list='list'&gt;&lt;/cart-total&gt; &lt;/div&gt; `, components: { 'cart-title': CartTitle, 'cart-list': CartList, 'cart-total': CartTotal }, methods: { changeNum: function(val) { #4 分为三种情况：输入框变更、加号变更、减号变更 if(val.type=='change') { // 根据子组件传递过来的数据，跟新list中对应的数据 this.list.some(item=&gt;{ if(item.id == val.id) { item.num = val.num; // 终止遍历 return true; } }); }else if(val.type=='sub'){ // 减一操作 this.list.some(item=&gt;{ if(item.id == val.id) { item.num -= 1; // 终止遍历 return true; } }); }else if(val.type=='add'){ // 加一操作 this.list.some(item=&gt;{ if(item.id == val.id) { item.num += 1; // 终止遍历 return true; } }); } } } }); var vm = new Vue({ el: '#app', data: { } }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 接口调用方式 原生ajax 基于jQuery的ajax fetch axios 异步 JavaScript的执行环境是「单线程」 所谓单线程，是指JS引擎中负责解释和执行JavaScript代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完后才能执行下一个，它会「阻塞」其他任务。这个任务可称为主线程 异步模式可以一起执行多个任务 JS中常见的异步调用 定时任何 ajax 事件函数 promise 主要解决异步深层嵌套的问题 promise 提供了简洁的API 使得异步操作更加容易 1234567891011121314151617181920212223242526&lt;script type=\"text/javascript\"&gt; /* 1. Promise基本使用 我们使用new来构建一个Promise Promise的构造函数接收一个参数，是函数，并且传入两个参数： resolve，reject， 分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数 */ var p = new Promise(function(resolve, reject){ //2. 这里用于实现异步任务 setTimeout setTimeout(function(){ var flag = false; if(flag) { //3. 正常情况 resolve('hello'); }else{ //4. 异常情况 reject('出错了'); } }, 100); }); // 5 Promise实例生成以后，可以用then方法指定resolved状态和reject状态的回调函数 // 在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了 p.then(function(data){ console.log(data) },function(info){ console.log(info) }); &lt;/script&gt; 基于Promise发送Ajax请求123456789101112131415161718192021222324252627282930313233343536373839&lt;script type=\"text/javascript\"&gt; /* 基于Promise发送Ajax请求 */ function queryData(url) { # 1.1 创建一个Promise实例 var p = new Promise(function(resolve, reject){ var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function(){ if(xhr.readyState != 4) return; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) { # 1.2 处理正常的情况 resolve(xhr.responseText); }else{ # 1.3 处理异常情况 reject('服务器错误'); } }; xhr.open('get', url); xhr.send(null); }); return p; } # 注意： 这里需要开启一个服务 # 在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了 queryData('http://localhost:3000/data') .then(function(data){ console.log(data) # 1.4 想要继续链式编程下去 需要 return return queryData('http://localhost:3000/data1'); }) .then(function(data){ console.log(data); return queryData('http://localhost:3000/data2'); }) .then(function(data){ console.log(data) });&lt;/script&gt; Promise 基本API实例方法.then() 得到异步任务正确的结果 .catch() 获取异常信息 .finally() 成功与否都会执行（不是正式标准） 123456789101112131415161718192021222324252627282930313233343536373839&lt;script type=\"text/javascript\"&gt; /* Promise常用API-实例方法 */ // console.dir(Promise); function foo() { return new Promise(function(resolve, reject){ setTimeout(function(){ // resolve(123); reject('error'); }, 100); }) } // foo() // .then(function(data){ // console.log(data) // }) // .catch(function(data){ // console.log(data) // }) // .finally(function(){ // console.log('finished') // }); // -------------------------- // 两种写法是等效的 foo() .then(function(data){ # 得到异步任务正确的结果 console.log(data) },function(data){ # 获取异常信息 console.log(data) }) # 成功与否都会执行（不是正式标准） .finally(function(){ console.log('finished') }); &lt;/script&gt; 静态方法.all() Promise.all方法接受一个数组作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用Promise.resolve转换为一个promise)。它的状态由这三个promise实例决定 .race() Promise.race方法同样接受一个数组作参数。当p1, p2, p3中有一个实例的状态发生改变（变为fulfilled或rejected），p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数 1234567891011121314151617181920212223242526272829303132333435&lt;script type=\"text/javascript\"&gt; /* Promise常用API-对象方法 */ // console.dir(Promise) function queryData(url) { return new Promise(function(resolve, reject){ var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function(){ if(xhr.readyState != 4) return; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) { // 处理正常的情况 resolve(xhr.responseText); }else{ // 处理异常情况 reject('服务器错误'); } }; xhr.open('get', url); xhr.send(null); }); } var p1 = queryData('http://localhost:3000/a1'); var p2 = queryData('http://localhost:3000/a2'); var p3 = queryData('http://localhost:3000/a3'); Promise.all([p1,p2,p3]).then(function(result){ // all 中的参数 [p1,p2,p3] 和 返回的结果一 一对应[\"HELLO TOM\", \"HELLO JERRY\", \"HELLO SPIKE\"] console.log(result) //[\"HELLO TOM\", \"HELLO JERRY\", \"HELLO SPIKE\"] }) Promise.race([p1,p2,p3]).then(function(result){ // 由于p1执行较快，Promise的then()将获得结果'P1'。p2,p3仍在继续执行，但执行结果将被丢弃。 console.log(result) // \"HELLO TOM\" }) &lt;/script&gt; fetch Fetch API是新的ajax解决方案 Fetch会返回Promise fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。 fetch(url, options).then(） 1234567891011121314&lt;script type=\"text/javascript\"&gt; /* Fetch API 基本用法 fetch(url).then() 第一个参数请求的路径 Fetch会返回Promise 所以我们可以使用then 拿到请求成功的结果 */ fetch('http://localhost:3000/fdata').then(function(data){ // text()方法属于fetchAPI的一部分，它返回一个Promise实例对象，用于获取后台返回的数据 return data.text(); }).then(function(data){ // 在这个then里面我们能拿到最终的数据 console.log(data); })&lt;/script&gt; fetch API 中的 HTTP 请求 fetch(url, options).then() HTTP协议，它给我们提供了很多的方法，如POST，GET，DELETE，UPDATE，PATCH和PUT 默认的是 GET 请求 需要在 options 对象中 指定对应的 method method:请求使用的方法 post 和 普通 请求的时候 需要在options 中 设置 请求头 headers 和 body 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;script type=\"text/javascript\"&gt; /* Fetch API 调用接口传递参数 */ #1.1 GET参数传递 - 传统URL 通过url ？ 的形式传参 fetch('http://localhost:3000/books?id=123', { # get 请求可以省略不写 默认的是GET method: 'get' }) .then(function(data) { # 它返回一个Promise实例对象，用于获取后台返回的数据 return data.text(); }).then(function(data) { # 在这个then里面我们能拿到最终的数据 console.log(data) }); #1.2 GET参数传递 restful形式的URL 通过/ 的形式传递参数 即 id = 456 和id后台的配置有关 fetch('http://localhost:3000/books/456', { # get 请求可以省略不写 默认的是GET method: 'get' }) .then(function(data) { return data.text(); }).then(function(data) { console.log(data) }); #2.1 DELETE请求方式参数传递 删除id 是 id=789 fetch('http://localhost:3000/books/789', { method: 'delete' }) .then(function(data) { return data.text(); }).then(function(data) { console.log(data) }); #3 POST请求传参 fetch('http://localhost:3000/books', { method: 'post', # 3.1 传递数据 body: 'uname=lisi&amp;pwd=123', # 3.2 设置请求头 headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }) .then(function(data) { return data.text(); }).then(function(data) { console.log(data) }); # POST请求传参 fetch('http://localhost:3000/books', { method: 'post', body: JSON.stringify({ uname: '张三', pwd: '456' }), headers: { 'Content-Type': 'application/json' } }) .then(function(data) { return data.text(); }).then(function(data) { console.log(data) }); # PUT请求传参 修改id 是 123 的 fetch('http://localhost:3000/books/123', { method: 'put', body: JSON.stringify({ uname: '张三', pwd: '789' }), headers: { 'Content-Type': 'application/json' } }) .then(function(data) { return data.text(); }).then(function(data) { console.log(data) }); &lt;/script&gt; fetchAPI 中 响应格式 用fetch来获取数据，如果响应正常返回，我们首先看到的是一个response对象，其中包括返回的一堆原始字节，这些字节需要在收到后，需要我们通过调用方法将其转换为相应格式的数据，比如JSON，BLOB或者TEXT等等 123456789101112/* Fetch响应结果的数据格式*/fetch('http://localhost:3000/json').then(function(data){ // return data.json(); // 将获取到的数据使用 json 转换对象 return data.text(); // // 将获取到的数据 转换成字符串 }).then(function(data){ // console.log(data.uname) // console.log(typeof data) var obj = JSON.parse(data); console.log(obj.uname,obj.age,obj.gender)}) axios 基于promise用于浏览器和node.js的http客户端 支持浏览器和node.js 支持promise 能拦截请求和响应 自动转换JSON数据 能转换请求和响应数据 axios基础用法 get和 delete请求传递参数 通过传统的url 以 ? 的形式传递参数 restful 形式传递参数 通过params形式传递参数 post 和 put 请求传递参数 通过选项传递参数 通过 URLSearchParams 传递参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 1. 发送get 请求 axios.get('http://localhost:3000/adata').then(function(ret){ # 拿到 ret 是一个对象 所有的对象都存在 ret 的data 属性里面 // 注意data属性是固定的用法，用于获取后台的实际数据 // console.log(ret.data) console.log(ret) })# 2. get 请求传递参数 # 2.1 通过传统的url 以 ? 的形式传递参数 axios.get('http://localhost:3000/axios?id=123').then(function(ret){ console.log(ret.data) }) # 2.2 restful 形式传递参数 axios.get('http://localhost:3000/axios/123').then(function(ret){ console.log(ret.data) }) # 2.3 通过params 形式传递参数 axios.get('http://localhost:3000/axios', { params: { id: 789 } }).then(function(ret){ console.log(ret.data) })#3 axios delete 请求传参 传参的形式和 get 请求一样 axios.delete('http://localhost:3000/axios', { params: { id: 111 } }).then(function(ret){ console.log(ret.data) })# 4 axios 的 post 请求 # 4.1 通过选项传递参数 axios.post('http://localhost:3000/axios', { uname: 'lisi', pwd: 123 }).then(function(ret){ console.log(ret.data) })# 4.2 通过 URLSearchParams 传递参数 var params = new URLSearchParams(); params.append('uname', 'zhangsan'); params.append('pwd', '111'); axios.post('http://localhost:3000/axios', params).then(function(ret){ console.log(ret.data) })#5 axios put 请求传参 和 post 请求一样 axios.put('http://localhost:3000/axios/123', { uname: 'lisi', pwd: 123 }).then(function(ret){ console.log(ret.data) }) axios 全局配置12345678# 配置公共的请求头 axios.defaults.baseURL = 'https://api.example.com';# 配置 超时时间axios.defaults.timeout = 2500;# 配置公共的请求头axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;# 配置公共的 post 的 Content-Typeaxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; axios 拦截器 请求拦截器 请求拦截器的作用是在请求发送前进行一些操作 例如在每个请求体里加上token，统一做了处理如果以后要改也非常容易 响应拦截器 响应拦截器的作用是在接收到响应后进行一些操作 例如在服务器返回登录状态失效，需要重新登录的时候，跳转到登录页 1234567891011121314151617181920# 1. 请求拦截器 axios.interceptors.request.use(function(config) { console.log(config.url) # 1.1 任何请求都会经过这一步 在发送请求之前做些什么 config.headers.mytoken = 'nihao'; # 1.2 这里一定要return 否则配置不成功 return config; }, function(err){ #1.3 对请求错误做点什么 console.log(err) })#2. 响应拦截器 axios.interceptors.response.use(function(res) { #2.1 在接收响应做些什么 var data = res.data; return data; }, function(err){ #2.2 对响应错误做点什么 console.log(err) }) async 和 await async作为一个关键字放到函数前面 任何一个async函数都会隐式返回一个promise await关键字只能在使用async定义的函数中使用 await后面可以直接跟一个 Promise实例对象 await函数不能单独使用 async/await 让异步代码看起来、表现起来更像同步代码 1234567891011121314151617181920212223242526272829# 1. async 基础用法 # 1.1 async作为一个关键字放到函数前面 async function queryData() { # 1.2 await关键字只能在使用async定义的函数中使用 await后面可以直接跟一个 Promise实例对象 var ret = await new Promise(function(resolve, reject){ setTimeout(function(){ resolve('nihao') },1000); }) // console.log(ret.data) return ret; } # 1.3 任何一个async函数都会隐式返回一个promise 我们可以使用then 进行链式编程 queryData().then(function(data){ console.log(data) }) #2. async函数处理多个异步函数 axios.defaults.baseURL = 'http://localhost:3000'; async function queryData() { # 2.1 添加await之后 当前的await 返回结果之后才会执行后面的代码 var info = await axios.get('async1'); #2.2 让异步代码看起来、表现起来更像同步代码 var ret = await axios.get('async2?info=' + info.data); return ret.data; } queryData().then(function(data){ console.log(data) }) 图书列表案例1. 基于接口案例-获取图书列表 导入axios 用来发送ajax 把获取到的数据渲染到页面上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 &lt;div id=\"app\"&gt; &lt;div class=\"grid\"&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;时间&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!-- 5. 把books 中的数据渲染到页面上 --&gt; &lt;tr :key='item.id' v-for='item in books'&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.date }}&lt;/td&gt; &lt;td&gt; &lt;a href=\"\"&gt;修改&lt;/a&gt; &lt;span&gt;|&lt;/span&gt; &lt;a href=\"\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\"&gt;&lt;/script&gt;1. 导入axios &lt;script type=\"text/javascript\" src=\"js/axios.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; /* 图书管理-添加图书 */ # 2 配置公共的url地址 简化后面的调用方式 axios.defaults.baseURL = 'http://localhost:3000/'; axios.interceptors.response.use(function(res) { return res.data; }, function(error) { console.log(error) }); var vm = new Vue({ el: '#app', data: { flag: false, submitFlag: false, id: '', name: '', books: [] }, methods: { # 3 定义一个方法 用来发送 ajax # 3.1 使用 async 来 让异步的代码 以同步的形式书写 queryData: async function() { // 调用后台接口获取图书列表数据 // var ret = await axios.get('books'); // this.books = ret.data; # 3.2 发送ajax请求 把拿到的数据放在books 里面 this.books = await axios.get('books'); } }, mounted: function() { # 4 mounted 里面 DOM已经加载完毕 在这里调用函数 this.queryData(); } }); &lt;/script&gt; 2 添加图书 获取用户输入的数据 发送到后台 渲染最新的数据到页面上 123456789101112131415161718192021222324252627282930methods: { handle: async function(){ if(this.flag) { // 编辑图书 // 就是根据当前的ID去更新数组中对应的数据 this.books.some((item) =&gt; { if(item.id == this.id) { item.name = this.name; // 完成更新操作之后，需要终止循环 return true; } }); this.flag = false; }else{ # 1.1 在前面封装好的 handle 方法中 发送ajax请求 # 1.2 使用async 和 await 简化操作 需要在 function 前面添加 async var ret = await axios.post('books', { name: this.name }) # 1.3 根据后台返回的状态码判断是否加载数据 if(ret.status == 200) { # 1.4 调用 queryData 这个方法 渲染最新的数据 this.queryData(); } } // 清空表单 this.id = ''; this.name = ''; }, } 3 验证图书名称是否存在 添加图书之前发送请求验证图示是否已经存在 如果不存在 往后台里面添加图书名称 图书存在与否只需要修改submitFlag的值即可 12345678910111213141516 watch: { name: async function(val) { // 验证图书名称是否已经存在 // var flag = this.books.some(function(item){ // return item.name == val; // }); var ret = await axios.get('/books/book/' + this.name); if(ret.status == 1) { // 图书名称存在 this.submitFlag = true; }else{ // 图书名称不存在 this.submitFlag = false; } }}, 4. 编辑图书 根据当前书的id 查询需要编辑的书籍 需要根据状态位判断是添加还是编辑 1234567891011121314151617181920212223242526272829303132333435methods: { handle: async function(){ if(this.flag) { #4.3 编辑图书 把用户输入的信息提交到后台 var ret = await axios.put('books/' + this.id, { name: this.name }); if(ret.status == 200){ #4.4 完成添加后 重新加载列表数据 this.queryData(); } this.flag = false; }else{ // 添加图书 var ret = await axios.post('books', { name: this.name }) if(ret.status == 200) { // 重新加载列表数据 this.queryData(); } } // 清空表单 this.id = ''; this.name = ''; }, toEdit: async function(id){ #4.1 flag状态位用于区分编辑和添加操作 this.flag = true; #4.2 根据id查询出对应的图书信息 页面中可以加载出来最新的信息 # 调用接口发送ajax 请求 var ret = await axios.get('books/' + id); this.id = ret.id; this.name = ret.name; }, 5 删除图书 把需要删除的id书籍 通过参数的形式传递到后台 12345678deleteBook: async function(id){ // 删除图书 var ret = await axios.delete('books/' + id); if(ret.status == 200) { // 重新加载列表数据 this.queryData(); }} 路由###1.路由的概念 路由的本质就是一种对应关系，比如说我们在url地址中输入我们要访问的url地址之后，浏览器要去请求这个url地址对应的资源。那么url地址和真实的资源之间就有一种对应的关系，就是路由。 路由分为前端路由和后端路由1).后端路由是由服务器端进行实现，并完成资源的分发2).前端路由是依靠hash值(锚链接)的变化进行实现 后端路由性能相对前端路由来说较低，所以，我们接下来主要学习的是前端路由前端路由的基本概念：根据不同的事件来显示不同的页面内容，即事件与事件处理函数之间的对应关系前端路由主要做的事情就是监听事件并分发执行事件处理函数 ###2.前端路由的初体验 前端路由是基于hash值的变化进行实现的（比如点击页面中的菜单或者按钮改变URL的hash值，根据hash值的变化来控制组件的切换）核心实现依靠一个事件，即监听hash值变化的事件。 1234window.onhashchange = function(){ //location.hash可以获取到最新的hash值 location.hash} 前端路由实现tab栏切换： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 导入 vue 文件 --&gt; &lt;script src=\"./lib/vue_2.5.22.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 被 vue 实例控制的 div 区域 --&gt; &lt;div id=\"app\"&gt; &lt;!-- 切换组件的超链接 --&gt; &lt;a href=\"#/zhuye\"&gt;主页&lt;/a&gt; &lt;a href=\"#/keji\"&gt;科技&lt;/a&gt; &lt;a href=\"#/caijing\"&gt;财经&lt;/a&gt; &lt;a href=\"#/yule\"&gt;娱乐&lt;/a&gt; &lt;!-- 根据 :is 属性指定的组件名称，把对应的组件渲染到 component 标签所在的位置 --&gt; &lt;!-- 可以把 component 标签当做是【组件的占位符】 --&gt; &lt;component :is=\"comName\"&gt;&lt;/component&gt; &lt;/div&gt; &lt;script&gt; // #region 定义需要被切换的 4 个组件 // 主页组件 const zhuye = { template: '&lt;h1&gt;主页信息&lt;/h1&gt;' } // 科技组件 const keji = { template: '&lt;h1&gt;科技信息&lt;/h1&gt;' } // 财经组件 const caijing = { template: '&lt;h1&gt;财经信息&lt;/h1&gt;' } // 娱乐组件 const yule = { template: '&lt;h1&gt;娱乐信息&lt;/h1&gt;' } // #endregion // #region vue 实例对象 const vm = new Vue({ el: '#app', data: { comName: 'zhuye' }, // 注册私有组件 components: { zhuye, keji, caijing, yule } }) // #endregion // 监听 window 的 onhashchange 事件，根据获取到的最新的 hash 值，切换要显示的组件的名称 window.onhashchange = function() { // 通过 location.hash 获取到最新的 hash 值 console.log(location.hash); switch(location.hash.slice(1)){ case '/zhuye': vm.comName = 'zhuye' break case '/keji': vm.comName = 'keji' break case '/caijing': vm.comName = 'caijing' break case '/yule': vm.comName = 'yule' break } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 案例效果图： ![01前端路由(/images/vue.assets/01前端路由(1).png)](17-21 Vue.js项目实战开发/20-21vue电商/1.vue-路由/笔记/images/01前端路由(1).png) 点击每个超链接之后，会进行相应的内容切换，如下： 核心思路：在页面中有一个vue实例对象，vue实例对象中有四个组件，分别是tab栏切换需要显示的组件内容在页面中有四个超链接，如下： 1234&lt;a href=\"#/zhuye\"&gt;主页&lt;/a&gt; &lt;a href=\"#/keji\"&gt;科技&lt;/a&gt; &lt;a href=\"#/caijing\"&gt;财经&lt;/a&gt;&lt;a href=\"#/yule\"&gt;娱乐&lt;/a&gt; 当我们点击这些超链接的时候，就会改变url地址中的hash值，当hash值被改变时，就会触发onhashchange事件在触发onhashchange事件的时候，我们根据hash值来让不同的组件进行显示： 1234567891011121314151617181920window.onhashchange = function() { // 通过 location.hash 获取到最新的 hash 值 console.log(location.hash); switch(location.hash.slice(1)){ case '/zhuye': //通过更改数据comName来指定显示的组件 //因为 &lt;component :is=\"comName\"&gt;&lt;/component&gt; ，组件已经绑定了comName vm.comName = 'zhuye' break case '/keji': vm.comName = 'keji' break case '/caijing': vm.comName = 'caijing' break case '/yule': vm.comName = 'yule' break }} ###3.Vue Router简介 它是一个Vue.js官方提供的路由管理器。是一个功能更加强大的前端路由器，推荐使用。Vue Router和Vue.js非常契合，可以一起方便的实现SPA(single page web application,单页应用程序)应用程序的开发。Vue Router依赖于Vue，所以需要先引入Vue，再引入Vue Router. Vue Router的特性：支持H5历史模式或者hash模式支持嵌套路由支持路由参数支持编程式路由支持命名路由支持路由导航守卫支持路由过渡动画特效支持路由懒加载支持路由滚动行为 ###4.Vue Router的使用步骤(★★★) A.导入js文件 \\&lt;script src=&quot;lib/vue_2.5.22.js”&gt;\\&lt;/script&gt;`&lt;script src=”lib/vue-router_3.0.2.js”&gt;&lt;/script&gt;` B.添加路由链接:&lt;router-link&gt;是路由中提供的标签，默认会被渲染为a标签，to属性默认被渲染为href属性，to属性的值会被渲染为#开头的hash地址&lt;router-link to=”/user”&gt;User&lt;/router-link&gt;&lt;router-link to=”/login”&gt;Login&lt;/router-link&gt;C.添加路由填充位（路由占位符）&lt;router-view&gt;&lt;/router-view&gt;D.定义路由组件var User = { template:”&lt;div&gt;This is User&lt;/div&gt;” }var Login = { template:”&lt;div&gt;This is Login&lt;/div&gt;” }E.配置路由规则并创建路由实例var myRouter = new VueRouter({ //routes是路由规则数组 routes:[ //每一个路由规则都是一个对象，对象中至少包含path和component两个属性 //path表示 路由匹配的hash地址，component表示路由规则对应要展示的组件对象 {path:”/user”,component:User}, {path:”/login”,component:Login} ]})F.将路由挂载到Vue实例中new Vue({ el:”#app”, //通过router属性挂载路由对象 router:myRouter}) 小结：Vue Router的使用步骤还是比较清晰的，按照步骤一步一步就能完成路由操作A.导入js文件B.添加路由链接C.添加路由占位符(最后路由展示的组件就会在占位符的位置显示)D.定义路由组件E.配置路由规则并创建路由实例F.将路由挂载到Vue实例中 补充：路由重定向：可以通过路由重定向为页面设置默认展示的组件在路由规则中添加一条路由规则即可，如下：var myRouter = new VueRouter({ //routes是路由规则数组 routes: [ //path设置为/表示页面最初始的地址 / ,redirect表示要被重定向的新地址，设置为一个路由即可 { path:”/“,redirect:”/user”}, { path: “/user”, component: User }, { path: “/login”, component: Login } ]}) ###5.嵌套路由，动态路由的实现方式 ####A.嵌套路由的概念(★★★) 当我们进行路由的时候显示的组件中还有新的子级路由链接以及内容。 嵌套路由最关键的代码在于理解子级路由的概念：比如我们有一个/login的路由那么/login下面还可以添加子级路由，如:/login/account/login/phone 参考代码如下： 1234567891011121314151617181920212223242526272829303132333435var User = { template: \"&lt;div&gt;This is User&lt;/div&gt;\" }//Login组件中的模板代码里面包含了子级路由链接以及子级路由的占位符var Login = { template: `&lt;div&gt; &lt;h1&gt;This is Login&lt;/h1&gt; &lt;hr&gt; &lt;router-link to=\"/login/account\"&gt;账号密码登录&lt;/router-link&gt; &lt;router-link to=\"/login/phone\"&gt;扫码登录&lt;/router-link&gt; &lt;!-- 子路由组件将会在router-view中显示 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;` }//定义两个子级路由组件var account = { template:\"&lt;div&gt;账号：&lt;input&gt;&lt;br&gt;密码：&lt;input&gt;&lt;/div&gt;\"};var phone = { template:\"&lt;h1&gt;扫我二维码&lt;/h1&gt;\"};var myRouter = new VueRouter({ //routes是路由规则数组 routes: [ { path:\"/\",redirect:\"/user\"}, { path: \"/user\", component: User }, { path: \"/login\", component: Login, //通过children属性为/login添加子路由规则 children:[ { path: \"/login/account\", component: account }, { path: \"/login/phone\", component: phone }, ] } ]})var vm = new Vue({ el: '#app', data: {}, methods: {}, router:myRouter}); 页面效果大致如下： ####B.动态路由匹配(★★★) var User = { template:&quot;&lt;div&gt;用户：&lt;/div&gt;&quot;} 12345678var myRouter = new VueRouter({ //routes是路由规则数组 routes: [ //通过/:参数名 的形式传递参数 { path: \"/user/:id\", component: User }, ]}) 补充：如果使用$route.params.id来获取路径传参的数据不够灵活。1.我们可以通过props来接收参数 1234567891011121314var User = { props:[\"id\"], template:”\\div&gt;用户：{{id}}\\&lt;/div&gt;\"}var myRouter = new VueRouter({ //routes是路由规则数组 routes: [ //通过/:参数名 的形式传递参数 //如果props设置为true，route.params将会被设置为组件属性 { path: \"/user/:id\", component: User,props:true }, ]}) 2.还有一种情况，我们可以将props设置为对象，那么就直接将对象的数据传递给组件进行使用 1234567891011121314var User = { props:[\"username\",\"pwd\"], template:\"&lt;div&gt;用户：{{username}}---{{pwd}}&lt;/div&gt;\" }var myRouter = new VueRouter({ //routes是路由规则数组 routes: [ //通过/:参数名 的形式传递参数 //如果props设置为对象，则传递的是对象中的数据给组件 { path: \"/user/:id\", component: User,props:{username:\"jack\",pwd:123} }, ]}) 3.如果想要获取传递的参数值还想要获取传递的对象数据，那么props应该设置为函数形式。 12345678910111213141516171819var User = { props:[\"username\",\"pwd\",\"id\"], template:\"&lt;div&gt;用户：{{id}} -&gt; {{username}}---{{pwd}}&lt;/div&gt;\" }var myRouter = new VueRouter({ //routes是路由规则数组 routes: [ //通过/:参数名 的形式传递参数 //如果props设置为函数，则通过函数的第一个参数获取路由对象 //并可以通过路由对象的params属性获取传递的参数 // { path: \"/user/:id\", component: User,props:(route)=&gt;{ return {username:\"jack\",pwd:123,id:route.params.id} } }, ]}) ###7.命名路由以及编程式导航 ####A.命名路由：给路由取别名 案例： 12345678var myRouter = new VueRouter({ //routes是路由规则数组 routes: [ //通过name属性为路由添加一个别名 { path: \"/user/:id\", component: User, name:\"user\"}, ]}) //添加了别名之后，可以使用别名进行跳转&lt;router-link to=”/user”&gt;User&lt;/router-link&gt;&lt;router-link :to=”{ name:’user’ , params: {id:123} }”&gt;User&lt;/router-link&gt; //还可以编程式导航myRouter.push( { name:’user’ , params: {id:123} } ) ####B.编程式导航(★★★) 页面导航的两种方式：A.声明式导航：通过点击链接的方式实现的导航B.编程式导航：调用js的api方法实现导航 Vue-Router中常见的导航方式： 12345678this.$router.push(\"hash地址\");this.$router.push(\"/login\");this.$router.push({ name:'user' , params: {id:123} });this.$router.push({ path:\"/login\" });this.$router.push({ path:\"/login\",query:{username:\"jack\"} });this.$router.go( n );//n为数字，参考history.gothis.$router.go( -1 ); ###8.实现后台管理案例(★★★) 案例效果： 点击左侧的”用户管理”,”权限管理”,”商品管理”,”订单管理”,”系统设置”都会出现对应的组件并展示内容 其中”用户管理”组件展示的效果如上图所示，在用户管理区域中的详情链接也是可以点击的，点击之后将会显示用户详情信息。 案例思路：1).先将素材文件夹中的11.基于vue-router的案例.html复制到我们自己的文件夹中。看一下这个文件中的代码编写了一些什么内容，这个页面已经把后台管理页面的基本布局实现了2).在页面中引入vue，vue-router3).创建Vue实例对象，准备开始编写代码实现功能4).希望是通过组件的形式展示页面的主体内容，而不是写死页面结构，所以我们可以定义一个根组件： 1234567891011121314151617181920212223242526//只需要把原本页面中的html代码设置为组件中的模板内容即可const app = { template:`&lt;div&gt; &lt;!-- 头部区域 --&gt; &lt;header class=\"header\"&gt;传智后台管理系统&lt;/header&gt; &lt;!-- 中间主体区域 --&gt; &lt;div class=\"main\"&gt; &lt;!-- 左侧菜单栏 --&gt; &lt;div class=\"content left\"&gt; &lt;ul&gt; &lt;li&gt;用户管理&lt;/li&gt; &lt;li&gt;权限管理&lt;/li&gt; &lt;li&gt;商品管理&lt;/li&gt; &lt;li&gt;订单管理&lt;/li&gt; &lt;li&gt;系统设置&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 右侧内容区域 --&gt; &lt;div class=\"content right\"&gt; &lt;div class=\"main-content\"&gt;添加用户表单&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 尾部区域 --&gt; &lt;footer class=\"footer\"&gt;版权信息&lt;/footer&gt; &lt;/div&gt;` } 5).当我们访问页面的时候，默认需要展示刚刚创建的app根组件，我们可以创建一个路由对象来完成这个事情,然后将路由挂载到Vue实例对象中即可 123456789101112const myRouter = new VueRouter({ routes:[ {path:\"/\",component:app} ]})const vm = new Vue({ el:\"#app\", data:{}, methods:{}, router:myRouter}) 补充：到此为止，基本的js代码都处理完毕了，我们还需要设置一个路由占位符 12345&lt;body&gt; &lt;div id=\"app\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/body&gt; 6).此时我们打开页面应该就可以得到一个VueRouter路由出来的根组件了我们需要在这个根组件中继续路由实现其他的功能子组件先让我们更改根组件中的模板：更改左侧li为子级路由链接，并在右侧内容区域添加子级组件占位符 1234567891011121314151617181920212223242526const app = { template:`&lt;div&gt; ........ &lt;div class=\"main\"&gt; &lt;!-- 左侧菜单栏 --&gt; &lt;div class=\"content left\"&gt; &lt;ul&gt; &lt;!-- 注意：我们把所有li都修改为了路由链接 --&gt; &lt;li&gt;&lt;router-link to=\"/users\"&gt;用户管理&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/accesses\"&gt;权限管理&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/goods\"&gt;商品管理&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/orders\"&gt;订单管理&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/systems\"&gt;系统设置&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 右侧内容区域 --&gt; &lt;div class=\"content right\"&gt; &lt;div class=\"main-content\"&gt; &lt;!-- 在 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ....... &lt;/div&gt;` } 然后，我们要为子级路由创建并设置需要显示的子级组件 123456789101112131415161718192021222324252627282930313233343536//建议创建的组件首字母大写，和其他内容区分const Users = {template:`&lt;div&gt; &lt;h3&gt;用户管理&lt;/h3&gt;&lt;/div&gt;`}const Access = {template:`&lt;div&gt; &lt;h3&gt;权限管理&lt;/h3&gt;&lt;/div&gt;`}const Goods = {template:`&lt;div&gt; &lt;h3&gt;商品管理&lt;/h3&gt;&lt;/div&gt;`}const Orders = {template:`&lt;div&gt; &lt;h3&gt;订单管理&lt;/h3&gt;&lt;/div&gt;`}const Systems = {template:`&lt;div&gt; &lt;h3&gt;系统管理&lt;/h3&gt;&lt;/div&gt;`}//添加子组件的路由规则const myRouter = new VueRouter({ routes:[ {path:\"/\",component:app , children:[ { path:\"/users\",component:Users }, { path:\"/accesses\",component:Access }, { path:\"/goods\",component:Goods }, { path:\"/orders\",component:Orders }, { path:\"/systems\",component:Systems }, ]} ]})const vm = new Vue({ el:\"#app\", data:{}, methods:{}, router:myRouter}) 7).展示用户信息列表： A.为Users组件添加私有数据,并在模板中循环展示私有数据 ​``` const Users = { data(){ return { userList:[ {id:1,name:”zs”,age:18}, {id:2,name:”ls”,age:19}, {id:3,name:”wang”,age:20}, {id:4,name:”jack”,age:21}, ] } }, template:` &lt;h3&gt;用户管理&lt;/h3&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr :key=&quot;item.id&quot; v-for=&quot;item in userList&quot;&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.age}}&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;javascript:;&quot;&gt;详情&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;​ `}​ ​``` 8.当用户列表展示完毕之后，我们可以点击列表中的详情来显示用户详情信息，首先我们需要创建一个组件，用来展示详情信息 1234567891011121314const UserInfo = { props:[\"id\"], template:`&lt;div&gt; &lt;h5&gt;用户详情&lt;/h5&gt; &lt;p&gt;查看 {{id}} 号用户信息&lt;/p&gt; &lt;button @click=\"goBack\"&gt;返回用户详情页&lt;/button&gt; &lt;/div&gt; `, methods:{ goBack(){ //当用户点击按钮，后退一页 this.$router.go(-1); } } } 然后我们需要设置这个组件的路由规则 1234567891011121314151617181920const myRouter = new VueRouter({ routes:[ {path:\"/\",component:app , children:[ { path:\"/users\",component:Users }, //添加一个/userinfo的路由规则 { path:\"/userinfo/:id\",component:UserInfo,props:true}, { path:\"/accesses\",component:Access }, { path:\"/goods\",component:Goods }, { path:\"/orders\",component:Orders }, { path:\"/systems\",component:Systems }, ]} ]})const vm = new Vue({ el:\"#app\", data:{}, methods:{}, router:myRouter}) 再接着给用户列表中的详情a连接添加事件 1234567891011121314151617181920212223242526272829303132333435363738const Users = { data(){ return { userList:[ {id:1,name:\"zs\",age:18}, {id:2,name:\"ls\",age:19}, {id:3,name:\"wang\",age:20}, {id:4,name:\"jack\",age:21}, ] } }, template:`&lt;div&gt; &lt;h3&gt;用户管理&lt;/h3&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr :key=\"item.id\" v-for=\"item in userList\"&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.age}}&lt;/td&gt; &lt;td&gt;&lt;a href=\"javascript:;\" @click=\"goDetail(item.id)\"&gt;详情&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt;`, methods:{ goDetail(id){ this.$router.push(\"/userinfo/\"+id); } }} Vue工程化###1.模块化的分类 ####A.浏览器端的模块化 12341).AMD(Asynchronous Module Definition,异步模块定义)代表产品为：Require.js2).CMD(Common Module Definition,通用模块定义)代表产品为：Sea.js ####B.服务器端的模块化 服务器端的模块化规范是使用CommonJS规范： 1).使用require引入其他模块或者包 2).使用exports或者module.exports导出模块成员 3).一个文件就是一个模块，都拥有独立的作用域####C.ES6模块化 ES6模块化规范中定义： 1).每一个js文件都是独立的模块 2).导入模块成员使用import关键字 3).暴露模块成员使用export关键字小结：推荐使用ES6模块化，因为AMD，CMD局限使用与浏览器端，而CommonJS在服务器端使用。 ES6模块化是浏览器端和服务器端通用的规范. ###2.在NodeJS中安装babel ####A.安装babel 打开终端，输入命令：npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel/node 安装完毕之后，再次输入命令安装：npm install --save @babel/polyfill####B.创建babel.config.js 在项目目录中创建babel.config.js文件。 编辑js文件中的代码如下： const presets = [ [&quot;@babel/env&quot;,{ targets:{ edge:&quot;17&quot;, firefox:&quot;60&quot;, chrome:&quot;67&quot;, safari:&quot;11.1&quot; } }] ] //暴露 module.exports = { presets }####C.创建index.js文件 在项目目录中创建index.js文件作为入口文件 在index.js中输入需要执行的js代码，例如： console.log(&quot;ok&quot;);####D.使用npx执行文件 打开终端，输入命令：npx babel-node ./index.js###3.设置默认导入/导出 ####A.默认导出 export default { 成员A, 成员B, ....... },如下： let num = 100; export default{ num }####B.默认导入 import 接收名称 from &quot;模块标识符&quot;，如下： import test from &quot;./test.js&quot;注意：在一个模块中，只允许使用export default向外默认暴露一次成员，千万不要写多个export default。如果在一个模块中没有向外暴露成员，其他模块引入该模块时将会得到一个空对象. ###4.设置按需导入/导出 ####A.按需导出 123export let num = 998;export let myName = \"jack\";export function fn = function(){ console.log(\"fn\") } ####B.按需导入 123import { num,fn as printFn ,myName } from \"./test.js\"//同时导入默认导出的成员以及按需导入的成员import test,{ num,fn as printFn ,myName } from \"./test.js\" 注意：一个模块中既可以按需导入也可以默认导入，一个模块中既可以按需导出也可以默认导出 ###5.直接导入并执行代码 1import \"./test2.js\"; ###6.webpack的概念 webpack是一个流行的前端项目构建工具，可以解决目前web开发的困境。webpack提供了模块化支持，代码压缩混淆，解决js兼容问题，性能优化等特性，提高了开发效率和项目的可维护性 ###7.webpack的基本使用 ####A.创建项目目录并初始化 创建项目，并打开项目所在目录的终端，输入命令： npm init -y####B.创建首页及js文件 在项目目录中创建index.html页面，并初始化页面结构：在页面中摆放一个ul，ul里面放置几个li 在项目目录中创建js文件夹，并在文件夹中创建index.js文件####C.安装jQuery 打开项目目录终端，输入命令: npm install jQuery -S####D.导入jQuery 123456//打开index.js文件，编写代码导入jQuery并实现功能：import $ from \"jquery\";$(function(){ $(\"li:odd\").css(\"background\",\"cyan\"); $(\"li:odd\").css(\"background\",\"pink\");}) 注意：此时项目运行会有错误，因为import $ from “jquery”;这句代码属于ES6的新语法代码，在浏览器中可能会存在兼容性问题所以我们需要webpack来帮助我们解决这个问题。 ####E.安装webpack 123456789101112131415161718192021221).打开项目目录终端，输入命令:npm install webpack webpack-cli -D2).然后在项目根目录中，创建一个 webpack.config.js 的配置文件用来配置webpack在 webpack.config.js 文件中编写代码进行webpack配置，如下：module.exports = { mode:\"development\"//可以设置为development(开发模式)，production(发布模式)}补充：mode设置的是项目的编译模式。如果设置为development则表示项目处于开发阶段，不会进行压缩和混淆，打包速度会快一些如果设置为production则表示项目处于上线发布阶段，会进行压缩和混淆，打包速度会慢一些3).修改项目中的package.json文件添加运行脚本dev，如下：\"scripts\":{ \"dev\":\"webpack\"}注意：scripts节点下的脚本，可以通过 npm run 运行，如：运行终端命令：npm run dev将会启动webpack进行项目打包4).运行dev命令进行项目打包，并在页面中引入项目打包生成的js文件打开项目目录终端，输入命令:npm run dev等待webpack打包完毕之后，找到默认的dist路径中生成的main.js文件，将其引入到html页面中。浏览页面查看效果。 ###8.设置webpack的打包入口/出口 12345678910111213141516在webpack 4.x中，默认会将src/index.js 作为默认的打包入口js文件 默认会将dist/main.js 作为默认的打包输出js文件如果不想使用默认的入口/出口js文件，我们可以通过改变 webpack.config.js 来设置入口/出口的js文件，如下：const path = require(\"path\");module.exports = { mode:\"development\", //设置入口文件路径 entry: path.join(__dirname,\"./src/xx.js\"), //设置出口文件 output:{ //设置路径 path:path.join(__dirname,\"./dist\"), //设置文件名 filename:\"res.js\" }} ###9.设置webpack的自动打包 1234567891011121314默认情况下，我们更改入口js文件的代码，需要重新运行命令打包webpack，才能生成出口的js文件那么每次都要重新执行命令打包，这是一个非常繁琐的事情，那么，自动打包可以解决这样繁琐的操作。实现自动打包功能的步骤如下： A.安装自动打包功能的包:webpack-dev-server npm install webpack-dev-server -D B.修改package.json中的dev指令如下： \"scripts\":{ \"dev\":\"webpack-dev-server\" } C.将引入的js文件路径更改为：&lt;script src=\"/bundle.js\"&gt;&lt;/script&gt; D.运行npm run dev，进行打包 E.打开网址查看效果：http://localhost:8080注意：webpack-dev-server自动打包的输出文件，默认放到了服务器的根目录中. 补充：在自动打包完毕之后，默认打开服务器网页，实现方式就是打开package.json文件，修改dev命令： “dev”: “webpack-dev-server –open –host 127.0.0.1 –port 9999” ###10.配置html-webpack-plugin 123456789101112131415161718192021使用html-webpack-plugin 可以生成一个预览页面。因为当我们访问默认的 http://localhost:8080/的时候，看到的是一些文件和文件夹，想要查看我们的页面还需要点击文件夹点击文件才能查看，那么我们希望默认就能看到一个页面，而不是看到文件夹或者目录。实现默认预览页面功能的步骤如下： A.安装默认预览功能的包:html-webpack-plugin npm install html-webpack-plugin -D B.修改webpack.config.js文件，如下： //导入包 const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); //创建对象 const htmlPlugin = new HtmlWebpackPlugin({ //设置生成预览页面的模板文件 template:\"./src/index.html\", //设置生成的预览页面名称 filename:\"index.html\" }) C.继续修改webpack.config.js文件，添加plugins信息： module.exports = { ...... plugins:[ htmlPlugin ] } ###11.webpack中的加载器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193通过loader打包非js模块：默认情况下，webpack只能打包js文件，如果想要打包非js文件，需要调用loader加载器才能打包 loader加载器包含： 1).less-loader 2).sass-loader 3).url-loader:打包处理css中与url路径有关的文件 4).babel-loader:处理高级js语法的加载器 5).postcss-loader 6).css-loader,style-loader注意：指定多个loader时的顺序是固定的，而调用loader的顺序是从后向前进行调用A.安装style-loader,css-loader来处理样式文件 1).安装包 npm install style-loader css-loader -D 2).配置规则：更改webpack.config.js的module中的rules数组 module.exports = { ...... plugins:[ htmlPlugin ], module : { rules:[ { //test设置需要匹配的文件类型，支持正则 test:/\\.css$/, //use表示该文件类型需要调用的loader use:['style-loader','css-loader'] } ] } }B.安装less,less-loader处理less文件 1).安装包 npm install less-loader less -D 2).配置规则：更改webpack.config.js的module中的rules数组 module.exports = { ...... plugins:[ htmlPlugin ], module : { rules:[ { //test设置需要匹配的文件类型，支持正则 test:/\\.css$/, //use表示该文件类型需要调用的loader use:['style-loader','css-loader'] }, { test:/\\.less$/, use:['style-loader','css-loader','less-loader'] } ] } }C.安装sass-loader,node-sass处理less文件 1).安装包 npm install sass-loader node-sass -D 2).配置规则：更改webpack.config.js的module中的rules数组 module.exports = { ...... plugins:[ htmlPlugin ], module : { rules:[ { //test设置需要匹配的文件类型，支持正则 test:/\\.css$/, //use表示该文件类型需要调用的loader use:['style-loader','css-loader'] }, { test:/\\.less$/, use:['style-loader','css-loader','less-loader'] }, { test:/\\.scss$/, use:['style-loader','css-loader','sass-loader'] } ] } } 补充：安装sass-loader失败时，大部分情况是因为网络原因，详情参考： https://segmentfault.com/a/1190000010984731?utm_source=tag-newestD.安装post-css自动添加css的兼容性前缀（-ie-,-webkit-）1).安装包 npm install postcss-loader autoprefixer -D2).在项目根目录创建并配置postcss.config.js文件const autoprefixer = require(\"autoprefixer\");module.exports = { plugins:[ autoprefixer ]}3).配置规则：更改webpack.config.js的module中的rules数组module.exports = { ...... plugins:[ htmlPlugin ], module : { rules:[ { //test设置需要匹配的文件类型，支持正则 test:/\\.css$/, //use表示该文件类型需要调用的loader use:['style-loader','css-loader','postcss-loader'] }, { test:/\\.less$/, use:['style-loader','css-loader','less-loader'] }, { test:/\\.scss$/, use:['style-loader','css-loader','sass-loader'] } ] }}E.打包样式表中的图片以及字体文件在样式表css中有时候会设置背景图片和设置字体文件，一样需要loader进行处理使用url-loader和file-loader来处理打包图片文件以及字体文件1).安装包 npm install url-loader file-loader -D2).配置规则：更改webpack.config.js的module中的rules数组module.exports = { ...... plugins:[ htmlPlugin ], module : { rules:[ { //test设置需要匹配的文件类型，支持正则 test:/\\.css$/, //use表示该文件类型需要调用的loader use:['style-loader','css-loader'] }, { test:/\\.less$/, use:['style-loader','css-loader','less-loader'] }, { test:/\\.scss$/, use:['style-loader','css-loader','sass-loader'] },{ test:/\\.jpg|png|gif|bmp|ttf|eot|svg|woff|woff2$/, //limit用来设置字节数，只有小于limit值的图片，才会转换 //为base64图片 use:\"url-loader?limit=16940\" } ] }}F.打包js文件中的高级语法：在编写js的时候，有时候我们会使用高版本的js语法有可能这些高版本的语法不被兼容，我们需要将之打包为兼容性的js代码我们需要安装babel系列的包A.安装babel转换器 npm install babel-loader @babel/core @babel/runtime -DB.安装babel语法插件包 npm install @babel/preset-env @babel/plugin-transform-runtime @babel/plugin-proposal-class-properties -DC.在项目根目录创建并配置babel.config.js文件 module.exports = { presets:[\"@babel/preset-env\"], plugins:[ \"@babel/plugin-transform-runtime\", \"@babel/plugin-proposal-class-properties\" ] }D.配置规则：更改webpack.config.js的module中的rules数组module.exports = { ...... plugins:[ htmlPlugin ], module : { rules:[ { //test设置需要匹配的文件类型，支持正则 test:/\\.css$/, //use表示该文件类型需要调用的loader use:['style-loader','css-loader'] }, { test:/\\.less$/, use:['style-loader','css-loader','less-loader'] }, { test:/\\.scss$/, use:['style-loader','css-loader','sass-loader'] },{ test:/\\.jpg|png|gif|bmp|ttf|eot|svg|woff|woff2$/, //limit用来设置字节数，只有小于limit值的图片，才会转换 //为base64图片 use:\"url-loader?limit=16940\" },{ test:/\\.js$/, use:\"babel-loader\", //exclude为排除项，意思是不要处理node_modules中的js文件 exclude:/node_modules/ } ] }} ###12.Vue单文件组件 传统Vue组件的缺陷：全局定义的组件不能重名，字符串模板缺乏语法高亮，不支持css(当html和js组件化时，css没有参与其中)没有构建步骤限制，只能使用H5和ES5，不能使用预处理器（babel）解决方案：使用Vue单文件组件，每个单文件组件的后缀名都是.vue每一个Vue单文件组件都由三部分组成1).template组件组成的模板区域2).script组成的业务逻辑区域3).style样式区域 代码如下： 1234567891011&lt;template&gt; 组件代码区域&lt;/template&gt;&lt;script&gt; js代码区域&lt;/script&gt;&lt;style scoped&gt; 样式代码区域&lt;/style&gt; 补充：安装Vetur插件可以使得.vue文件中的代码高亮 配置.vue文件的加载器A.安装vue组件的加载器 npm install vue-loader vue-template-compiler -DB.配置规则：更改webpack.config.js的module中的rules数组 123456789101112131415const VueLoaderPlugin = require(\"vue-loader/lib/plugin\");const vuePlugin = new VueLoaderPlugin();module.exports = { ...... plugins:[ htmlPlugin, vuePlugin ], module : { rules:[ ...//其他规则 { test:/\\.vue$/, loader:\"vue-loader\", } ] }} ###13.在webpack中使用vue 上一节我们安装处理了vue单文件组件的加载器，想要让vue单文件组件能够使用，我们必须要安装vue并使用vue来引用vue单文件组件。A.安装Vue npm install vue -SB.在index.js中引入vue：import Vue from &quot;vue&quot;C.创建Vue实例对象并指定el，最后使用render函数渲染单文件组件 1234const vm = new Vue({ el:\"#first\", render:h=&gt;h(app)}) ###14.使用webpack打包发布项目 在项目上线之前，我们需要将整个项目打包并发布。A.配置package.json 1234\"scripts\":{ \"dev\":\"webpack-dev-server\", \"build\":\"webpack -p\"} B.在项目打包之前，可以将dist目录删除，生成全新的dist目录 ###15.Vue脚手架 Vue脚手架可以快速生成Vue项目基础的架构。A.安装3.x版本的Vue脚手架： npm install -g @vue/cliB.基于3.x版本的脚手架创建Vue项目： 1).使用命令创建Vue项目 命令：vue create my-project 选择Manually select features(选择特性以创建项目) 勾选特性可以用空格进行勾选。 是否选用历史模式的路由：n ESLint选择：ESLint + Standard config 何时进行ESLint语法校验：Lint on save babel，postcss等配置文件如何放置：In dedicated config files(单独使用文件进行配置) 是否保存为模板：n 使用哪个工具安装包：npm 2).基于ui界面创建Vue项目 命令：vue ui 在自动打开的创建项目网页中配置项目信息。 3).基于2.x的旧模板，创建Vue项目 npm install -g @vue/cli-init vue init webpack my-project C.分析Vue脚手架生成的项目结构 node_modules:依赖包目录 public：静态资源目录 src：源码目录 src/assets:资源目录 src/components：组件目录 src/views:视图组件目录 src/App.vue:根组件 src/main.js:入口js src/router.js:路由js babel.config.js:babel配置文件 .eslintrc.js: ###16.Vue脚手架的自定义配置 1234567891011121314A.通过 package.json 进行配置 [不推荐使用] \"vue\":{ \"devServer\":{ \"port\":\"9990\", \"open\":true } }B.通过单独的配置文件进行配置，创建vue.config.js module.exports = { devServer:{ port:8888, open:true } } Vuex###1.Vuex概述 Vuex是实现组件全局状态（数据）管理的一种机制，可以方便的实现组件之间的数据共享 使用Vuex管理数据的好处：A.能够在vuex中集中管理共享的数据，便于开发和后期进行维护B.能够高效的实现组件之间的数据共享，提高开发效率C.存储在vuex中的数据是响应式的，当数据发生改变时，页面中的数据也会同步更新 ###2.Vuex的基本使用 创建带有vuex的vue项目，打开终端，输入命令：vue ui当项目仪表盘打开之后，我们点击页面左上角的项目管理下拉列表，再点击Vue项目管理器点击创建项目，如下图所示第一步，设置项目名称和包管理器第二步，设置手动配置项目第三步，设置功能项![创建vuex项目04(/images/vue.assets/创建vuex项目04(1).png)](17-21 Vue.js项目实战开发/20-21vue电商/10.vuex/笔记/images/创建vuex项目04(1).png)第四步，创建项目 ###3.使用Vuex完成计数器案例 打开刚刚创建的vuex项目，找到src目录中的App.vue组件，将代码重新编写如下： 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;my-addition&gt;&lt;/my-addition&gt; &lt;p&gt;----------------------------------------&lt;/p&gt; &lt;my-subtraction&gt;&lt;/my-subtraction&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Addition from './components/Addition.vue'import Subtraction from './components/Subtraction.vue'export default { data() { return {} }, components: { 'my-subtraction': Subtraction, 'my-addition': Addition }}&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 在components文件夹中创建Addition.vue组件，代码如下： 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;h3&gt;当前最新的count值为：&lt;/h3&gt; &lt;button&gt;+1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return {} }}&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 在components文件夹中创建Subtraction.vue组件，代码如下： 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;h3&gt;当前最新的count值为：&lt;/h3&gt; &lt;button&gt;-1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return {} }}&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 最后在项目根目录(与src平级)中创建 .prettierrc 文件，编写代码如下： 1234{ \"semi\":false, \"singleQuote\":true} ###4.Vuex中的核心特性 ####A.State State提供唯一的公共数据源，所有共享的数据都要统一放到Store中的State中存储例如，打开项目中的store.js文件，在State对象中可以添加我们要共享的数据，如：count:0 在组件中访问State的方式： this.\\$store.state.全局数据名称 如：this.$store.state.count 先按需导入mapState函数：import { mapState } from 'vuex' 然后数据映射为计算属性： computed:{ ...mapState(['全局数据名称']) } ####B.Mutation Mutation用于修改变更$store中的数据使用方式：打开store.js文件，在mutations中添加代码如下 1234567mutations: { add(state,step){ //第一个形参永远都是state也就是$state对象 //第二个形参是调用add时传递的参数 state.count+=step; }} 然后在Addition.vue中给按钮添加事件代码如下： 123456789&lt;button @click=\"Add\"&gt;+1&lt;/button&gt;methods:{ Add(){ //使用commit函数调用mutations中的对应函数， //第一个参数就是我们要调用的mutations中的函数名 //第二个参数就是传递给add函数的参数 this.$store.commit('add',10) }} 使用mutations的第二种方式： 12345import { mapMutations } from 'vuex'methods:{ ...mapMutations(['add'])} 如下： 12345678910111213141516171819import { mapState,mapMutations } from 'vuex'export default { data() { return {} }, methods:{ //获得mapMutations映射的sub函数 ...mapMutations(['sub']), //当点击按钮时触发Sub函数 Sub(){ //调用sub函数完成对数据的操作 this.sub(10); } }, computed:{ ...mapState(['count']) }} ####C.Action 在mutations中不能编写异步的代码，会导致vue调试器的显示出错。在vuex中我们可以使用Action来执行异步操作。操作步骤如下：打开store.js文件，修改Action，如下： 1234567actions: { addAsync(context,step){ setTimeout(()=&gt;{ context.commit('add',step); },2000) }} 然后在Addition.vue中给按钮添加事件代码如下： 1234567&lt;button @click=&quot;AddAsync&quot;&gt;...+1&lt;/button&gt;methods:{ AddAsync(){ this.$store.dispatch('addAsync',5) }} 第二种方式： 12345import { mapActions } from 'vuex'methods:{ ...mapActions(['subAsync'])} 如下： 12345678910111213141516171819202122232425import { mapState,mapMutations,mapActions } from 'vuex'export default { data() { return {} }, methods:{ //获得mapMutations映射的sub函数 ...mapMutations(['sub']), //当点击按钮时触发Sub函数 Sub(){ //调用sub函数完成对数据的操作 this.sub(10); }, //获得mapActions映射的addAsync函数 ...mapActions(['subAsync']), asyncSub(){ this.subAsync(5); } }, computed:{ ...mapState(['count']) }} ####D.Getter Getter用于对Store中的数据进行加工处理形成新的数据它只会包装Store中保存的数据，并不会修改Store中保存的数据，当Store中的数据发生变化时，Getter生成的内容也会随之变化打开store.js文件，添加getters，如下： 123456789export default new Vuex.Store({ ....... getters:{ //添加了一个showNum的属性 showNum : state =&gt;{ return '最新的count值为：'+state.count; } }}) 然后打开Addition.vue中 添加插值表达式使用getters, 也可以在Addition.vue中，导入mapGetters，并将之映射为计算属性 1234import { mapGetters } from 'vuex'computed:{ ...mapGetters(['showNum'])} ###5.vuex案例 ####A.初始化案例 首先使用vue ui初始化一个使用vuex的案例然后打开public文件夹，创建一个list.json文件，文件代码如下： 123456789101112131415161718192021222324252627[ { \"id\": 0, \"info\": \"Racing car sprays burning fuel into crowd.\", \"done\": false }, { \"id\": 1, \"info\": \"Japanese princess to wed commoner.\", \"done\": false }, { \"id\": 2, \"info\": \"Australian walks 100km after outback crash.\", \"done\": false }, { \"id\": 3, \"info\": \"Man charged over missing wedding girl.\", \"done\": false }, { \"id\": 4, \"info\": \"Los Angeles battles huge wildfires.\", \"done\": false }] 再接着，打开main.js,添加store.js的引入，如下： 1234567891011121314151617import Vue from 'vue'import App from './App.vue'import store from './store.js'// 1. 导入 ant-design-vue 组件库import Antd from 'ant-design-vue'// 2. 导入组件库的样式表import 'ant-design-vue/dist/antd.css'Vue.config.productionTip = false// 3. 安装组件库Vue.use(Antd)new Vue({ store, render: h =&gt; h(App)}).$mount('#app') 再接着打开store.js，添加axios请求json文件获取数据的代码，如下： 123456789101112131415161718192021222324252627282930import Vue from 'vue'import Vuex from 'vuex'import axios from 'axios'Vue.use(Vuex)export default new Vuex.Store({ state: { //所有任务列表 list: [], //文本输入框中的值 inputValue: 'AAA' }, mutations: { initList(state, list) { state.list = list }, setInputValue(state,value){ state.inputValue = value } }, actions: { getList(context) { axios.get('/list.json').then(({ data }) =&gt; { console.log(data); context.commit('initList', data) }) } }}) 最后，代开App.vue文件，将store中的数据获取并展示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;a-input placeholder=&quot;请输入任务&quot; class=&quot;my_ipt&quot; :value=&quot;inputValue&quot; @change=&quot;handleInputChange&quot; /&gt; &lt;a-button type=&quot;primary&quot;&gt;添加事项&lt;/a-button&gt; &lt;a-list bordered :dataSource=&quot;list&quot; class=&quot;dt_list&quot;&gt; &lt;a-list-item slot=&quot;renderItem&quot; slot-scope=&quot;item&quot;&gt; &lt;!-- 复选框 --&gt; &lt;a-checkbox :checked=&quot;item.done&quot;&gt;{{item.info}}&lt;/a-checkbox&gt; &lt;!-- 删除链接 --&gt; &lt;a slot=&quot;actions&quot;&gt;删除&lt;/a&gt; &lt;/a-list-item&gt; &lt;!-- footer区域 --&gt; &lt;div slot=&quot;footer&quot; class=&quot;footer&quot;&gt; &lt;!-- 未完成的任务个数 --&gt; &lt;span&gt;0条剩余&lt;/span&gt; &lt;!-- 操作按钮 --&gt; &lt;a-button-group&gt; &lt;a-button type=&quot;primary&quot;&gt;全部&lt;/a-button&gt; &lt;a-button&gt;未完成&lt;/a-button&gt; &lt;a-button&gt;已完成&lt;/a-button&gt; &lt;/a-button-group&gt; &lt;!-- 把已经完成的任务清空 --&gt; &lt;a&gt;清除已完成&lt;/a&gt; &lt;/div&gt; &lt;/a-list&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { mapState } from 'vuex'export default { name: 'app', data() { return { // list:[] } }, created(){ // console.log(this.$store); this.$store.dispatch('getList') }, methods:{ handleInputChange(e){ // console.log(e.target.value) this.$store.commit('setInputValue',e.target.value) } }, computed:{ ...mapState(['list','inputValue']) }}&lt;/script&gt;&lt;style scoped&gt;#app { padding: 10px;}.my_ipt { width: 500px; margin-right: 10px;}.dt_list { width: 500px; margin-top: 10px;}.footer { display: flex; justify-content: space-between; align-items: center;}&lt;/style&gt; ####B.完成添加事项 首先，打开App.vue文件，给“添加事项”按钮绑定点击事件，编写处理函数 123456789101112131415//绑定事件&lt;a-button type=\"primary\" @click=\"addItemToList\"&gt;添加事项&lt;/a-button&gt;//编写事件处理函数methods:{ ...... addItemToList(){ //向列表中新增事项 if(this.inputValue.trim().length &lt;= 0){ return this.$message.warning('文本框内容不能为空') } this.$store.commit('addItem') } } 然后打开store.js编写addItem 123456789101112131415161718192021222324252627export default new Vuex.Store({ state: { //所有任务列表 list: [], //文本输入框中的值 inputValue: 'AAA', //下一个id nextId:5 }, mutations: { ........ //添加列表项 addItem(state){ const obj = { id :state.nextId, info: state.inputValue.trim(), done:false } //将创建好的事项添加到数组list中 state.list.push(obj) //将nextId值自增 state.nextId++ state.inputValue = '' } } ......}) ####C.完成删除事项 首先，打开App.vue文件，给“删除”按钮绑定点击事件，编写处理函数 1234567891011//绑定事件&lt;a slot=\"actions\" @click=\"removeItemById(item.id)\"&gt;删除&lt;/a&gt;//编写事件处理函数methods:{ ...... removeItemById(id){ //根据id删除事项 this.$store.commit('removeItem',id) } } 然后打开store.js编写addItem 12345678910111213export default new Vuex.Store({ ...... mutations: { ........ removeItem(state,id){ //根据id删除事项数据 const index = state.list.findIndex( x =&gt; x.id === id ) // console.log(index); if(index != -1) state.list.splice(index,1); } } ......}) ####D.完成选中状态的改变 首先，打开App.vue文件，给“复选”按钮绑定点击事件，编写处理函数 1234567891011121314151617//绑定事件&lt;a-checkbox :checked=\"item.done\" @change=\"cbStateChanged(item.id,$event)\"&gt;{{item.info}}&lt;/a-checkbox&gt;//编写事件处理函数methods:{ ...... cbStateChanged(id,e){ //复选框状态改变时触发 const param = { id:id, status:e.target.checked } //根据id更改事项状态 this.$store.commit('changeStatus',param) } } 然后打开store.js编写addItem 123456789101112export default new Vuex.Store({ ...... mutations: { ........ changeStatus(state,param){ //根据id改变对应事项的状态 const index = state.list.findIndex( x =&gt; x.id === param.id ) if(index != -1) state.list[index].done = param.status } } ......}) ####E.剩余项统计 打开store.js，添加getters完成剩余项统计 1234567getters:{ unDoneLength(state){ const temp = state.list.filter( x =&gt; x.done === false ) console.log(temp) return temp.length }} 打开App.vue，使用getters展示剩余项 1234567891011//使用映射好的计算属性展示剩余项&lt;!-- 未完成的任务个数 --&gt;&lt;span&gt;{{unDoneLength}}条剩余&lt;/span&gt;//导入gettersimport { mapState,mapGetters } from 'vuex'//映射computed:{ ...mapState(['list','inputValue']), ...mapGetters(['unDoneLength'])} ####F.清除完成事项 首先，打开App.vue文件，给“清除已完成”按钮绑定点击事件，编写处理函数 1234567891011&lt;!-- 把已经完成的任务清空 --&gt;&lt;a @click=\"clean\"&gt;清除已完成&lt;/a&gt;//编写事件处理函数methods:{ ...... clean(){ //清除已经完成的事项 this.$store.commit('cleanDone') }} 然后打开store.js编写addItem 12345678910export default new Vuex.Store({ ...... mutations: { ........ cleanDone(state){ state.list = state.list.filter( x =&gt; x.done === false ) } } ......}) ####G.点击选项卡切换事项 打开App.vue，给“全部”，“未完成”，“已完成”三个选项卡绑定点击事件，编写处理函数并将列表数据来源更改为一个getters。 1234567891011121314151617181920212223&lt;a-list bordered :dataSource=\"infoList\" class=\"dt_list\"&gt; ...... &lt;!-- 操作按钮 --&gt; &lt;a-button-group&gt; &lt;a-button :type=\"viewKey ==='all'?'primary':'default'\" @click=\"changeList('all')\"&gt;全部&lt;/a-button&gt; &lt;a-button :type=\"viewKey ==='undone'?'primary':'default'\" @click=\"changeList('undone')\"&gt;未完成&lt;/a-button&gt; &lt;a-button :type=\"viewKey ==='done'?'primary':'default'\" @click=\"changeList('done')\"&gt;已完成&lt;/a-button&gt; &lt;/a-button-group&gt; ......&lt;/a-list&gt;//编写事件处理函数以及映射计算属性methods:{ ...... changeList( key ){ //点击“全部”，“已完成”，“未完成”时触发 this.$store.commit('changeKey',key) }},computed:{ ...mapState(['list','inputValue','viewKey']), ...mapGetters(['unDoneLength','infoList'])} 打开store.js，添加getters，mutations，state 1234567891011121314151617181920212223242526272829export default new Vuex.Store({ state: { ...... //保存默认的选项卡值 viewKey:'all' }, mutations: { ...... changeKey(state,key){ //当用户点击“全部”，“已完成”，“未完成”选项卡时触发 state.viewKey = key } }, ...... getters:{ ....... infoList(state){ if(state.viewKey === 'all'){ return state.list } if(state.viewKey === 'undone'){ return state.list.filter( x =&gt; x.done === false ) } if(state.viewKey === 'done'){ return state.list.filter( x =&gt; x.done === true ) } } }})","link":"/2020/05/16/%E5%A4%A7%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Element","slug":"Element","link":"/tags/Element/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"大前端","slug":"大前端","link":"/tags/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"WebSocket","slug":"WebSocket","link":"/tags/WebSocket/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"跨域","slug":"跨域","link":"/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"PM2","slug":"PM2","link":"/tags/PM2/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"}],"categories":[{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"博客","slug":"博客","link":"/categories/%E5%8D%9A%E5%AE%A2/"}]}