<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JavaScript之混淆的类 - Radoapx&#039;s Zone</title><meta description="序言学习JavaScript时，如果你已经对C++、Java等传统面向对象编程语言有一定了解，或者老师教导过你使用类(类是面向对象编程的实现核心)把过程化风格的代码转换成结构清晰的代码，那么你很自然地会想在js中使用类。如在万物皆为类的Java中，严格区分类和对象，对象由类实例化而成，继承实际上是类的扩展。但JavaScript中只有对象，没有类，这是本质上的区别，可在JavaScript中有许多"><meta property="og:type" content="blog"><meta property="og:title" content="JavaScript之混淆的类"><meta property="og:url" content="http://yoursite.com/"><meta property="og:site_name" content="Radoapx&#039;s Zone"><meta property="og:description" content="序言学习JavaScript时，如果你已经对C++、Java等传统面向对象编程语言有一定了解，或者老师教导过你使用类(类是面向对象编程的实现核心)把过程化风格的代码转换成结构清晰的代码，那么你很自然地会想在js中使用类。如在万物皆为类的Java中，严格区分类和对象，对象由类实例化而成，继承实际上是类的扩展。但JavaScript中只有对象，没有类，这是本质上的区别，可在JavaScript中有许多"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/radoapx/rad-figure-bed/PicGo/blogs/js%E6%B7%B7%E6%B7%86%E7%9A%84%E7%B1%BB/20200514215003.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/radoapx/rad-figure-bed/PicGo/blogs/js%E6%B7%B7%E6%B7%86%E7%9A%84%E7%B1%BB/20200514215009.jpg"><meta property="article:published_time" content="2020-05-16T06:45:05.018Z"><meta property="article:modified_time" content="2020-05-16T06:45:05.018Z"><meta property="article:author" content="Radoapx"><meta property="article:tag" content="JavaScript"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/radoapx/rad-figure-bed/PicGo/blogs/js%E6%B7%B7%E6%B7%86%E7%9A%84%E7%B1%BB/20200514215003.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2020/05/16/%E5%8D%9A%E5%AE%A2/JavaScript%20%E4%B9%8B%E6%B7%B7%E6%B7%86%E7%9A%84%E2%80%9C%E7%B1%BB%E2%80%9D/"},"headline":"Radoapx's Zone","image":["https://cdn.jsdelivr.net/gh/radoapx/rad-figure-bed/PicGo/blogs/js%E6%B7%B7%E6%B7%86%E7%9A%84%E7%B1%BB/20200514215003.jpg","https://cdn.jsdelivr.net/gh/radoapx/rad-figure-bed/PicGo/blogs/js%E6%B7%B7%E6%B7%86%E7%9A%84%E7%B1%BB/20200514215009.jpg"],"datePublished":"2020-05-16T06:45:05.018Z","dateModified":"2020-05-16T06:45:05.018Z","author":{"@type":"Person","name":"Radoapx"},"description":"序言学习JavaScript时，如果你已经对C++、Java等传统面向对象编程语言有一定了解，或者老师教导过你使用类(类是面向对象编程的实现核心)把过程化风格的代码转换成结构清晰的代码，那么你很自然地会想在js中使用类。如在万物皆为类的Java中，严格区分类和对象，对象由类实例化而成，继承实际上是类的扩展。但JavaScript中只有对象，没有类，这是本质上的区别，可在JavaScript中有许多"}</script><link rel="canonical" href="http://yoursite.com/2020/05/16/%E5%8D%9A%E5%AE%A2/JavaScript%20%E4%B9%8B%E6%B7%B7%E6%B7%86%E7%9A%84%E2%80%9C%E7%B1%BB%E2%80%9D/"><link rel="icon" href="/img/favicon.svg"><script src="/live2d-widget/autoload.js"></script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?0b3fb888f3a355444b0a19c06a5721bf";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo%201000.png" alt="Radoapx&#039;s Zone" height="58"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/archives">时间轴</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="https://google.com">工坊(building)</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/radoapx"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-05-16T06:45:05.018Z" title="2020-05-16T06:45:05.018Z">2020-05-16</time><span class="level-item"><a class="link-muted" href="/categories/%E5%8D%9A%E5%AE%A2/">博客</a></span><span class="level-item">23 分钟 读完 (大约 3490 个字)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">JavaScript之混淆的类</h1><div class="content"><h4 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h4><p>学习JavaScript时，如果你已经对C++、Java等传统面向对象编程语言有一定了解，或者老师教导过你使用类(类是面向对象编程的实现核心)把过程化风格的代码转换成结构清晰的代码，那么你很自然地会想在js中使用类。如在万物皆为类的Java中，严格区分类和对象，对象由类实例化而成，继承实际上是类的扩展。但JavaScript中只有对象，没有类，这是本质上的区别，可在JavaScript中有许多模拟类的语法糖在试图掩盖这个事实，很多教程中并未对此作详细解释，而是直接教初学者使用这些语法糖，导致初学者会在无形中出现困惑。</p>
<a id="more"></a>

<p>虽然JavaScript中没有类，但俗话说“没有的才是最好的”，开发者们通过不断探索总结，成功地模拟出了“类”。由于大家定义类的方法五花八门，风格不一。对于模拟面向对象的封装、继承、多态，更有许多研究，实现办法更加晦涩，不利于JavaScript新手使用。</p>
<p>这就引出了本文的话题：JavaScript中类的机制。</p>
<h4 id="类的封装、继承与多态"><a href="#类的封装、继承与多态" class="headerlink" title="类的封装、继承与多态"></a>类的封装、继承与多态</h4><p>说到面向对象编程，不得不先了解类。</p>
<p>根据维基百科的定义，<strong>类</strong>(class)在面向对象编程中是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。有封装性、继承性、多态性三个最重要的特性。</p>
<p>类与<strong>继承</strong>抽象了一种代码的组织形式，一种编程领域对真实世界中问题的建模。比如，轮船可以被看做交通工具的一个特例，后者是更广泛的类，可以用<code>Vehicle</code>和<code>Steamer</code>两个类进行建模。Vehicle可以定义引擎、载人能力等几乎所有交通工具都具有的属性，而在具体的交通工具类中，定义同样的属性是没有意义的，所以在定义<code>Steamer</code>类时，只需声明它继承了<code>Vehicle</code>这个基类，那么它就能拥有基类的属性及方法。</p>
<p>有了<code>Steamer</code>类，就有了轮船的所有属性和行为，这便是类的<strong>封装</strong>。我们迫不及待地想上船航行，可类好比蓝图，正如轮船的图纸，并非真正可以交互的轮船，只有根据图纸建造出物理实物，才能上船。真的轮船便是蓝图的物理实例，本质上是对蓝图的复制，即<strong>实例化</strong>。</p>
<p>类的另一个核心概念是<strong>多态</strong>，指父类(基类)的通用行为可以被子类用特殊行为重写。如Vehicle类中为所有交通工具定义了一个<code>decelerate()</code>减速方法，默认操作是踩刹车，但在轮船的减速中，可能还需要抛锚，所以在<code>Steamer</code>类中，可以重写<code>decelerate()</code>方法，在引用<code>Vehicle</code>类中<code>decelerate()</code>方法的基础上再加一步抛锚操作。即任何方法都可引用继承层次中高层的方法(方法名可以不同)。</p>
<p>有以下伪代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    engines=<span class="number">1</span></span><br><span class="line">    startEngine()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'start engine 1'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    drive()&#123;</span><br><span class="line">        startEngine()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'driving'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Steamer</span> <span class="keyword">extends</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    engines=<span class="number">2</span><span class="comment">//轮船有两个引擎</span></span><br><span class="line">    startEngine()&#123;</span><br><span class="line">    	<span class="keyword">super</span>.startEngine()<span class="comment">//实现相对多态，调用父类的同名方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'start engine 2'</span>)<span class="comment">//增加自身需要的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    drive()&#123;<span class="comment">//重写了父类的方法</span></span><br><span class="line">        startEngine()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'sailing'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中<code>Steamer</code>下的<code>drive</code>方法会调用自身相对多态的<code>startEngine</code>方法，即多态性取决于引用的实例所来自的类。</p>
<p>可以看出，类是一种设计模式，只是Java等许多语言提供了面向类的原生语法，所以一般不为我们所感知，JavaScript也有类似的语法，但和其他语言中的类完全不同，这便是本文想解释清楚的地方。</p>
<p>类代表着复制，在Java等语言中，类被实例化时，它的行为会被复制到实例中，被继承时行为也会被复制到子类中，多态也是如此。但JavaScript的对象系统基于原型，而不是类，不会自动生成对象的副本。</p>
<h4 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h4><p>要想在JavaScript中优雅地使用“类”，首先需要了解JavaScript的“类”本质上是基于原型的继承。</p>
<p><strong>原型(Prototype)</strong>是JS对象的一个特殊内置属性，是对于其他对象的引用。创建一个方法时，会根据一组特定规则为该方法添加一个``prototype<code>属性，这个属性指向方法的原型对象。在默认情况下，原型对象会自动生成一个</code>constructor<code>属性，这个属性包含一个指向</code>prototype`属性所在函数对象的指针，如图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/radoapx/rad-figure-bed/PicGo/blogs/js%E6%B7%B7%E6%B7%86%E7%9A%84%E7%B1%BB/20200514215003.jpg" alt=""></p>
<p>需访问一个对象的属性时，先在对象的本身上查找，如果找不到引擎就会继续在``prototype<code>所关联的对象上继续查找，直到找到为止，</code>prototype<code>最终都指向</code>Object.prototype`。这一系列查找对象的链接即是<strong>原型链</strong>。如下图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/radoapx/rad-figure-bed/PicGo/blogs/js%E6%B7%B7%E6%B7%86%E7%9A%84%E7%B1%BB/20200514215009.jpg" alt=""></p>
<h5 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.a = <span class="number">1</span></span><br><span class="line">   <span class="keyword">this</span>.b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = <span class="keyword">new</span> f(); <span class="comment">// &#123;a: 1, b: 2&#125;</span></span><br><span class="line"><span class="comment">// 在f函数的原型上定义属性</span></span><br><span class="line">f.prototype.b = <span class="number">3</span>;</span><br><span class="line">f.prototype.c = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可得原型链如下: </span></span><br><span class="line"><span class="comment">// &#123;a:1, b:2&#125; ---&gt; &#123;b:3, c:4&#125; ---&gt; Object.prototype---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g.a) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// a是g自身的属性，值为 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g.b) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// b是g自身的属性，值为 2</span></span><br><span class="line"><span class="comment">// 原型上也有一个'b'属性，但是它不会被访问到。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g.c) <span class="comment">// 4</span></span><br><span class="line"><span class="comment">// c不是g的自身属性，那看看它的原型上有没有</span></span><br><span class="line"><span class="comment">// c是g.[[Prototype]]属性该属性的值为 4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g.d) <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// d 不是 g 的自身，那看看它的原型上有没有</span></span><br><span class="line"><span class="comment">// d 不是 g.[[Prototype]] 的属性，那看看它的原型上有没有</span></span><br><span class="line"><span class="comment">// g.[[Prototype]].[[Prototype]] 为 null，停止搜索</span></span><br><span class="line"><span class="comment">// 无 d 属性，故为 undefined</span></span><br></pre></td></tr></table></figure>

<p>上例中<code>console.log(g.b)</code>时输出2而不是3，即’b’属性既出现在g中也出现在了g的原型链上层，那么会触发<strong>屏蔽</strong>，即g中的’b’属性会屏蔽原型链上层的所有’b’属性。这种情况相当于其他语言的方法重写。</p>
<h5 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(o.m()) <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 当调用 o.m 时，'this' 指向了 o.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">Object</span>.create(o)</span><br><span class="line"><span class="comment">// p是一个继承自 o 的对象</span></span><br><span class="line">p.a = <span class="number">4</span> <span class="comment">// 创建 p 的自身属性 'a'</span></span><br><span class="line"><span class="built_in">console</span>.log(p.m()) <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 调用 p.m 时，'this' 指向了 p</span></span><br><span class="line"><span class="comment">// 又因为 p 继承了 o 的 m 函数</span></span><br><span class="line"><span class="comment">// 所以，此时的 'this.a' 即 p.a，就是 p 的自身属性 'a'</span></span><br></pre></td></tr></table></figure>

<p>JavaScript没有那些基于类的语言定义的“方法”。JavaScript中，任何函数(方法)都可以添加到对象上作为对象的属性。函数的继承与其他的属性继承没有差别，包括上面的“<strong>屏蔽</strong>”。继承的函数被调用时，this指向当前继承的对象，而不是继承的函数所在的原型对象。</p>
<p>Object.create(obj)返回一个与obj的<code>prototype</code>关联的对象，实现了p对于o的“继承”，虽然p对象并无a属性，但访问时若原对象无此属性，便会顺着其prototype链一直查找，直到prototype的尽头——Object.prototype，因此顺着prototype链访问到了o的a属性，是不是有点继承的感觉了？</p>
<h4 id="模拟“类”"><a href="#模拟“类”" class="headerlink" title="模拟“类”"></a>模拟“类”</h4><p>所以，在JavaScript中使用类，ES6之前大多为用函数模拟。回到上面Vehicle与Steamer的伪代码，用js代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vehicle</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = props.id||<span class="string">'not bind'</span></span><br><span class="line">    <span class="keyword">this</span>.engines=props.engines||<span class="string">'not bind'</span></span><br><span class="line">&#125;</span><br><span class="line">Vehicle.prototype.startEngine = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start engine '</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Steamer</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用Vehicle构造函数，绑定this</span></span><br><span class="line">    Vehicle.call(<span class="keyword">this</span>, props)</span><br><span class="line">    <span class="keyword">this</span>.cabin = props.cabin || <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> titanic = <span class="keyword">new</span> Steamer(&#123; <span class="attr">cabin</span>: <span class="number">10</span>, <span class="attr">id</span>: <span class="string">'12412321'</span>, <span class="attr">engines</span>: <span class="number">10</span> &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(titanic);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(titanic));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.getPrototypeOf(titanic)));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.getPrototypeOf(titanic))));</span><br><span class="line"><span class="comment">//Steamer &#123; id: '12412321', engines: 10, cabin: 10 &#125;</span></span><br><span class="line"><span class="comment">//Steamer &#123;&#125;</span></span><br><span class="line"><span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="comment">//null</span></span><br></pre></td></tr></table></figure>

<p>但调用了Vehicle()作为“构造函数”不代表继承了Vehicle，Steamer创建的对象原型是``new Steamer()–&gt; Steamer.prototype–&gt; Object.prototype–&gt; null<code>，继承关系的原型链应为</code>new Steamer() –&gt; Steamer.prototype–&gt; Vehicle.prototype–&gt; Object.prototype–&gt; null<code>，这样新的Steamer对象不仅能调用</code>Steamer.prototype<code>绑定的方法，也可以使用</code>Vehicle.prototype<code>绑定的方法。但要想达到这个状态，直接</code>Steamer.prototype = Vehicle.prototype`是不行的，这样两者指向同一个对象，继承关系就不存在了。此时需要借助一个中间对象，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vehicle</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = props.id||<span class="string">'not bind'</span></span><br><span class="line">    <span class="keyword">this</span>.engines=props.engines||<span class="string">'not bind'</span></span><br><span class="line">&#125;</span><br><span class="line">Vehicle.prototype.startEngine = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start engine '</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Steamer</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用Vehicle构造函数，绑定this</span></span><br><span class="line">    Vehicle.call(<span class="keyword">this</span>, props)</span><br><span class="line">    <span class="keyword">this</span>.cabin = props.cabin || <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tmp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Tmp.prototype = Vehicle.prototype</span><br><span class="line"><span class="comment">//把Steamer的原型指向一个新Tmp对象，Tmp对象的原型正好指向Vehicle.prototype</span></span><br><span class="line">Steamer.prototype = <span class="keyword">new</span> Tmp()</span><br><span class="line"><span class="comment">// 把Steamer原型的“构造函数”变回Steamer</span></span><br><span class="line">Steamer.prototype.constructor = Steamer</span><br><span class="line"></span><br><span class="line">Steamer.prototype.getCabin = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cabin</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> titanic=<span class="keyword">new</span> Steamer(&#123;</span><br><span class="line">    cabin:<span class="number">9999</span>,</span><br><span class="line">    engines:<span class="number">4</span>,</span><br><span class="line">    id:<span class="string">'21435452378454'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(titanic.cabin)<span class="comment">//9999</span></span><br><span class="line"><span class="built_in">console</span>.log(titanic.engines)<span class="comment">//4</span></span><br><span class="line"><span class="comment">//继承关系验证</span></span><br><span class="line">titanic <span class="keyword">instanceof</span> Steamer<span class="comment">//true</span></span><br><span class="line">titanic <span class="keyword">instanceof</span> Vehicle<span class="comment">//true</span></span><br><span class="line"><span class="comment">//查看原型链</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(titanic));</span><br><span class="line"><span class="comment">//Steamer &#123; constructor: [Function: Steamer], getCabin: [Function] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.getPrototypeOf(titanic)));</span><br><span class="line"><span class="comment">//Vehicle &#123; startEngine: [Function] &#125;</span></span><br></pre></td></tr></table></figure>

<p>由于Tmp()仅用于两者继承的连接，所以可以用一个函数把这个行为封装起来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Tmp</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    Tmp.prototype=f</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Tmp()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这即是<code>Object.create()</code>的简单实现。<code>Object.create()</code>创建一个新对象，使用现有的对象来提供新创建的对象的prototype。</p>
<p><code>Steamer.prototype.constructor = Steamer</code>的作用是补上constructor属性(默认对象的prototype都有这个属性，可以理解为“构造函数”，一般指向函数自身，即<code>new Son()</code>时调用<code>Son()</code>来“构造”一个新对象，这个新对象的prototype与Son.prototype相关联)，如果将这里也封装进函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">son, father</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(father.prototype);<span class="comment">// 创建对象，注意！这里和Tmp()方式相同</span></span><br><span class="line">  prototype.constructor = son;</span><br><span class="line">  son.prototype = prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽离出来的<code>extend</code>方法被称作<strong>寄生组合式继承</strong>，是目前最成熟的方法，仅使用<code>Object.create()</code>而不补上<code>constructor</code>被称作<strong>原型式继承</strong>，缺点是原型链继承多个实例的引用类型属性指向相同，可能被篡改，以及无法传递参数。还有<strong>混入</strong>、<strong>寄生式</strong>等几种方式实现继承，各有各的优缺点，就不一一赘述了。</p>
<p>下面你会读到<code>extends</code>关键字，什么？和上面的<code>extend</code>很像？没错，<code>extends</code>关键字的核心实现就是<strong>寄生组合式继承</strong>，不然怎么叫语法糖。</p>
<h4 id="class-关键字"><a href="#class-关键字" class="headerlink" title="class 关键字"></a>class 关键字</h4><p>ECMAScript 6规范中，引入了<code>class</code>的概念。使得 JS 开发者终于告别了直接使用原型对象模仿面向对象中的类和类继承的时代。但是 <code>class</code> 仅仅只是对原型对象运用语法糖，如果认为它像其它面向类语言中的<code>class</code>那样，使用时只会增加新手的困惑。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typeof</span> P <span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<p>可以看出，一个class实际上就是function。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">this</span>.engines = props.engines;</span><br><span class="line">    <span class="keyword">this</span>.id = props.id;</span><br><span class="line">  &#125;</span><br><span class="line">  startEngine() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"start "</span>,<span class="keyword">this</span>.engines,<span class="string">' engines'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Steamer</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.cabin = props.cabin;</span><br><span class="line">  &#125;</span><br><span class="line">  getCabin() &#123;</span><br><span class="line">    <span class="keyword">this</span>.startEngine();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"I have"</span>, <span class="keyword">this</span>.cabin, <span class="string">" cabins"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> titanic = <span class="keyword">new</span> Steamer(&#123;</span><br><span class="line">  cabin: <span class="number">9999</span>,</span><br><span class="line">  engines: <span class="number">4</span>,</span><br><span class="line">  id: <span class="string">"21435452378454"</span></span><br><span class="line">&#125;);</span><br><span class="line">titanic.getCabin(); </span><br><span class="line"><span class="comment">//start  4  engines</span></span><br><span class="line"><span class="comment">//I have 9999  cabins</span></span><br></pre></td></tr></table></figure>

<p>当titanic调用 <code>getCabin</code>方法时，titanic自身没有需要的 <code>startEngine</code>方法，所以会到 <code>titanic.prototype</code> 原型对象上查找，最后调用``Vehicle.prototype<code>原型对象上的</code>startEngine<code>方法。调用时，</code>this` 指向的是titanic对象。</p>
<p>实际上，ECMAScript 6中的<code>class</code>仍然遵循你了解的JavaScript模式，继承的原理还和以前一样基于原型链，方法添加在原型上，只是用了更简单的关键字来代替，却隐藏了许多问题，要说优点可能只有一个:可以打更少的字。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>传统基于类的面向对象思维在一定程度上妨碍了大家对JavaScript面向对象特性的理解，虽然这些机制和Java等传统面向类语言中的“类初始化”“继承”很像，但JavaScript有一个本质区别就是不会进行复制，对象之间通过内部的prototype链进行关联。所以说，在一定程度上JavaScript模拟类是得不偿失的，可解决当前问题，更可埋下隐患。实际上，对象之间的关系用<strong>委托</strong>形容更加贴切。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><blockquote>
<ul>
<li><p>类 (计算机科学)——维基百科</p>
</li>
<li><p>《你不知道的JavaScript》——KYLE SIMPSON</p>
</li>
<li><p>《JavaScript继承机制研究》—— 周 岚</p>
</li>
<li><p>《JavaScript需要类吗?》——紫云飞</p>
</li>
<li><p>《继承与原型链》——MDN web docs</p>
</li>
<li><p>《原型继承》——廖雪峰的官方网站</p>
</li>
<li><p>《JavaScript常用八种继承方案》——木易杨说</p>
</li>
</ul>
</blockquote>
</div><div class="article-tags size-small is-uppercase mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/JavaScript/">JavaScript</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=5e987269931c3700123db905&amp;product=inline-share-buttons" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://cdn.jsdelivr.net/gh/radoapx/rad-figure-bed/PicGo/blog/donates/20200416220326.JPG" alt="支付宝"></span></a><a class="button is-warning donate" onclick="document.getElementById(&#039;paypal-donate-form&#039;).submit()"><span class="icon is-small"><i class="fab fa-paypal"></i></span><span>Paypal</span></a><form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_blank" rel="noopener" id="paypal-donate-form"><input type="hidden" name="cmd" value="_donations"><input type="hidden" name="business" value="845225343@qq.com"><input type="hidden" name="currency_code" value="USD"></form><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://cdn.jsdelivr.net/gh/radoapx/rad-figure-bed/PicGo/blog/donates/20200416220459.JPG" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/05/16/%E5%A4%A7%E5%89%8D%E7%AB%AF/CSS/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">CSS</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/05/16/%E5%8D%9A%E5%AE%A2/%E5%88%A9%E7%94%A8Element%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%BC%E8%88%AA%E6%A0%8F/"><span class="level-item">利用Element实现响应式导航栏</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="/img/avatar.jpeg" alt="radoapx"></figure><p class="title is-size-4 is-block line-height-inherit">radoapx</p><p class="is-size-6 is-block">代码&amp;生活</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Njtech,China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">17</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">16</p></a></div></div></nav><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/radoapx"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/keep_escalating"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Gmail" href="mailto:radoapx@gmail.com"><i class="fas fa-envelope"></i></a></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-05-16T06:45:05.029Z">2020-05-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/05/16/%E8%BF%90%E7%BB%B4/PM2/">PM2</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-05-16T06:45:05.028Z">2020-05-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/05/16/%E8%BF%90%E7%BB%B4/Nginx/">Nginx</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-05-16T06:45:05.027Z">2020-05-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/05/16/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E8%B7%A8%E5%9F%9F/">跨域相关</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-05-16T06:45:05.026Z">2020-05-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/05/16/%E5%A4%A7%E5%89%8D%E7%AB%AF/webpack/">Webpack 笔记</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-05-16T06:45:05.024Z">2020-05-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/05/16/%E5%A4%A7%E5%89%8D%E7%AB%AF/vue/">Vue 笔记</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://www.apple.com.cn/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Apple</span></span><span class="level-right"><span class="level-item tag">www.apple.com.cn</span></span></a></li><li><a class="level is-mobile is-mobile" href="http://acm.hdu.edu.cn/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">HDU OJ</span></span><span class="level-right"><span class="level-item tag">acm.hdu.edu.cn</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://www.trumangu.fun/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">TrumanGu</span></span><span class="level-right"><span class="level-item tag">www.trumangu.fun</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#序言"><span class="mr-2">1</span><span>序言</span></a></li><li><a class="is-flex" href="#类的封装、继承与多态"><span class="mr-2">2</span><span>类的封装、继承与多态</span></a></li><li><a class="is-flex" href="#原型继承"><span class="mr-2">3</span><span>原型继承</span></a><ul class="menu-list"><li><a class="is-flex" href="#继承属性"><span class="mr-2">3.1</span><span>继承属性</span></a></li><li><a class="is-flex" href="#继承方法"><span class="mr-2">3.2</span><span>继承方法</span></a></li></ul></li><li><a class="is-flex" href="#模拟“类”"><span class="mr-2">4</span><span>模拟“类”</span></a></li><li><a class="is-flex" href="#class-关键字"><span class="mr-2">5</span><span>class 关键字</span></a></li><li><a class="is-flex" href="#总结"><span class="mr-2">6</span><span>总结</span></a></li><li><a class="is-flex" href="#参考文献"><span class="mr-2">7</span><span>参考文献</span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/%E5%8D%9A%E5%AE%A2/"><span class="level-start"><span class="level-item">博客</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">笔记</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/CSS/"><span class="tag">CSS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Element/"><span class="tag">Element</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML/"><span class="tag">HTML</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTTP/"><span class="tag">HTTP</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Nginx/"><span class="tag">Nginx</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PM2/"><span class="tag">PM2</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Vue/"><span class="tag">Vue</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WebSocket/"><span class="tag">WebSocket</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/node/"><span class="tag">node</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/webpack/"><span class="tag">webpack</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%A7%E5%89%8D%E7%AB%AF/"><span class="tag">大前端</span><span class="tag is-grey-lightest">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><span class="tag">正则表达式</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B7%A8%E5%9F%9F/"><span class="tag">跨域</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo%201000.png" alt="Radoapx&#039;s Zone" height="28"></a><p class="size-small"><span>&copy; 2020 Radoapx</span>  Surreptitious <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/radoapx"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>